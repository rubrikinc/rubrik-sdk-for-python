# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

interface AwsNativeAccountDescendantType {
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

interface AwsNativeAccountLogicalChildType {
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

"A Blueprint"
interface Blueprint {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "list of children"
    children: [BlueprintChild!]!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "status of the last test failover"
    currentFailoverStatus: AppBlueprintFailoverStatusEnum!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "relic status of the Blueprint"
    isRelic: Boolean!
    "last failover"
    lastFailover: Failover
    "last test failover"
    lastTestFailover: Failover
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "number of child snappables of the Blueprint"
    numChildren: Int!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "resource mapping status of the Blueprint"
    rmStatus: AppBlueprintRmStatusEnum!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
    "status of the Blueprint"
    status: AppBlueprintStatusEnum!
}

"Blueprint Child"
interface BlueprintChild {
    "boot priority"
    bootPriority: Int!
    "child fid"
    fid: UUID!
}

"A Blueprint failover instance"
interface BlueprintFailoverInstance {
    "blueprint child snappable id"
    snappableId: String!
}

"A CDM Managed Hierarchy Object"
interface CdmHierarchyObject {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

"A Managed Hierarchy Snappable"
interface CdmHierarchySnappableNew {
    "The ID of the snappable on the Rubrik CDM cluster."
    cdmId: String!
    "A link to view the snappable on the CDM cluster. For dev use only."
    cdmLink: String!
    "The cluster from which this snappable originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The list of missed snapshots for this VM"
    missedSnapshotConnection(
        after: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        first: Int
    ): MissedSnapshotCommonConnection
    "The list of missed snapshots for this VM"
    missedSnapshotGroupByConnection(
        after: String,
        before: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        first: Int,
        "group snapshots by field"
        groupBy: MissedSnapshotGroupByEnum!,
        last: Int,
        timezoneOffset: Float = 0.0
    ): MissedSnapshotGroupByConnection
    "The name of the hierarchy object."
    name: String!
    "the newest snapshot archived to AWS."
    newestArchivedSnapshot: CdmSnapshot
    "the newest snapshot replicated to a cluster."
    newestReplicatedSnapshot: CdmSnapshot
    "the most recent snapshot of this snappable"
    newestSnapshot: CdmSnapshot
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "the oldest snapshot of this snappable"
    oldestSnapshot: CdmSnapshot
    "the number of on-demand snapshots"
    onDemandSnapshotCount: Int!
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The list of snapshots taken for this VM"
    snapshotConnection(
        after: String,
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        first: Int,
        last: Int,
        "sort snapshots by field"
        sortBy: CdmSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): CdmSnapshotConnection
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this VM's snapshots."
    snapshotGroupByConnection(
        after: String,
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        first: Int,
        "group snapshots by field"
        groupBy: CdmSnapshotGroupByEnum!,
        last: Int,
        timezoneOffset: Float = 0.0
    ): cdmSnapshotGroupByConnection
}

"Cloud Account (AWS, Azure etc.) Info"
interface CloudAccount {
    "The id of this Cloud Account"
    cloudAccountId: String!
    "The type of this Cloud Provider."
    cloudProvider: CloudProviderTypeEnum!
    "The connection status of this Cloud Account."
    connectionStatus: ConnectionStatusType!
    "The description of this Cloud Account"
    description: String
    "The name of this Cloud Account"
    name: String!
}

interface DisplayableValue {
    displayValue: String!
    serializedValue: String!
}

interface FilesetTemplateDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

interface FilesetTemplatePhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

interface GcpNativeProjectDescendantType {
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

interface GcpNativeProjectLogicalChildType {
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

"A generic snapshot type"
interface GenericSnapshot {
    "The date of the snapshot."
    date: DateTime!
    "The expirationDate of the snapshot."
    expirationDate: DateTime
    "The id of the snapshot."
    id: UUID!
    "The number of indexing attempts for the snapshot."
    indexingAttempts: Long!
    "Whether or not the snapshot is corrupted."
    isCorrupted: Boolean!
    "Whether or not the snapshot is expired"
    isExpired: Boolean!
    "Whether or not the snapshot is indexed."
    isIndexed: Boolean!
    "Whether the snapshot is an on-demand snapshot"
    isOnDemandSnapshot: Boolean!
    "Whether or not the snapshot is unindexable."
    isUnindexable: Boolean!
    "The snappableId of the snapshot."
    snappableId: String!
}

"A Managed Hierarchy Object"
interface HierarchyObject {
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

"A Generic Hierarchy Snappable"
interface HierarchySnappable {
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

interface HostShareDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

interface HostSharePhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

interface O365AppObject {
    "The added time of the O365 app."
    addedAt: DateTime!
    "The id of the O365 app."
    appId: String!
    "The owner of the O365 app (RUBRIK or CUSTOMER)."
    appOwner: String!
    "The type of the O365 app (e.g. ONEDRIVE)"
    appType: String!
    "The authentication status of the app against the subscription"
    isAuthenticated: Boolean!
    "The subscription to which the O365 app is associated."
    subscription: String!
}

interface O365ExchangeObject {
    "The id of the O365 exchange object."
    id: String!
    "The parent folder id of the object (ROOT indicates root folder)."
    parentFolderId: String
}

interface O365OnedriveObject {
    "The creation time of the onedrive object"
    createTime: DateTime
    "The id of the O365 onedrive object."
    id: String!
    "The modified time of the onedrive object"
    modifiedTime: DateTime
    "The name of the onedrive object"
    name: String
    "The parent folder id of the object (ROOT indicates root folder)."
    parentFolderId: String
    "The size of the onedrive object or its contents in bytes"
    size: Long
}

interface O365OrgDescendant {
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

interface O365SharepointObject {
    "The sharepoint object ID"
    objectId: String!
    "The parent id of the object"
    parentId: String!
    "The title or name of the sharepoint object"
    title: String!
}

interface O365UserDescendant {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

interface PhysicalHostDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

interface PhysicalHostPhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

"A Polaris Managed Hierarchy Object"
interface PolarisHierarchyObject {
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

"A Polaris Snappable"
interface PolarisHierarchySnappable {
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "the newest snapshot that is indexed and unexpired, and therefore restorable."
    newestIndexedSnapshot: PolarisSnapshot
    "the most recent snapshot of this snappable"
    newestSnapshot: PolarisSnapshot
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "the oldest snapshot of this snappable"
    oldestSnapshot: PolarisSnapshot
    "the number of on-demand snapshots"
    onDemandSnapshotCount: Int!
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The list of snapshots taken for this snappable"
    snapshotConnection(
        after: String,
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        first: Int,
        last: Int,
        "sort polaris snapshots by field"
        sortBy: PolarisSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): PolarisSnapshotConnection
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByConnection(
        after: String,
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        first: Int,
        "group polaris snapshots by field"
        groupBy: PolarisSnapshotGroupByEnum!,
        last: Int,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByConnection
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByNewConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "filter polaris snapshot connection"
        snapshotFilter: [PolarisSnapshotFilterNewInput!]!,
        "group polaris snapshots by field"
        snapshotGroupBy: SnapshotGroupByTimeEnum!,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByNewConnection
    "The list of snapshots taken for this snappable"
    snapshotsOfSnappableConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        snappableId: String!,
        "filter for snapshot connection"
        snapshotFilter: [SnapshotQueryFilterInput!],
        sortBy: SnapshotQuerySortByField,
        "sort order"
        sortOrder: SortOrderEnum,
        timeRange: TimeRangeInput
    ): GenericSnapshotConnection
}

interface ProtectedObjectSummary {
    "The effective sla of the protected object (if defined)."
    effectiveSlaOpt: String
    "The id of the protected object."
    id: String!
    "Whether the protected object is archived."
    isArchived: Boolean!
    "The name of the protected object."
    name: String!
    "The object type of the protected object (if returned)"
    objectType: ManagedObjectType
}

"A Recovery Spec"
interface RecoverySpec {
    "recovery spec version"
    userData: String
    "recovery spec version"
    version: Long!
}

"A Resource Spec"
interface ResourceSpec {
    "resource spec is archived"
    isArchived: Boolean!
    "resource spec child snappable id"
    snappableId: String!
    "resource spec child snappable name"
    snappableName: String!
    "resource spec child snapshot id"
    snapshotId: String!
}

interface SapHanaSystemDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

interface SapHanaSystemPhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

interface SlaDomain {
    "The id of the SLA Domain."
    id: String!
    "The name of the SLA Domain."
    name: String!
}

"Target Info to be used for archival or replication"
interface Target {
    "The cluster to which this target belongs"
    cluster: Cluster!
    "The id of this Target"
    id: String!
    "The pause/resume status of this Target"
    isActive: Boolean!
    "Whether this Target is archived"
    isArchived: Boolean!
    "The name of this Target"
    name: String!
    "The type of this Target"
    targetType: TargetTypeEnum!
}

"Target Template to be used for automatic archival group"
interface TargetTemplate {
    "The type of this Target"
    targetType: TargetTypeEnum!
}

interface VSphereComputeClusterDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

interface VSphereComputeClusterPhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

interface VSphereDatacenterDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

interface VSphereDatacenterLogicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

interface VSphereDatacenterPhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

interface VSphereFolderDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

interface VSphereFolderLogicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

interface VSphereHostDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

interface VSphereHostPhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

interface VSphereTagCategoryDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

interface VSphereTagCategoryTagChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

interface VSphereTagDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

interface VSphereTagTagChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

interface VSphereVCenterDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

interface VSphereVCenterLogicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

interface VSphereVCenterPhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

interface VSphereVCenterTagChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

interface Value {
    serializedValue: String!
}

interface VcdOrgDescendant {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

union ActivitySeriesGroupByInfo = ActivityObjectType | ActivityStatus | ActivityType | Cluster | ClusterType | TimeRangeWithUnit

union AnomalyResultGroupByInfo = AnomalyStatus | Cluster | Snappable | TimeRangeWithUnit

union CdmSnapshotGroupByInfo = TimeRangeWithUnit

union ClusterGroupByInfo = ClusterType | TimeRangeWithUnit

union ClusterMetricGroupByInfo = TimeRangeWithUnit

union CustomReportGroupByInfo = ReportFocus

union FailoverGroupByInfo = FailoverStatus | FailoverType | LastTestStatus | Source | TargetSite | TimeRangeWithUnit

union MissedSnapshotGroupByInfo = TimeRangeWithUnit

union PolarisSnapshotGroupByInfo = TimeRangeWithUnit

union RansomwareResultGroupByInfo = Cluster | Snappable | TimeRangeWithUnit

"All the possible chart types."
union ReportChartType = ActivityChart | AnomalyChart | FailoverChart | InfrastructureChart | SnappableChart | SonarContentReportChart | SonarReportChart | TaskDetailChart | TaskSummaryChart | UserAuditChart

"All the possible table types."
union ReportTableType = ActivityTable | AnomalyTable | FailoverTable | InfrastructureTable | SnappableTable | SonarContentReportTable | SonarReportTable | TaskDetailTable | TaskSummaryTable | UserAuditTable

union SnappableGroupByInfo = Cluster | ClusterSlaDomain | ClusterType | ComplianceStatus | ObjectType | ProtectionStatus | TimeRangeWithUnit

union TaskDetailGroupByInfo = Cluster | Status | TaskDetailClusterType | TaskDetailObjectType | TimeRangeWithUnit

union TaskSummaryGroupByInfo = Cluster | ClusterType | GlobalSla | ObjectType | PolarisHierarchySnappableObject | TimeRangeWithUnit

union UpgradeGroupByInfo = ClusterJobStatusType | ClusterType

union UserAuditGroupByInfo = Cluster | ClusterType | TimeRangeWithUnit | UserAuditObjectType | UserAuditStatus | UserAuditType

type ADObject {
    cn: String!
    distinguishedName: String!
    emailAddress: String!
    memberOf: String!
    objectCategory: String!
    objectClass: String!
    objectGuid: String!
    objectSid: String!
    paginationId: Int!
}

type ADObjectConnection {
    count: Int!
    edges: [ADObjectEdge!]!
    nodes: [ADObject!]!
    pageInfo: PageInfo!
}

type ADObjectEdge {
    cursor: String!
    node: ADObject!
}

type ASPKey {
    account: String!
    component: ComponentEnum!
    name: String!
}

type ASPValue {
    key: ASPKey
    value: String!
}

"additional information about the vcenter object, such as name, version, os type, and api type, only available on clusters 5.1+"
type AboutInformation {
    apiType: String!
    name: String!
    osType: String!
    version: String!
}

type AccountSetting {
    isEmailNotificationEnabled: Boolean
    isEulaAccepted: Boolean
}

type Activity {
    activityInfo: String
    activitySeries: ActivitySeries!
    clusterId: UUID!
    id: ID!
    message: String!
    objectId: String!
    objectType: ActivityObjectTypeEnum!
    progress: String
    severity: ActivitySeverityEnum!
    status: ActivityStatusEnum!
    time: DateTime!
    type: ActivityTypeEnum!
}

type ActivityChart {
    focus: ReportFocusEnum!
    groupBy: [ActivitySeriesGroupByEnum!]
    name: String!
}

type ActivityConnection {
    count: Int!
    edges: [ActivityEdge!]!
    nodes: [Activity!]!
    pageInfo: PageInfo!
}

type ActivityEdge {
    cursor: String!
    node: Activity!
}

type ActivityObjectType {
    enumValue: ActivityObjectTypeEnum!
}

type ActivitySeries {
    activityConnection(after: String, before: String, first: Int, last: Int): ActivityConnection!
    activitySeriesId: UUID!
    cluster: Cluster
    clusterName: String!
    clusterUuid: UUID!
    failureReason: String
    fid: UUID
    id: Long!
    isCancelable: Boolean
    isPolarisEventSeries: Boolean!
    lastActivityStatus: ActivityStatusEnum!
    lastActivityType: ActivityTypeEnum!
    lastEventAddedAt: DateTime
    lastUpdated: DateTime!
    lastVerifiedAt: DateTime
    location: String!
    objectId: String!
    objectName: String
    objectType: ActivityObjectTypeEnum!
    progress: String
    severity: ActivitySeverityEnum!
    startTime: DateTime
}

type ActivitySeriesConnection {
    count: Int!
    edges: [ActivitySeriesEdge!]!
    nodes: [ActivitySeries!]!
    pageInfo: PageInfo!
}

type ActivitySeriesEdge {
    cursor: String!
    node: ActivitySeries!
}

"Activity series data with groupby info applied to it."
type ActivitySeriesGroupBy {
    "Paginated activity series data."
    activitySeriesConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "sort activity series by field"
        sortBy: ActivitySeriesSortByEnum = LastUpdated
    ): ActivitySeriesConnection!
    "Further provide groupings for the data."
    activitySeriesGroupBy(
        "group activity series by a field"
        groupBy: ActivitySeriesGroupByEnum!
    ): [ActivitySeriesGroupBy!]!
    "The data groupby info."
    groupByInfo: ActivitySeriesGroupByInfo!
}

type ActivitySeriesGroupByConnection {
    count: Int!
    edges: [ActivitySeriesGroupByEdge!]!
    nodes: [ActivitySeriesGroupBy!]!
    pageInfo: PageInfo!
}

type ActivitySeriesGroupByEdge {
    cursor: String!
    node: ActivitySeriesGroupBy!
}

type ActivityStatus {
    enumValue: ActivityStatusEnum!
}

type ActivitySummaryByUser {
    numCreates: Int!
    numDeletes: Int!
    numReads: Int!
    numWrites: Int!
    paginationId: String!
    sid: String!
    user: String!
}

type ActivitySummaryByUserConnection {
    count: Int!
    edges: [ActivitySummaryByUserEdge!]!
    nodes: [ActivitySummaryByUser!]!
    pageInfo: PageInfo!
}

type ActivitySummaryByUserEdge {
    cursor: String!
    node: ActivitySummaryByUser!
}

type ActivityTable {
    focus: ReportFocusEnum!
    groupBy: [ActivitySeriesGroupByEnum!]
    name: String!
    selectedColumns: [ActivityTableColumnEnum!]!
    sortBy: ActivitySeriesSortByEnum
    sortOrder: SortOrderEnum
}

type ActivityType {
    enumValue: ActivityTypeEnum!
}

"Add O365 Org response"
type AddO365OrgResponse {
    orgId: String!
    refreshOrgTaskchainId: String!
}

type AddressBlockV4 {
    cidrBlock: String!
}

"The status of the agent running on the vm"
type AgentStatus {
    agentStatus: AgentConnectStatusEnum!
    disconnectReason: String
}

type Analyzer {
    analyzerType: AnalyzerTypeEnum!
    dictionary: [String!]!
    dictionaryCsv: String!
    id: String!
    name: String!
    regex: String!
}

type AnalyzerConnection {
    count: Int!
    edges: [AnalyzerEdge!]!
    nodes: [Analyzer!]!
    pageInfo: PageInfo!
}

type AnalyzerEdge {
    cursor: String!
    node: Analyzer!
}

type AnalyzerGroup {
    analyzers: [Analyzer!]!
    groupType: AnalyzerGroupTypeEnum!
    id: String!
    name: String!
}

type AnalyzerGroupConnection {
    count: Int!
    edges: [AnalyzerGroupEdge!]!
    nodes: [AnalyzerGroup!]!
    pageInfo: PageInfo!
}

type AnalyzerGroupEdge {
    cursor: String!
    node: AnalyzerGroup!
}

type AnalyzerGroupResult {
    analyzerGroup: AnalyzerGroup!
    analyzerResults: [AnalyzerResult!]!
    hits: Hits!
}

type AnalyzerMapping {
    analyzerResult: AnalyzerResult!
    groups: [AnalyzerGroup!]!
}

type AnalyzerResult {
    analyzer: Analyzer!
    hits: Hits!
}

type AnalyzerUsage {
    analyzer: Analyzer!
    policies: [ClassificationPolicySummary!]!
}

type AnalyzerUsageConnection {
    count: Int!
    edges: [AnalyzerUsageEdge!]!
    nodes: [AnalyzerUsage!]!
    pageInfo: PageInfo!
}

type AnalyzerUsageEdge {
    cursor: String!
    node: AnalyzerUsage!
}

type AnomalyChart {
    focus: ReportFocusEnum!
    groupBy: [AnomalyResultGroupByEnum!]
    name: String!
}

"Anomaly analysis report from lambda service"
type AnomalyResult {
    anomalyProbability: Float!
    bytesCreatedCount: Long
    bytesDeletedCount: Long
    bytesModifiedCount: Long
    bytesNetChangedCount: Long
    cluster: Cluster!
    filesCreatedCount: Long
    filesDeletedCount: Long
    filesModifiedCount: Long
    id: String!
    isAnomaly: Boolean!
    managedId: String!
    objectType: ObjectTypeEnum
    previousSnapshotDate: DateTime!
    previousSnapshotId: String!
    snappableFid: UUID!
    snappableId: String!
    snappableName: String
    snapshotDate: DateTime!
    snapshotFid: UUID!
    snapshotId: String!
    suspiciousFilesCount: Long
}

type AnomalyResultAggregation {
    bytesAdded: Long!
    bytesDeleted: Long!
    bytesModified: Long!
    filesAdded: Long!
    filesDeleted: Long!
    filesModified: Long!
}

type AnomalyResultConnection {
    aggregation: AnomalyResultAggregation!
    count: Int!
    edges: [AnomalyResultEdge!]!
    nodes: [AnomalyResult!]!
    pageInfo: PageInfo!
}

type AnomalyResultEdge {
    cursor: String!
    node: AnomalyResult!
}

"Anomaly result data with groupby info applied to it"
type AnomalyResultGroupBy {
    "Paginated anomaly result data"
    anomalyResultConnection(
        after: String,
        before: String,
        "filter anomaly results by input"
        filter: AnomalyResultFilterInput,
        first: Int,
        last: Int,
        "sort anomaly results by field"
        sortBy: AnomalyResultSortByEnum,
        "sort order"
        sortOrder: SortOrderEnum
    ): AnomalyResultConnection!
    "Further provide groupings for the data."
    anomalyResultGroupBy(
        "group anomaly results by field"
        groupBy: AnomalyResultGroupByEnum!
    ): [AnomalyResultGroupBy!]!
    "Groupby info."
    groupByInfo: AnomalyResultGroupByInfo!
}

type AnomalyResultGroupByConnection {
    count: Int!
    edges: [AnomalyResultGroupByEdge!]!
    nodes: [AnomalyResultGroupBy!]!
    pageInfo: PageInfo!
}

type AnomalyResultGroupByEdge {
    cursor: String!
    node: AnomalyResultGroupBy!
}

type AnomalyStatus {
    isAnomaly: Boolean!
}

type AnomalyTable {
    focus: ReportFocusEnum!
    groupBy: [AnomalyResultGroupByEnum!]
    name: String!
    selectedColumns: [AnomalyTableColumnEnum!]!
    sortBy: AnomalyResultSortByEnum
    sortOrder: SortOrderEnum
}

type AppBlueprintRecoverySpecMap {
    childRecoverySpecs: [ChildRecoverySpecMap!]!
    isPending: Boolean!
    planType: PlanNameEnum!
    userData: String
    version: Long!
}

type AppBlueprintResourceSpec {
    ec2RecSpec: [Ec2InstanceResourceDesc!]!
    vmResSpec: [VmwareVirtualMachineResourceDesc!]!
}

type AppBlueprintSnappableRecoverySpec {
    childrenRecoverySpecs: [SnappableRecoverySpecMap!]!
    fid: String!
}

type AppBlueprintSnapshotCloudImage {
    appImageIds: [String!]!
    imageConverted: Boolean!
    snapshotFid: String!
}

type AppIDForType {
    appId: String!
    appType: String!
}

type ArchivalLocation {
    bucket: String
    id: String!
    isActive: Boolean!
    locationType: ArchivalLocationType!
    name: String!
}

type ArchivalSpec {
    targetMapping: TargetMapping
    threshold: Int!
    thresholdUnit: RetentionUnitEnum!
}

"A reply of the async download request"
type AsyncDownloadReply {
    "The Id of the job"
    jobId: Long!
    "The reference Id of the job"
    referenceId: String!
}

"""

Supported in v5.0+
"""
type AsyncRequestStatus {
    """

    Supported in v5.0+
    v5.0: The end time of the request
    v5.1+: The end time of the request.
    """
    endTime: DateTime
    """

    Supported in v5.0+
    v5.0: Any errors encountered
    v5.1+: Any errors encountered.
    """
    error: RequestErrorInfo
    """

    Required. Supported in v5.0+
    v5.0: The ID of the request object. Use it to poll the status.
    v5.1+: The ID of the request object used to poll the status.
    """
    id: String!
    """

    Required. Supported in v5.0+
    v5.0: References to any related objects
    v5.1+: References to any related objects.
    """
    links: [Link!]!
    """

    Supported in v5.0+
    The ID of the node where the job ran.
    """
    nodeId: String
    """

    Supported in v5.0+
    v5.0: The current progress in terms of percentage of the async request.
    v5.1+: The current percentage progress of the asynchronous request.
    """
    progress: Float
    """

    Supported in v5.0+
    v5.0: The start time of the request
    v5.1+: The start time of the request.
    """
    startTime: DateTime
    """

    Required. Supported in v5.0+
    v5.0: Status of the id.
    v5.1+: Status of the ID.
    """
    status: String!
}

type AttachmentSpecForEbsVolume {
    awsNativeEc2InstanceId: String!
    devicePath: String!
    isExcludedFromSnapshot: Boolean!
    isRootVolume: Boolean!
}

type AttachmentSpecForEc2Instance {
    awsNativeEbsVolumeId: String!
    devicePath: String!
    isExcludedFromSnapshot: Boolean!
    isRootVolume: Boolean!
}

type AuthorizedOperations {
    id: String!
    operations: [OperationEnum!]!
    snappableHierarchy: SnappableLevelHierarchyTypeEnum
}

"Ldap Authorized Principal"
type AuthorizedPrincipal {
    authDomainId: String!
    authDomainName: String!
    email: String
    id: String!
    name: String!
    principalType: PrincipalTypeEnum!
    roles: [Role!]!
}

type AuthorizedPrincipalConnection {
    count: Int!
    edges: [AuthorizedPrincipalEdge!]!
    nodes: [AuthorizedPrincipal!]!
    pageInfo: PageInfo!
}

type AuthorizedPrincipalEdge {
    cursor: String!
    node: AuthorizedPrincipal!
}

"AWS Account specific info"
type AwsAccount implements CloudAccount {
    accessKey: String!
    "The id of this Cloud Account"
    cloudAccountId: String!
    "The type of this Cloud Provider."
    cloudProvider: CloudProviderTypeEnum!
    "The connection status of this Cloud Account."
    connectionStatus: ConnectionStatusType!
    "The description of this Cloud Account"
    description: String
    "The name of this Cloud Account"
    name: String!
}

"Aws account response"
type AwsAccountResponse {
    accountName: String!
    cloudType: AwsCloudTypeEnum!
    id: String!
    message: String!
    nativeId: String!
    seamlessFlowEnabled: Boolean!
}

"Validate given aws accounts."
type AwsAccountValidationResponse {
    accountName: String!
    cloudType: AwsCloudTypeEnum!
    message: String!
    nativeId: String!
    seamlessFlowEnabled: Boolean!
}

"Initiate delete of aws cloud account."
type AwsCloudAccountDeleteInitiateReply {
    "Cloud formation url to delete the stack"
    cloudFormationUrl: String!
    "List of feature-version"
    featureRegionMap: [AwsCloudAccountFeatureVersion!]!
}

"Process delete of aws cloud account."
type AwsCloudAccountDeleteProcessReply {
    "Contains success response message."
    message: String
}

"Feature version of aws cloud accounts"
type AwsCloudAccountFeatureVersion {
    "Feature Enum"
    feature: CloudAccountFeatureEnum!
    "Version"
    version: Int!
}

"Aws cloud accounts."
type AwsCloudAccountGetAccountResponse {
    "Account details."
    awsCloudAccount: AwsAccountResponse
    "Feature details."
    featureDetails: [FeatureDetail!]!
}

"Aws cloud accounts for a feature."
type AwsCloudAccountGetAccountsResponse {
    awsCloudAccounts: [AwsCloudAccountGetAccountResponse!]!
}

"Initiate aws cloud accounts."
type AwsCloudAccountInitiate {
    "Aws regions"
    awsRegions: [AwsCloudAccountRegionEnum!]
    "Aws cloud-formation url"
    cloudFormationUrl: String!
    "External id for the cloud account"
    externalId: String!
    "List of feature-versions"
    featureVersionList: [AwsCloudAccountFeatureVersion!]!
    "Role arn for the feature(if valid)"
    roleArn: String!
    "Stack name of template to run, only for single account addition"
    stackName: String
    "StackSet name of template to run, only for bulk account addition"
    stackSetName: String
    "Aws cloud formation template url"
    templateUrl: String!
}

"Aws cloud Account list KMS Keys response"
type AwsCloudAccountListKMSKeysResponse {
    result: [KMSKey!]!
}

"Aws cloud Account list Security Group response"
type AwsCloudAccountListSecurityGroupsResponse {
    result: [CloudAccountSub!]!
}

"Aws cloud Account list Subnet response"
type AwsCloudAccountListSubnetsResponse {
    result: [CloudAccountSubnet!]!
}

"Aws cloud Account list VPC response"
type AwsCloudAccountListVpcResponse {
    result: [CloudAccountVpc!]!
}

"Process aws cloud account(s)."
type AwsCloudAccountProcessResponse {
    "Contains success response message."
    awsChildAccounts: [AwsAccountResponse!]!
    "Contains success response message."
    message: String
}

"Aws cloud account save response."
type AwsCloudAccountSaveResponse {
    "Contains success response message."
    message: String
}

"Aws Cloud Account Update Feature Initiate Response."
type AwsCloudAccountUpdateFeatureInitiateResponse {
    cloudFormationUrl: String!
    templateUrl: String!
}

"Aws Cloud Account Update Feature Response."
type AwsCloudAccountUpdateFeatureResponse {
    success: Boolean!
}

"Aws cloud accounts validate response."
type AwsCloudAccountValidateAndInitateResponse {
    "Aws cloud account initiate response type."
    initiateResponse: AwsCloudAccountInitiate
    "Contains error message for admin account."
    validateResponse: AwsCloudAccountValidateResponse
}

"Aws cloud accounts validate response."
type AwsCloudAccountValidateResponse {
    "Contains error message for account(s)."
    invalidAwsAccounts: [AwsAccountValidationResponse!]!
    "Contains error message for admin account."
    invalidAwsAdminAccount: AwsAccountValidationResponse
}

"Compute setting for AWS Target"
type AwsComputeSettings {
    cloudAccount: CloudAccount
    clusterInterfaceCidrs: [ClusterInfCidrs!]!
    id: String!
    isArchived: Boolean!
    isPolarisManaged: Boolean!
    name: String!
    proxySettings: ProxySettings
    region: AwsRegionEnum!
    securityGroupId: String!
    subnetId: String!
    vpcId: String!
}

type AwsEc2Instance {
    imageId: String!
    instanceId: String!
    instanceName: String!
    instanceType: String!
}

"AWS Exocompute Configs Create Response."
type AwsExocomputeConfigsCreateResponse {
    configs: [AwsExocomputeGetConfigResponse!]!
}

"AWS Exocompute Configs Delete Response."
type AwsExocomputeConfigsDeleteResponse {
    deletionStatus: [AwsExocomputeConfigsDeletionStatusType!]!
}

"AWS Exocompute Configs Deletion status."
type AwsExocomputeConfigsDeletionStatusType {
    exocomputeConfigId: String!
    success: Boolean!
}

"AWS Exocompute configs in an AWS account."
type AwsExocomputeConfigsInAccount {
    "Account details."
    awsCloudAccount: AwsAccountResponse!
    "Aws exocompute get config response"
    configs: [AwsExocomputeGetConfigResponse!]!
    "List of regions for which exocompute can be configured."
    exocomputeEligibleRegions: [AwsCloudAccountRegionEnum!]!
    "Feature details."
    featureDetails: FeatureDetail!
}

"AWS Exocompute Configs List Response."
type AwsExocomputeConfigsResponse {
    configs: [AwsExocomputeConfigsInAccount!]!
}

"AWS Exocompute config in a region."
type AwsExocomputeGetConfigResponse {
    areSecurityGroupsPolarisManaged: Boolean!
    clusterSecurityGroupId: String!
    configUuid: String!
    message: String!
    nodeSecurityGroupId: String!
    region: AwsCloudAccountRegionEnum!
    subnet1: AwsExocomputeSubnetType!
    subnet2: AwsExocomputeSubnetType!
    vpcId: String!
}

"AWS Exocompute config in a region."
type AwsExocomputeSubnetType {
    availabilityZone: String!
    subnetId: String!
}

type AwsInstanceType {
    instanceTypeId: Int!
    memoryMbs: Int!
    name: String!
    networkPerformance: String!
    region: String!
    storage: String!
    tenancy: String!
    vcpus: Int!
}

type AwsNativeAccount implements HierarchyObject & PolarisHierarchyObject {
    "The authorized operations on the object."
    authorizedOperations: [PolarisObjectAuthorizedOperationsEnum!]!
    "List of all ebs volumes under this AWS account"
    awsNativeEbsVolumeConnection(
        after: String,
        before: String,
        ebsVolumeFilters: AwsNativeEbsVolumeFilters,
        first: Int,
        last: Int,
        "Sort fields for list of AWS EBS volumes."
        sortBy: AwsNativeEbsVolumeSortFieldsEnum,
        sortOrder: HierarchySortOrder
    ): AwsNativeEbsVolumeConnection!
    "List of all ec2 instances under this AWS account"
    awsNativeEc2InstanceConnection(
        after: String,
        before: String,
        ec2InstanceFilters: AwsNativeEc2InstanceFilters,
        first: Int,
        last: Int,
        "Sort fields for list of AWS EC2 instances."
        sortBy: AwsNativeEc2InstanceSortFieldsEnum,
        sortOrder: HierarchySortOrder
    ): AwsNativeEc2InstanceConnection!
    "List of all RDS instances under this AWS account"
    awsNativeRdsInstanceConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        rdsInstanceFilters: AwsNativeRdsInstanceFilters,
        "Sort fields for list of AWS RDS instances."
        sortBy: AwsNativeRdsInstanceSortFieldsEnum,
        sortOrder: HierarchySortOrder
    ): AwsNativeRdsInstanceConnection!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    ebsVolumeCount: Int!
    ec2InstanceCount: Int!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    lastRefreshedAt: DateTime
    "List of logical children"
    logicalChildConnection(
        after: String,
        filter: [Filter!],
        first: Int,
        "provide optional snappable hierarchy for RBAC and SLA, none value is assumed to be All snappable hierarchy"
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): AwsNativeAccountLogicalChildTypeConnection!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    rdsInstanceCount: Int!
    regions: [AwsNativeRegionEnum!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
    status: AwsAccountStatusEnum!
}

type AwsNativeAccountConnection {
    count: Int!
    edges: [AwsNativeAccountEdge!]!
    nodes: [AwsNativeAccount!]!
    pageInfo: PageInfo!
}

type AwsNativeAccountEdge {
    cursor: String!
    node: AwsNativeAccount!
}

type AwsNativeAccountLogicalChildTypeConnection {
    count: Int!
    edges: [AwsNativeAccountLogicalChildTypeEdge!]!
    nodes: [AwsNativeAccountLogicalChildType!]!
    pageInfo: PageInfo!
}

type AwsNativeAccountLogicalChildTypeEdge {
    cursor: String!
    node: AwsNativeAccountLogicalChildType!
}

type AwsNativeEbsVolume implements AwsNativeAccountDescendantType & AwsNativeAccountLogicalChildType & HierarchyObject & PolarisHierarchyObject & PolarisHierarchySnappable {
    "Ec2 Instance to which this volume is attached"
    attachedEc2Instances: [AwsNativeEc2Instance!]!
    attachmentSpecs: [AttachmentSpecForEbsVolume!]!
    "The authorized operations on the object."
    authorizedOperations: [PolarisSnappableAuthorizedOperationsEnum!]!
    availabilityZone: String!
    "Aws account of the EBS Volumes"
    awsNativeAccount: AwsNativeAccount!
    awsNativeAccountName: String!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    iops: Long!
    isExocomputeConfigured: Boolean!
    isIndexingEnabled: Boolean!
    isMarketplace: Boolean!
    isRelic: Boolean!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "the newest snapshot that is indexed and unexpired, and therefore restorable."
    newestIndexedSnapshot: PolarisSnapshot
    "the most recent snapshot of this snappable"
    newestSnapshot: PolarisSnapshot
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "the oldest snapshot of this snappable"
    oldestSnapshot: PolarisSnapshot
    "the number of on-demand snapshots"
    onDemandSnapshotCount: Int!
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    region: AwsNativeRegionEnum!
    sizeInGBs: Int!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The list of snapshots taken for this snappable"
    snapshotConnection(
        after: String,
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        first: Int,
        last: Int,
        "sort polaris snapshots by field"
        sortBy: PolarisSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): PolarisSnapshotConnection
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByConnection(
        after: String,
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        first: Int,
        "group polaris snapshots by field"
        groupBy: PolarisSnapshotGroupByEnum!,
        last: Int,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByConnection
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByNewConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "filter polaris snapshot connection"
        snapshotFilter: [PolarisSnapshotFilterNewInput!]!,
        "group polaris snapshots by field"
        snapshotGroupBy: SnapshotGroupByTimeEnum!,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByNewConnection
    "The list of snapshots taken for this snappable"
    snapshotsOfSnappableConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        snappableId: String!,
        "filter for snapshot connection"
        snapshotFilter: [SnapshotQueryFilterInput!],
        sortBy: SnapshotQuerySortByField,
        "sort order"
        sortOrder: SortOrderEnum,
        timeRange: TimeRangeInput
    ): GenericSnapshotConnection
    tags: [Tag!]!
    volumeId: String!
    volumeName: String!
    volumeType: AwsNativeEbsVolumeTypeEnum!
}

type AwsNativeEbsVolumeConnection {
    count: Int!
    edges: [AwsNativeEbsVolumeEdge!]!
    nodes: [AwsNativeEbsVolume!]!
    pageInfo: PageInfo!
}

type AwsNativeEbsVolumeEdge {
    cursor: String!
    node: AwsNativeEbsVolume!
}

type AwsNativeEc2Instance implements AwsNativeAccountDescendantType & AwsNativeAccountLogicalChildType & HierarchyObject & PolarisHierarchyObject & PolarisHierarchySnappable {
    "Attached ebs volumes"
    attachedEbsVolumes: [AwsNativeEbsVolume!]!
    attachmentSpecs: [AttachmentSpecForEc2Instance!]!
    "The authorized operations on the object."
    authorizedOperations: [PolarisSnappableAuthorizedOperationsEnum!]!
    availabilityZone: String!
    "Aws account of the Ec2 instance"
    awsNativeAccount: AwsNativeAccount!
    awsNativeAccountName: String!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    instanceId: String!
    instanceName: String!
    instanceType: AwsNativeEc2InstanceTypeEnum!
    isExocomputeConfigured: Boolean!
    isIndexingEnabled: Boolean!
    isMarketplace: Boolean!
    isRelic: Boolean!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "the newest snapshot that is indexed and unexpired, and therefore restorable."
    newestIndexedSnapshot: PolarisSnapshot
    "the most recent snapshot of this snappable"
    newestSnapshot: PolarisSnapshot
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "the oldest snapshot of this snappable"
    oldestSnapshot: PolarisSnapshot
    "the number of on-demand snapshots"
    onDemandSnapshotCount: Int!
    osType: OsTypeEnum!
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    privateIp: String!
    publicIp: String!
    region: AwsNativeRegionEnum!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The list of snapshots taken for this snappable"
    snapshotConnection(
        after: String,
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        first: Int,
        last: Int,
        "sort polaris snapshots by field"
        sortBy: PolarisSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): PolarisSnapshotConnection
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByConnection(
        after: String,
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        first: Int,
        "group polaris snapshots by field"
        groupBy: PolarisSnapshotGroupByEnum!,
        last: Int,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByConnection
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByNewConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "filter polaris snapshot connection"
        snapshotFilter: [PolarisSnapshotFilterNewInput!]!,
        "group polaris snapshots by field"
        snapshotGroupBy: SnapshotGroupByTimeEnum!,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByNewConnection
    "The list of snapshots taken for this snappable"
    snapshotsOfSnappableConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        snappableId: String!,
        "filter for snapshot connection"
        snapshotFilter: [SnapshotQueryFilterInput!],
        sortBy: SnapshotQuerySortByField,
        "sort order"
        sortOrder: SortOrderEnum,
        timeRange: TimeRangeInput
    ): GenericSnapshotConnection
    sshKeyPairName: String!
    tags: [Tag!]!
    vpcId: String!
    vpcName: String!
}

type AwsNativeEc2InstanceConnection {
    count: Int!
    edges: [AwsNativeEc2InstanceEdge!]!
    nodes: [AwsNativeEc2Instance!]!
    pageInfo: PageInfo!
}

type AwsNativeEc2InstanceEdge {
    cursor: String!
    node: AwsNativeEc2Instance!
}

type AwsNativeProtectionAccountAddResponse {
    cloudFormationName: String!
    cloudFormationTemplateUrl: String!
    cloudFormationUrl: String!
    errorMessage: String!
}

type AwsNativeRdsInstance implements AwsNativeAccountDescendantType & AwsNativeAccountLogicalChildType & HierarchyObject & PolarisHierarchyObject & PolarisHierarchySnappable {
    allocatedStorageInGibi: Long!
    "The authorized operations on the object."
    authorizedOperations: [PolarisSnappableAuthorizedOperationsEnum!]!
    "AWS account of the RDS instance"
    awsNativeAccount: AwsNativeAccount!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    dbEngine: AwsNativeRdsDbEngineEnum!
    dbInstanceClass: AwsNativeRdsDbInstanceClassEnum!
    dbInstanceName: String!
    dbiResourceId: String!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    isMultiAz: Boolean!
    isRelic: Boolean!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    maintenanceWindow: String!
    "The name of the hierarchy object."
    name: String!
    "the newest snapshot that is indexed and unexpired, and therefore restorable."
    newestIndexedSnapshot: PolarisSnapshot
    "the most recent snapshot of this snappable"
    newestSnapshot: PolarisSnapshot
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "the oldest snapshot of this snappable"
    oldestSnapshot: PolarisSnapshot
    "the number of on-demand snapshots"
    onDemandSnapshotCount: Int!
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    primaryAvailabilityZone: String!
    region: AwsNativeRegionEnum!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The list of snapshots taken for this snappable"
    snapshotConnection(
        after: String,
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        first: Int,
        last: Int,
        "sort polaris snapshots by field"
        sortBy: PolarisSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): PolarisSnapshotConnection
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByConnection(
        after: String,
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        first: Int,
        "group polaris snapshots by field"
        groupBy: PolarisSnapshotGroupByEnum!,
        last: Int,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByConnection
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByNewConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "filter polaris snapshot connection"
        snapshotFilter: [PolarisSnapshotFilterNewInput!]!,
        "group polaris snapshots by field"
        snapshotGroupBy: SnapshotGroupByTimeEnum!,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByNewConnection
    "The list of snapshots taken for this snappable"
    snapshotsOfSnappableConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        snappableId: String!,
        "filter for snapshot connection"
        snapshotFilter: [SnapshotQueryFilterInput!],
        sortBy: SnapshotQuerySortByField,
        "sort order"
        sortOrder: SortOrderEnum,
        timeRange: TimeRangeInput
    ): GenericSnapshotConnection
    tags: [Tag!]!
    vpcId: String!
    vpcName: String!
}

type AwsNativeRdsInstanceConnection {
    count: Int!
    edges: [AwsNativeRdsInstanceEdge!]!
    nodes: [AwsNativeRdsInstance!]!
    pageInfo: PageInfo!
}

type AwsNativeRdsInstanceEdge {
    cursor: String!
    node: AwsNativeRdsInstance!
}

"A subnet on AWS as defined in awsnative service."
type AwsNativeSubnet {
    availabilityZone: String!
    id: String!
    name: String!
}

type AwsRdsConfig {
    logRetention: SlaDuration
}

type AwsReplicationTarget {
    accountId: String!
    accountName: String!
    region: AwsNativeRegionForReplicationEnum!
}

"AWS role based Account specific info"
type AwsRoleBasedAccount implements CloudAccount {
    awsSpecificInfo: AwsCloudAccountGetAccountResponse!
    "The id of this Cloud Account"
    cloudAccountId: String!
    "The type of this Cloud Provider."
    cloudProvider: CloudProviderTypeEnum!
    "The connection status of this Cloud Account."
    connectionStatus: ConnectionStatusType!
    "The description of this Cloud Account"
    description: String
    "The name of this Cloud Account"
    name: String!
}

"A Security group in AWS realm."
type AwsSecurityGroup {
    id: String!
    name: String!
}

type AwsStorageVolumeType {
    maxIops: Int!
    maxSizeGbs: Int!
    name: String!
    volumeTypeId: Int!
}

"A Subnet in AWS realm."
type AwsSubnet {
    availabilityZone: String!
    id: String!
    name: String!
}

"Specific info for AWS Target Template"
type AwsTargetTemplate implements TargetTemplate {
    bucketPrefix: String!
    cloudAccount: CloudAccount!
    computeSettings: AwsComputeSettings
    encryptionType: TargetEncryptionTypeEnum!
    isConsolidationEnabled: Boolean!
    proxySettings: ProxySettings
    region: AwsRegionEnum!
    storageClass: AwsStorageClassTypeEnum!
    "The type of this Target"
    targetType: TargetTypeEnum!
}

type AwsVMNicSpec {
    ipv4Address: String!
    key: Int!
    "security group of the nic"
    securityGroup: SnappableSecurityGroup
    securityGroupId: String!
    "subnet of the nic"
    subnet: SnappableSubnet
    subnetId: String!
}

type AwsVMRecoverySpec {
    availabilityZone: String!
    dedicatedHostId: String!
    hostAffinity: String!
    instanceTypeId: Int!
    instanceTypeName: String!
    keyName: String!
    nics: [AwsVMNicSpec!]!
    placementGroup: String!
    tenancy: AwsInstanceTenancyEnum!
    userData: String!
    version: Long!
    volumes: [AwsVMVolumeSpec!]!
}

type AwsVMVolumeSpec {
    iops: Int!
    key: Int!
    sizeGbs: Int!
    volumeTypeId: Int!
}

"A VPC in AWS realm."
type AwsVpc {
    id: String!
    name: String!
    securityGroups: [AwsSecurityGroup!]!
    subnets: [AwsSubnet!]!
}

"Azure Account specific info"
type AzureAccount implements CloudAccount {
    "The id of this Cloud Account"
    cloudAccountId: String!
    "The type of this Cloud Provider."
    cloudProvider: CloudProviderTypeEnum!
    "The connection status of this Cloud Account."
    connectionStatus: ConnectionStatusType!
    "The description of this Cloud Account"
    description: String
    "The name of this Cloud Account"
    name: String!
    subscriptionId: String!
    tenantId: String!
}

"Azure Check Permissions On Subscription Response."
type AzureCheckPermissionsOnSubscriptionResponse {
    missingPermissions: [String!]!
    subscriptionNativeId: String!
}

"Azure Cloud Account Add Response."
type AzureCloudAccountAddResponse {
    "Status of the Azure Cloud Account Add operations."
    status: [AzureCloudAccountAddStatus!]!
    "Tenant ID for the added subscriptions"
    tenantId: String!
}

"Status of the Azure Cloud Accout Add operation."
type AzureCloudAccountAddStatus {
    error: String!
    subscriptionId: String!
    subscriptionNativeId: String!
}

"Azure Cloud Account Delete Response."
type AzureCloudAccountDeleteResponse {
    "Status of the Azure Cloud Account Delete operations."
    status: [AzureCloudAccountDeleteStatus!]!
}

"Status of the Azure Cloud Account Delete operation."
type AzureCloudAccountDeleteStatus {
    error: String!
    subscriptionId: String!
    success: Boolean!
}

"Azure Cloud Account Feature details"
type AzureCloudAccountFeatureDetail {
    feature: CloudAccountFeatureEnum!
    regions: [AzureCloudAccountRegionEnum!]!
    status: CloudAccountStatusEnum!
}

"Azure Cloud Account OAuth Complete Response."
type AzureCloudAccountOAuthCompleteResponse {
    subscriptions: [AzureCloudAccountSubscription!]!
    success: Boolean!
}

"Azure Cloud Account OAuth Initiate Response."
type AzureCloudAccountOAuthInitiateResponse {
    clientId: String!
    sessionId: String!
}

"Azure Subscription type with basic details."
type AzureCloudAccountSubscription {
    isAuthorized: Boolean!
    name: String!
    nativeId: String!
}

"Azure Cloud Account Subscription details for a given feature"
type AzureCloudAccountSubscriptionDetail {
    featureDetail: AzureCloudAccountFeatureDetail
    id: String!
    name: String!
    nativeId: String!
}

"Azure Cloud Account Tenant with details of subscriptions configured for a given feature."
type AzureCloudAccountTenant {
    clientId: String!
    cloudType: AzureCloudTypeEnum!
    domainName: String!
    id: String!
    subscriptionCount: Int!
    subscriptions: [AzureCloudAccountSubscriptionDetail!]!
}

"Azure Cloud Account Update Response."
type AzureCloudAccountUpdateResponse {
    "Status of the Azure Cloud Account Update operations."
    status: [AzureCloudAccountUpdateStatus!]!
}

"Status of the Azure Cloud Account Update operation."
type AzureCloudAccountUpdateStatus {
    subscriptionId: String!
    success: Boolean!
}

"Azure Cloud Account Upgrade Response."
type AzureCloudAccountUpgradeResponse {
    "Status of the Azure Cloud Account Upgrade permission operations."
    status: [AzureCloudAccountUpgradeStatus!]!
}

"Status of the Azure Cloud Account Upgrade permission operation."
type AzureCloudAccountUpgradeStatus {
    error: String!
    subscriptionId: String!
    success: Boolean!
}

"Compute setting for Azure Target"
type AzureComputeSettings {
    appId: String!
    computeProxySettings: ProxySettings
    generalPurposeStorageContainer: String!
    generalPurposeStorageName: String!
    region: AzureRegionEnum!
    resourceGroup: String!
    securityGroupId: String!
    subnetId: String!
    virtualNetworkId: String!
}

"Represents available disk types for an Azure availability zone."
type AzureNativeDiskTypesForAvailabilityZone {
    availabilityZone: String!
    diskTypes: [String!]!
}

"Azure Managed Disk"
type AzureNativeManagedDisk implements HierarchyObject & PolarisHierarchyObject & PolarisHierarchySnappable {
    "The authorized operations on the object."
    authorizedOperations: [PolarisSnappableAuthorizedOperationsEnum!]!
    availabilityZone: String!
    "Virtual Machine to which this disk is attached"
    azureNativeVirtualMachine: AzureNativeVirtualMachine
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    diskIopsReadWrite: Long!
    diskMbpsReadWrite: Int!
    diskSizeGib: Int!
    diskStorageTier: AzureNativeManagedDiskTypeEnum!
    diskUniqueNativeId: String!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    isAdeEncrypted: Boolean!
    isExcludedFromSnapshot: Boolean
    isOsDisk: Boolean
    isRelic: Boolean!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    lun: Int
    "The name of the hierarchy object."
    name: String!
    "the newest snapshot that is indexed and unexpired, and therefore restorable."
    newestIndexedSnapshot: PolarisSnapshot
    "the most recent snapshot of this snappable"
    newestSnapshot: PolarisSnapshot
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "the oldest snapshot of this snappable"
    oldestSnapshot: PolarisSnapshot
    "the number of on-demand snapshots"
    onDemandSnapshotCount: Int!
    osType: AzureNativeVmOsTypeEnum!
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    region: AzureNativeRegionEnum!
    "Resource Group of the Azure Disk"
    resourceGroup: AzureNativeResourceGroup!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The list of snapshots taken for this snappable"
    snapshotConnection(
        after: String,
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        first: Int,
        last: Int,
        "sort polaris snapshots by field"
        sortBy: PolarisSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): PolarisSnapshotConnection
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByConnection(
        after: String,
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        first: Int,
        "group polaris snapshots by field"
        groupBy: PolarisSnapshotGroupByEnum!,
        last: Int,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByConnection
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByNewConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "filter polaris snapshot connection"
        snapshotFilter: [PolarisSnapshotFilterNewInput!]!,
        "group polaris snapshots by field"
        snapshotGroupBy: SnapshotGroupByTimeEnum!,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByNewConnection
    "The list of snapshots taken for this snappable"
    snapshotsOfSnappableConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        snappableId: String!,
        "filter for snapshot connection"
        snapshotFilter: [SnapshotQueryFilterInput!],
        sortBy: SnapshotQuerySortByField,
        "sort order"
        sortOrder: SortOrderEnum,
        timeRange: TimeRangeInput
    ): GenericSnapshotConnection
    tags: [AzureTag!]!
}

type AzureNativeManagedDiskConnection {
    count: Int!
    edges: [AzureNativeManagedDiskEdge!]!
    nodes: [AzureNativeManagedDisk!]!
    pageInfo: PageInfo!
}

type AzureNativeManagedDiskEdge {
    cursor: String!
    node: AzureNativeManagedDisk!
}

"An Azure resource group"
type AzureNativeResourceGroup implements HierarchyObject & PolarisHierarchyObject {
    "The authorized operations on the object."
    authorizedOperations: [PolarisObjectAuthorizedOperationsEnum!]!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    diskResourceGroupId: UUID!
    diskSla: AzureNativeResourceGroupSlaAssignment!
    disksCount: Int!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    region: AzureNativeRegionEnum!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
    "Azure subscription of the resource group"
    subscription: AzureNativeSubscription!
    subscriptionId: UUID!
    tags: [AzureTag!]!
    "List of Azure Virtual Machines in the resource group"
    virtualMachineConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "Sort fields for list of Azure virtual machines."
        sortBy: AzureNativeVirtualMachineSortFieldsEnum,
        sortOrder: HierarchySortOrder,
        virtualMachineFilters: AzureNativeVirtualMachineFilters
    ): AzureNativeVirtualMachineConnection!
    vmResourceGroupId: UUID!
    vmSla: AzureNativeResourceGroupSlaAssignment!
    vmsCount: Int!
}

"An Azure resource group SLA assignment"
type AzureNativeResourceGroupSlaAssignment {
    configuredSlaDomain: GlobalSla!
    effectiveSlaDomain: GlobalSla!
    slaAssignment: SlaAssignmentTypeEnum!
}

"An Azure security group"
type AzureNativeSecurityGroup {
    name: String!
    nativeId: String!
    resourceGroupName: String!
}

"An Azure subnet"
type AzureNativeSubnet {
    name: String!
    nativeId: String!
    vnet: AzureNativeVnet!
}

"An Azure Subscription"
type AzureNativeSubscription implements HierarchyObject & PolarisHierarchyObject {
    "The authorized operations on the object."
    authorizedOperations: [PolarisObjectAuthorizedOperationsEnum!]!
    cloudType: AzureCloudTypeEnum!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    disksCount: Int!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    lastRefreshedAt: DateTime
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    nativeId: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "Lists Azure resource groups in the subscription"
    resourceGroupList(
        resourceGroupFilters: AzureNativeResourceGroupFilters,
        "Sort fields for list of Azure resource groups."
        sortBy: AzureNativeVMResourceGroupSortFieldsEnum,
        sortOrder: HierarchySortOrder
    ): [AzureNativeResourceGroup!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
    status: AzureSubscriptionStatusEnum!
    tenantId: String!
    vmsCount: Int!
}

type AzureNativeSubscriptionConnection {
    count: Int!
    edges: [AzureNativeSubscriptionEdge!]!
    nodes: [AzureNativeSubscription!]!
    pageInfo: PageInfo!
}

type AzureNativeSubscriptionEdge {
    cursor: String!
    node: AzureNativeSubscription!
}

"Represents available virtual machine sizes for an Azure availability zone."
type AzureNativeVMSizesForAvailabilityZone {
    availabilityZone: String!
    vmSizes: [String!]!
}

"Azure Virtual Machine"
type AzureNativeVirtualMachine implements HierarchyObject & PolarisHierarchyObject & PolarisHierarchySnappable {
    "Attached Managed Disks to the Azure VM"
    attachedManagedDisks: [AzureNativeManagedDisk!]!
    "The authorized operations on the object."
    authorizedOperations: [PolarisSnappableAuthorizedOperationsEnum!]!
    availabilityzone: String!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    isAdeEnabled: Boolean!
    isRelic: Boolean!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "the newest snapshot that is indexed and unexpired, and therefore restorable."
    newestIndexedSnapshot: PolarisSnapshot
    "the most recent snapshot of this snappable"
    newestSnapshot: PolarisSnapshot
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "the oldest snapshot of this snappable"
    oldestSnapshot: PolarisSnapshot
    "the number of on-demand snapshots"
    onDemandSnapshotCount: Int!
    osType: AzureNativeVmOsTypeEnum!
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    region: AzureNativeRegionEnum!
    "Resource Group of the Azure VM"
    resourceGroup: AzureNativeResourceGroup!
    sizeType: String!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The list of snapshots taken for this snappable"
    snapshotConnection(
        after: String,
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        first: Int,
        last: Int,
        "sort polaris snapshots by field"
        sortBy: PolarisSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): PolarisSnapshotConnection
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByConnection(
        after: String,
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        first: Int,
        "group polaris snapshots by field"
        groupBy: PolarisSnapshotGroupByEnum!,
        last: Int,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByConnection
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByNewConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "filter polaris snapshot connection"
        snapshotFilter: [PolarisSnapshotFilterNewInput!]!,
        "group polaris snapshots by field"
        snapshotGroupBy: SnapshotGroupByTimeEnum!,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByNewConnection
    "The list of snapshots taken for this snappable"
    snapshotsOfSnappableConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        snappableId: String!,
        "filter for snapshot connection"
        snapshotFilter: [SnapshotQueryFilterInput!],
        sortBy: SnapshotQuerySortByField,
        "sort order"
        sortOrder: SortOrderEnum,
        timeRange: TimeRangeInput
    ): GenericSnapshotConnection
    subnetName: String!
    tags: [AzureTag!]!
    vmName: String!
    vmUniqueNativeId: String!
    vnetName: String!
}

type AzureNativeVirtualMachineConnection {
    count: Int!
    edges: [AzureNativeVirtualMachineEdge!]!
    nodes: [AzureNativeVirtualMachine!]!
    pageInfo: PageInfo!
}

type AzureNativeVirtualMachineEdge {
    cursor: String!
    node: AzureNativeVirtualMachine!
}

"An Azure virtual network"
type AzureNativeVnet {
    name: String!
    resourceGroupName: String!
}

type AzureNetworkSecurityGroupResp {
    reason: String!
    rulesStatus: AzureNetworkSecurityRulesStatusEnum!
}

type AzureNetworkSubnetResp {
    valid: Boolean!
}

type AzureNetworkSubnetUnusedAddrResp {
    unusedAddr: Long!
}

type AzureO365ExocomputeCluster {
    acrId: String!
    aksId: String!
    aksVersion: String!
    azureAppId: String!
    groupName: String!
    id: String!
    isProvisioned: Boolean!
    kmsId: String!
    orgId: String!
    orgName: String!
    orgStatus: String!
    regionName: String!
    scaleRuntime: ScaleRuntime
    setupConfiguration: String!
    storageId: String!
    subscriptionId: String!
    tenantId: String!
}

type AzureOAuthConsentKickoffResp {
    appClientId: String!
    csrfToken: String!
}

type AzureReplicationTarget {
    region: AzureNativeRegionForReplicationEnum!
    subscriptionId: String!
    subscriptionName: String!
}

type AzureResourceAvailabilityResp {
    available: Boolean!
    reason: String!
}

type AzureSubscription {
    id: String!
    name: String!
}

type AzureSubscriptionConnection {
    count: Int!
    edges: [AzureSubscriptionEdge!]!
    nodes: [AzureSubscription!]!
    pageInfo: PageInfo!
}

type AzureSubscriptionEdge {
    cursor: String!
    node: AzureSubscription!
}

"Azure Tag"
type AzureTag {
    key: String!
    value: String!
}

"Specific info for Azure Target Template"
type AzureTargetTemplate implements TargetTemplate {
    cloudAccount: CloudAccount!
    computeSettings: AzureComputeSettings
    containerNamePrefix: String!
    instanceType: InstanceTypeEnum!
    isConsolidationEnabled: Boolean!
    proxySettings: ProxySettings
    storageAccountName: String!
    "The type of this Target"
    targetType: TargetTypeEnum!
}

type AzureUserRoleResp {
    globalAdministrator: RoleStatus
    subscriptionOwner: RoleStatus
}

type BackupWindow {
    durationInHours: Int!
    startTimeAttributes: StartTimeAttributes
}

"""

Supported in v5.0+
"""
type BaseSnapshotSummary {
    """

    Supported in v5.0+
    """
    archivalLocationIds: [String!]!
    """

    Supported in v5.0+
    Integer value that represents the archival state of a snapshot. 0 means the snapshot is not archived. 2 means the snapshot is archived. 3 means the snapshot is downloaded from the archival location. 4 means the snapshot is in the process of being downloaded from the archival location. 6 means the snapshot is stored locally and at the archival location.
    """
    cloudState: Long
    """

    Supported in v5.1+
    """
    cloudStorageTier: SnapshotCloudStorageTierEnum!
    """

    Supported in v5.0+
    """
    consistencyLevel: String
    """

    Required. Supported in v5.0+
    """
    date: DateTime
    """

    Supported in v5.0+
    """
    expirationDate: DateTime
    """

    Required. Supported in v5.0+
    """
    id: String!
    """

    Supported in v5.0+
    Integer value representing the state of the indexing job for a snapshot. 0 means that the indexing has not begun or is in progress. 1 means indexing completed successfully. 2 means that the indexer failed to process this snapshot.
    """
    indexState: Long
    """

    Supported in v5.2+
    A Boolean that indicates whether or not custom retention is applied to the snapshot.
    """
    isCustomRetentionApplied: Boolean
    """

    Supported in v5.0+
    """
    isOnDemandSnapshot: Boolean!
    """

    Supported in v5.2+
    A Boolean that indicates whether the snapshot is placed on Legal Hold. When this value is 'true', the snapshot is placed on Legal Hold.
    """
    isPlacedOnLegalHold: Boolean
    """

    Supported in v5.1+
    v5.1: A Boolean that indicates whether the snapshot is being retained under a Retention Lock SLA Domain. When this value is 'true,' the snapshot is being retained under a Retention Lock SLA Domain.
    v5.2+: A Boolean that indicates whether the snapshot is being retained under a Retention Lock SLA Domain. When this value is 'true', the snapshot is being retained under a Retention Lock SLA Domain.
    """
    isRetainedByRetentionLockSla: Boolean
    """

    Supported in v5.2+
    ID of the parent snapshot if the current snapshot is a child snapshot. Child snapshots are snapshots of objects that are part of an app, either a vCloud Director vApp or an AppBlueprint. Snapshots of the app are parent snapshots.
    """
    parentSnapshotId: String
    """

    Supported in v5.0+
    """
    replicationLocationIds: [String!]!
    """

    Supported in v5.0+
    v5.0-v5.1:
    v5.2+: (Deprecated) For a policy based snapshot this parameter contains the ID of the SLA Domain currently assigned to the data source of that snapshot. For an on demand snapshot this field corresponds to the SLA Domain that was assigned when the snapshot was taken. A data source, and individual snapshots, can be reassigned to a different SLA Domain, or the SLA Domain can be modified. In any of these cases this parameter can contain a stale and incorrect value. To view retention information for this snapshot, use snapshotRetentionInfo instead.
    """
    slaId: String!
    """

    Supported in v5.0+
    v5.0-v5.1:
    v5.2+: (Deprecated) For a policy based snapshot this parameter contains the name of the SLA Domain currently assigned to the data source of that snapshot. For an on demand snapshot this field corresponds to the SLA Domain that was assigned when the snapshot was taken. A data source, and individual snapshots, can be reassigned to a different SLA Domain, or the SLA Domain can be modified. In any of these cases this parameter can contain a stale and incorrect value. To view retention information for this snapshot, use snapshotRetentionInfo instead.
    """
    slaName: String!
    """

    Supported in v5.2+
    Snapshot retention related information for local, archival and replication locations.
    """
    snapshotRetentionInfo: SnapshotRetentionInfo
    """

    Supported in v5.0+
    """
    sourceObjectType: String
}

type BasicSnapshotSchedule {
    frequency: Int!
    retention: Int!
    retentionUnit: RetentionUnitEnum!
}

"""

Supported in v5.0+
"""
type BatchAsyncRequestStatus {
    """

    Required. Supported in v5.0+
    The asynchronous request status of a batch request.
    """
    responses: [AsyncRequestStatus!]!
}

"""

Supported in v5.1+
"""
type BatchVmwareCdpLiveInfo {
    """

    Required. Supported in v5.1+
    The live CDP info for the virtual machines.
    """
    responses: [VmwareCdpLiveInfo!]!
}

type BatchVmwareVmRecoverableRanges {
    "Required. The recoverable ranges for a set of virtual machines."
    responses: [VmwareVmRecoverableRanges!]!
}

type BidirectionalReplicationSpec {
    replicationSpec1: UnidirectionalReplicationSpec
    replicationSpec2: UnidirectionalReplicationSpec
}

type BlueprintChildConnection {
    count: Int!
    edges: [BlueprintChildEdge!]!
    nodes: [BlueprintChild!]!
    pageInfo: PageInfo!
}

type BlueprintChildEdge {
    cursor: String!
    node: BlueprintChild!
}

type BlueprintConnection {
    count: Int!
    edges: [BlueprintEdge!]!
    nodes: [Blueprint!]!
    pageInfo: PageInfo!
}

type BlueprintEdge {
    cursor: String!
    node: Blueprint!
}

type BlueprintRecoverableRange {
    beginTime: DateTime
    endTime: DateTime
}

type BlueprintRecoverableRanges {
    blueprintId: String!
    recoverableRanges: [BlueprintRecoverableRange!]!
}

type BlueprintRecoverySpecReply {
    appRecoverySpecs: [AppBlueprintRecoverySpecMap!]!
    validateFailureReasons: [ValidateFailureReason!]!
}

"""

Supported in v5.0+
"""
type BrowseResponse {
    """

    Supported in v5.0+
    The type of file, either a regular file or a directory
    """
    fileMode: String
    """

    Supported in v5.0+
    The name of the file
    """
    filename: String
    """

    Supported in v5.0+
    """
    lastModified: String
    """

    Supported in v5.0+
    The complete path of the file
    """
    path: String
    """

    Supported in v5.0+
    """
    size: Long
    """

    Supported in v5.0+
    Description about the status
    """
    statusMessage: String
    """

    Supported in v5.3
    Reason the file is unreadable. Undefined if the file is readable.
    """
    unreadable: Int
}

"""

Supported in v5.0+
"""
type BrowseResponseListResponse {
    """

    Supported in v5.0+
    List of matching objects
    """
    data: [BrowseResponse!]!
    """

    Supported in v5.0+
    If there is more
    """
    hasMore: Boolean
    """

    Supported in v5.0+
    Total list responses
    """
    total: Long
}

type CDMSnapshotLocationRetentionInfo {
    expirationTime: DateTime
    id: String!
    isExpirationDateCalculated: Boolean!
    isSnapshotPresent: Boolean!
    name: String!
    snapshotFrequency: SnapshotFrequencyEnum!
}

type CDMSnapshotRetentionInfo {
    archivalInfos: [CDMSnapshotLocationRetentionInfo!]
    localInfo: CDMSnapshotLocationRetentionInfo
    replicationInfos: [CDMSnapshotLocationRetentionInfo!]
}

type CancelJobReply {
    message: String!
    status: Boolean!
}

type CdmArchivalSpec {
    archivalLocationFid: String!
    archivalLocationName: String!
    threshold: Int!
    thresholdUnit: RetentionUnitEnum!
}

type CdmClusterStatus {
    message: String!
    status: CdmClusterStatusTypeEnum!
}

type CdmHierarchyObjectConnection {
    count: Int!
    edges: [CdmHierarchyObjectEdge!]!
    nodes: [CdmHierarchyObject!]!
    pageInfo: PageInfo!
}

type CdmHierarchyObjectEdge {
    cursor: String!
    node: CdmHierarchyObject!
}

type CdmInventorySubHierarchyRoot {
    "List of children"
    childConnection(
        after: String,
        filter: [Filter!],
        first: Int,
        "provide optional snappable hierarchy for RBAC and SLA, none value is assumed to be All snappable hierarchy"
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): CdmHierarchyObjectConnection!
    "List of descendants"
    descendantConnection(
        after: String,
        filter: [Filter!],
        first: Int,
        "provide optional snappable hierarchy for RBAC and SLA, none value is assumed to be All snappable hierarchy"
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): CdmHierarchyObjectConnection!
    rootEnum: InventorySubHierarchyRootEnum!
    "List of top-level descendants (with respect to RBAC)"
    topLevelDescendantConnection(after: String, filter: [Filter!], first: Int, sortBy: HierarchySortByField, sortOrder: HierarchySortOrder, typeFilter: [HierarchyObjectTypeEnum!]): CdmHierarchyObjectConnection!
}

type CdmSnapshot implements GenericSnapshot {
    archivalLocations: [DataLocation!]
    cdmId: String!
    cdmVersion: String!
    "children snapshot id list"
    childSnapshots: [CdmSnapshot!]!
    cloudNativeLocations: [DataLocation!]
    cluster: Cluster!
    consistencyLevel: ConsistencyLevelEnum
    date: DateTime!
    expirationDate: DateTime
    expiryHint: Boolean!
    "number of files in the snapshot"
    fileCount: Long!
    hasDelta: Boolean!
    "flag if the snapshot has image(s) converted."
    hasImageConverted: Boolean!
    id: UUID!
    indexingAttempts: Long!
    "flag if the snapshot is an anomaly."
    isAnomaly: Boolean!
    isCorrupted: Boolean!
    isDownloadedSnapshot: Boolean
    "Whether or not the snapshot is expired"
    isExpired: Boolean!
    isIndexed: Boolean!
    isOnDemandSnapshot: Boolean!
    isSapHanaIncrementalSnapshot: Boolean
    isUnindexable: Boolean!
    localLocations: [DataLocation!]
    locations: [DataLocation!]
    "Non-null when a user has assigned a SLA to this snapshot, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "Mapping from snapshot to delete pending action status"
    pendingSnapshotDeletion: PendingSnapshotDeletion
    replicationLocations: [DataLocation!]
    "SAP HANA specific metadata for the snapshot"
    sapHanaAppMetadata: SapHanaAppMetadata
    "sla domain of the snapshot"
    slaDomain: SlaDomain
    "The snappableId of the snapshot."
    snappableId: String!
    snappableNew: CdmHierarchySnappableNew!
    snapshotRetentionInfo: CDMSnapshotRetentionInfo
}

type CdmSnapshotConnection {
    count: Int!
    edges: [CdmSnapshotEdge!]!
    nodes: [CdmSnapshot!]!
    pageInfo: PageInfo!
}

type CdmSnapshotEdge {
    cursor: String!
    node: CdmSnapshot!
}

"Specific info for Target created on and synced from cdm cluster"
type CdmTarget implements Target {
    "The cluster to which this target belongs"
    cluster: Cluster!
    id: String!
    "The pause/resume status of this Target"
    isActive: Boolean!
    "Whether this Target is archived"
    isArchived: Boolean!
    "The name of this Target"
    name: String!
    "The type of this Target"
    targetType: TargetTypeEnum!
}

type CdmUpgradeAvailabilityReply {
    isAvailable: Boolean!
    status: UpgradeStatus
}

type CdmUpgradeInfo {
    "Operations the user are authorized to take on the cluster"
    authorizedOperations: AuthorizedOperations!
    "Cluster Job Status"
    clusterJobStatus: ClusterJobStatusTypeEnum
    "Status of cluster"
    clusterStatus: CdmClusterStatus
    "The cluster uuid."
    clusterUuid: UUID!
    "Current running state progress percentage"
    currentStateProgress: Float
    "Downloaded version of tarball"
    downloadedVersion: String
    "Finished states of upgrade"
    finishedStates: String
    "Overall upgrade Progress"
    overallProgress: Float
    "Pending states of upgrade"
    pendingStates: String
    "ScheduledUpgrade Action"
    scheduleUpgradeAction: String
    "ScheduledUpgrade timestamp"
    scheduleUpgradeAt: DateTime
    "ScheduledUpgrade Mode."
    scheduleUpgradeMode: String
    "Upgrade state machine status"
    stateMachineStatus: String
    "Last time when state machine was updated"
    stateMachineStatusAt: DateTime
    "The upgrade event series id"
    upgradeEventSeriesId: String
    "Upgrade started time"
    upgradeStartAt: DateTime
    "Version of cluster"
    version: String!
    "Version status of cluster"
    versionStatus: VersionStatusTypeEnum
}

type CdmUpgradeRecommendationReply {
    isRecommended: Boolean!
    status: UpgradeStatus
}

type CdmUpgradeReleaseDetail {
    description: String!
    gaReleaseDate: String!
    isRecommended: Boolean!
    isUpgradable: Boolean!
    md5Sum: String!
    name: String!
    releaseDate: String!
    releaseNotesLink: String!
    size: Long!
    tarDownloadLink: String!
}

type CdmUpgradeReleaseDetailsFromSupportPortalReply {
    compatibilityMatrixLink: String!
    releaseDetails: [CdmUpgradeReleaseDetail!]!
    supportSoftwareLink: String!
}

type ChartConfig {
    chartType: ChartType!
    groupBy: [String!]!
}

type CheckGuestOsReply {
    success: Boolean!
    supportedOs: [GuestOSEnum!]!
    validationResult: [CheckGuestOsResult!]!
}

type CheckGuestOsResult {
    errorMessage: String!
    "vsphere vm instance"
    instance: VSphereVmNew!
    instanceId: String!
    instanceOs: GuestOSEnum!
    instanceType: String!
}

type ChildInfo {
    vSphereVmInfo: VsphereBlueprintChildSnapshotInfo!
}

type ChildRecoverySpecMap {
    "the recovery spec"
    recoverySpec: RecoverySpec!
    "the fid of the recovery spec"
    recoverySpecFid: String!
    "the child snappable Fid"
    snappableFid: String!
    "the child snapshot Fid"
    snapshotId: String
}

type ClassificationPolicyDetail {
    analyzers: [Analyzer!]!
    colorEnum: ClassificationPolicyColor!
    createdTime: Long!
    creator: User
    deletable: Boolean!
    description: String!
    hierarchyObjectIds: [String!]!
    hierarchyObjects: [HierarchyObject!]!
    id: String!
    lastUpdatedTime: Long!
    mode: ClassificationPolicyMode!
    name: String!
    numAnalyzers: Int!
    objectStatuses: [ObjectStatus!]!
    totalObjects: Int!
    whitelists: [ClassificationPolicyWhitelistDetailedEntry!]!
}

type ClassificationPolicyDetailConnection {
    count: Int!
    edges: [ClassificationPolicyDetailEdge!]!
    nodes: [ClassificationPolicyDetail!]!
    pageInfo: PageInfo!
}

type ClassificationPolicyDetailEdge {
    cursor: String!
    node: ClassificationPolicyDetail!
}

type ClassificationPolicySummary {
    colorEnum: ClassificationPolicyColor!
    id: String!
    name: String!
}

type ClassificationPolicyWhitelistDetailedEntry {
    nativePath: String!
    snappable: HierarchyObject!
    stdPath: String!
    updateTs: Long!
    updateUsername: String!
}

type CloudAccountAddressBlockV4 {
    cidrBlock: String!
}

type CloudAccountSub {
    description: String!
    name: String!
    ownerId: String!
    securityGroupId: String!
    vpcId: String!
}

type CloudAccountSubnet {
    availabilityZone: String!
    cidrBlock: CloudAccountAddressBlockV4
    name: String!
    subnetId: String!
    vpcId: String!
}

type CloudAccountVpc {
    cidrBlock: CloudAccountAddressBlockV4
    id: String!
    name: String!
    vpcId: String!
}

"Cloud native Account Id with its name"
type CloudNativeAccountIdWithName {
    id: String!
    name: String!
}

type CloudNativeFileVersion {
    fileMode: FileModeEnum!
    lastModified: DateTime!
    sizeInBytes: Long!
    snapshot: CloudNativeSnapshotInfo!
}

"A single Label"
type CloudNativeLabel {
    labelKey: String!
    labelValue: String!
    matchAllValues: Boolean!
}

type CloudNativeSnapshotInfo {
    date: DateTime!
    id: String!
    isOnDemandSnapshot: Boolean!
}

"CloudNativeTagRule represents a single tag rule"
type CloudNativeTagRule {
    cloudNativeAccounts: [CloudNativeAccountIdWithName!]!
    effectiveSla: TagRuleEffectiveSla
    hasPermissionToModify: Boolean!
    id: String!
    name: String!
    objectType: ManagedObjectType!
    tag: TagRuleTag
}

type CloudNativeVersionedFile {
    absolutePath: String!
    displayPath: String!
    fileVersions: [CloudNativeFileVersion!]!
    filename: String!
    path: String!
}

type CloudNativeVersionedFileConnection {
    count: Int!
    edges: [CloudNativeVersionedFileEdge!]!
    nodes: [CloudNativeVersionedFile!]!
    pageInfo: PageInfo!
}

type CloudNativeVersionedFileEdge {
    cursor: String!
    node: CloudNativeVersionedFile!
}

type Cluster {
    "The cluster's activity series."
    activitySeriesConnection(
        after: String,
        before: String,
        filters: ActivitySeriesFilterInput,
        first: Int,
        last: Int,
        "sort activity series by field"
        sortBy: ActivitySeriesSortByEnum = LastUpdated
    ): ActivitySeriesConnection!
    "The cluster's archival locations."
    archivalLocations: [ArchivalLocation!]!
    "Cluster Upgrade info"
    cdmUpgradeInfo: CdmUpgradeInfo
    "The cluster disks."
    clusterDiskConnection(after: String, before: String, filter: ClusterDiskFilterInput, first: Int, last: Int): ClusterDiskConnection!
    "The cluster nodes."
    clusterNodeConnection(after: String, before: String, first: Int, last: Int): ClusterNodeConnection!
    "Sonar previewer config."
    datagovPreviewerConfig: PreviewerClusterConfig!
    "Whether or not the cluster is encrypted."
    encryptionEnabled: Boolean!
    "The number of days remaining before the system fills up."
    estimatedRunway: Long!
    "The cluster's location."
    geoLocation: GeoLocation
    "The cluster uuid."
    id: UUID!
    "Whether or not the cluster is healthy."
    isHealthy: Boolean!
    "Lambda config."
    lambdaConfig: GetLambdaConfigReply
    "The time the cluster was last connected"
    lastConnectionTime: DateTime
    "Metadata pull scheduler."
    metadataPullScheduler: JobsReply
    "The most recent metric of a cluster."
    metric: ClusterMetric
    "The metric time series of a cluster."
    metricTimeSeries(timeRange: TimeRangeInput, unit: TimeUnitEnum!): [metricTimeSeries!]!
    "The cluster name."
    name: String!
    "The cluster product type (e.g., CDM, DATOS, etc.)."
    productType: ClusterProductEnum
    "The time the cluster was registered."
    registrationTime: DateTime!
    "The cluster's replication sources."
    replicationSources: [ReplicationSource!]!
    "The cluster's replication targets."
    replicationTargets: [ReplicationTarget!]!
    "The cluster's snappables."
    snappableConnection(
        after: String,
        before: String,
        "filter snappables by input"
        filter: SnappableFilterInput,
        first: Int,
        last: Int
    ): SnappableConnection!
    "The total number of snapshots."
    snapshotCount: Long!
    "The cluster status."
    status: ClusterStatus!
    "The cluster type."
    type: ClusterTypeEnum!
    "The software version."
    version: String
}

type ClusterConnection {
    count: Int!
    edges: [ClusterEdge!]!
    nodes: [Cluster!]!
    pageInfo: PageInfo!
}

type ClusterDisk {
    capacityBytes: Long!
    clusterId: UUID!
    diskType: ClusterDiskType!
    id: String!
    isEncrypted: Boolean!
    nodeId: String
    path: String!
    status: ClusterDiskStatus!
    unallocatedBytes: Long
    usableBytes: Long
}

type ClusterDiskConnection {
    count: Int!
    edges: [ClusterDiskEdge!]!
    nodes: [ClusterDisk!]!
    pageInfo: PageInfo!
}

type ClusterDiskEdge {
    cursor: String!
    node: ClusterDisk!
}

type ClusterEdge {
    cursor: String!
    node: Cluster!
}

"Cluster data with groupby info applied to it."
type ClusterGroupBy {
    "Paginated snappable data."
    clusterConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "sort clusters by field"
        sortBy: ClusterSortByEnum = ClusterType,
        "cluster sort order"
        sortOrder: SortOrderEnum = Desc
    ): ClusterConnection!
    "Further provide groupings for the data."
    clusterGroupBy(
        after: String,
        before: String,
        first: Int,
        "group by field"
        groupBy: ClusterGroupByEnum!,
        last: Int
    ): [ClusterGroupBy!]!
    "The data groupby info."
    groupByInfo: ClusterGroupByInfo!
}

type ClusterGroupByConnection {
    count: Int!
    edges: [ClusterGroupByEdge!]!
    nodes: [ClusterGroupBy!]!
    pageInfo: PageInfo!
}

type ClusterGroupByEdge {
    cursor: String!
    node: ClusterGroupBy!
}

"Cluster interface CIDR map."
type ClusterInfCidrs {
    clusterId: String!
    clusterName: String!
    interfaceCidr: [InterfaceCidr!]!
}

type ClusterJobStatusType {
    enumValue: ClusterJobStatusTypeEnum!
}

type ClusterMetric {
    availableCapacity: Long!
    ingestedSnapshotStorage: Long!
    lastUpdateTime: DateTime!
    liveMountCapacity: Long!
    miscellaneousCapacity: Long!
    physicalSnapshotStorage: Long!
    snapshotCapacity: Long!
    totalCapacity: Long!
    usedCapacity: Long!
}

type ClusterNode {
    brikId: String!
    clusterId: UUID!
    id: String!
    ipAddress: String
    needsInspection: Boolean
    status: String
}

type ClusterNodeConnection {
    count: Int!
    edges: [ClusterNodeEdge!]!
    nodes: [ClusterNode!]!
    pageInfo: PageInfo!
}

type ClusterNodeEdge {
    cursor: String!
    node: ClusterNode!
}

type ClusterSlaDomain implements SlaDomain {
    archivalSpec: CdmArchivalSpec
    backupWindows: [BackupWindow!]!
    baseFrequency: SlaDuration
    cdmId: String!
    cluster: Cluster
    fid: String!
    firstFullBackupWindows: [BackupWindow!]!
    id: String!
    localRetentionLimit: SlaDuration
    name: String!
    polarisManagedId: String
    protectedObjectCount: Int!
    replicationSpec: ReplicationSpec
    replicationSpecV2: [ReplicationSpecV2!]!
    snapshotSchedule: SnapshotSchedule
}

type ClusterSlaDomainConnection {
    count: Int!
    edges: [ClusterSlaDomainEdge!]!
    nodes: [ClusterSlaDomain!]!
    pageInfo: PageInfo!
}

type ClusterSlaDomainEdge {
    cursor: String!
    node: ClusterSlaDomain!
}

"Metadata for rendering a cluster sla for filter."
type ClusterSlaDomainForFilter {
    clusterName: String
    id: String!
    name: String!
}

type ClusterSlaDomainForFilterConnection {
    count: Int!
    edges: [ClusterSlaDomainForFilterEdge!]!
    nodes: [ClusterSlaDomainForFilter!]!
    pageInfo: PageInfo!
}

type ClusterSlaDomainForFilterEdge {
    cursor: String!
    node: ClusterSlaDomainForFilter!
}

type ClusterType {
    enumValue: ClusterTypeEnum!
}

type Column {
    aggregate: Boolean!
    default: Boolean!
    dimensional: Boolean!
    displayName: String!
    name: String!
    nullable: Boolean!
    sortable: Boolean!
    type: DataTypeEnum!
}

type ComplianceStatus {
    enumValue: ComplianceStatusEnum!
}

type Context {
    status: UpgradeStatus
}

type CountOfObjectsProtectedBySLAsResult {
    slaObjectCounts: [SLAIdToObjectCount!]!
}

type Crawl {
    analyzerGroupResults: [AnalyzerGroupResult!]!
    analyzerResults: [AnalyzerResult!]!
    crawlObj(snappableFid: String!): CrawlObj!
    crawlObjConnection: CrawlObjConnection!
    endTime: Long!
    failedObjectCount: Int!
    fileResultConnection(after: String, before: String, filter: ListFileResultFiltersInput, first: Int, last: Int, sort: FileResultSortInput): FileResultConnection!
    filesAnalyzeable: Long!
    filesAnalyzed: Long!
    filesTotal: Long!
    filesWithHits: Long!
    id: String!
    name: String!
    progress: Float!
    snappableTypeSummaries: [SnappableTypeSummary!]!
    startTime: Long!
    status: CrawlStatusEnum!
    totalHits: Int!
    user: User
}

type CrawlConnection {
    count: Int!
    edges: [CrawlEdge!]!
    nodes: [Crawl!]!
    pageInfo: PageInfo!
}

type CrawlEdge {
    cursor: String!
    node: Crawl!
}

type CrawlObj {
    analyzerGroupResults: [AnalyzerGroupResult!]!
    analyzerResults: [AnalyzerResult!]!
    cluster: Cluster!
    crawlId: String!
    endTime: Long!
    error: String!
    fileResultConnection(after: String, before: String, filter: BrowseDirectoryFiltersInput, first: Int, last: Int, sort: FileResultSortInput, stdPath: String!): FileResultConnection!
    filesAnalyzeable: Long!
    filesAnalyzed: Long!
    filesTotal: Long!
    filesWithHits: Long!
    progress: Float!
    snappable: HierarchyObject!
    snapshotFid: String!
    snapshotTime: Long!
    startTime: Long!
    status: SnappableCrawlStatus!
    totalHits: Int!
}

type CrawlObjConnection {
    count: Int!
    edges: [CrawlObjEdge!]!
    nodes: [CrawlObj!]!
    pageInfo: PageInfo!
}

type CrawlObjEdge {
    cursor: String!
    node: CrawlObj!
}

"The status of Create EBS Volume Snapshot request. For each volume ID in the request: an entry in errors if failed, and in taskchainUuids if succeeded."
type CreateAwsNativeEbsVolumeSnapshotsReply {
    errors: [CreateEbsVolumeSnapshotError!]!
    taskchainUuids: [CreateEbsVolumeSnapshotTaskchainUuid!]!
}

type CreateAwsNativeEc2InstanceSnapshotsReply {
    errors: [CreateEc2InstanceSnapshotError!]!
    taskchainUuids: [CreateEc2InstanceSnapshotTaskchainUuid!]!
}

"The status of Create RDS Instance Snapshot request. For each instance ID in the request: an entry in errors if failed, and in taskchainUuids if succeeded."
type CreateAwsNativeRdsInstanceSnapshotsReply {
    errors: [CreateRdsInstanceSnapshotError!]!
    taskchainUuids: [CreateRdsInstanceSnapshotTaskchainUuid!]!
}

"Disk ID and the error encountered while scheduling create azure native disk snapshot job for the Disk"
type CreateAzureNativeDiskSnapshotError {
    diskID: String!
    error: String!
}

"Disk ID and the Taskchain ID of the create azure native disk snapshot job scheduled for the Disk"
type CreateAzureNativeDiskSnapshotTaskchainUuid {
    diskId: String!
    taskchainUuid: String!
}

"The status of Create Azure Native Disk Snapshots request. For each disk ID in the request: an entry in errors if failed, or in taskchainUuids if succeeded."
type CreateAzureNativeDiskSnapshotsReply {
    errors: [CreateAzureNativeDiskSnapshotError!]!
    taskchainUuids: [CreateAzureNativeDiskSnapshotTaskchainUuid!]!
}

"Virtual Machine ID and the error encountered while schedulingcreate azure native virtual machine snapshot job for the VM"
type CreateAzureNativeVirtualMachineSnapshotError {
    error: String!
    vmId: String!
}

"Virtual Machine ID and the Taskchain ID of the create azure native virtual machine snapshot job scheduled for the VM"
type CreateAzureNativeVirtualMachineSnapshotTaskchainUuid {
    taskchainUuid: String!
    vmId: String!
}

"The status of Create Azure Native Virtual Machine Snapshots request. For each vm ID in the request: an entry in errors if failed, or in taskchainUuids if succeeded."
type CreateAzureNativeVirtualMachineSnapshotsReply {
    errors: [CreateAzureNativeVirtualMachineSnapshotError!]!
    taskchainUuids: [CreateAzureNativeVirtualMachineSnapshotTaskchainUuid!]!
}

"The status of Create label Rule request. It contains theid of the new label rule if request succeeds"
type CreateCloudNativeLabelRuleReply {
    labelRuleId: String!
}

"The status of Create tag Rule request. It contains theid of the new tag rule if request succeeds"
type CreateCloudNativeTagRuleReply {
    tagRuleId: String!
}

type CreateEbsVolumeSnapshotError {
    ebsVolumeId: String!
    error: String!
}

type CreateEbsVolumeSnapshotTaskchainUuid {
    ebsVolumeId: String!
    taskchainUuid: String!
}

type CreateEc2InstanceSnapshotError {
    ec2InstanceId: String!
    error: String!
}

type CreateEc2InstanceSnapshotTaskchainUuid {
    ec2InstanceId: String!
    taskchainUuid: String!
}

"O365 create app kickoff response"
type CreateO365AppKickoffResp {
    appClientId: String!
    csrfToken: String!
    o365TenantId: String!
}

"Reply to Create on-demand job request"
type CreateOnDemandJobReply {
    jobId: Long!
    taskchainId: String!
}

type CreateRdsInstanceSnapshotError {
    error: String!
    rdsInstanceId: String!
}

type CreateRdsInstanceSnapshotTaskchainUuid {
    rdsInstanceId: String!
    taskchainUuid: String!
}

type CustomAnalyzerMatch {
    endIndex: Int!
    startIndex: Int!
}

"Metadata for rendering a custom report."
type CustomReport {
    "The list of charts in the custom report."
    charts: [ReportChartType!]!
    "Time the report was created."
    createdAt: DateTime!
    "The filters applied to the data in the report."
    filters: CustomReportFilters!
    "The metrics focus of the custom report."
    focus: ReportFocusEnum!
    "ID of the custom report."
    id: Int!
    "True if report should be hidden from gallery view."
    isHidden: Boolean!
    "True if report is auto-generated and not allowed to be edited."
    isReadOnly: Boolean!
    "Name of the custom report."
    name: String!
    newestSyncDate: DateTime
    oldestSyncDate: DateTime
    "The creator of the custom report."
    owner: User!
    scheduledReportConnection(after: String, before: String, first: Int, last: Int): ScheduledReportConnection!
    "The list of tables in the custom report."
    tables: [ReportTableType!]!
    "Time the report was last updated (i.e., saved)."
    updatedAt: DateTime!
    "Time the report was last viewed / opened by the user."
    viewedAt: DateTime!
}

type CustomReportConnection {
    count: Int!
    edges: [CustomReportEdge!]!
    nodes: [CustomReport!]!
    pageInfo: PageInfo!
}

type CustomReportEdge {
    cursor: String!
    node: CustomReport!
}

"Filter configs for a report."
type CustomReportFilters {
    "List of activity object types to filter on."
    activityObjectType: [ActivityObjectTypeEnum!]
    "List of clusters to filter on."
    cluster: [Cluster!]
    clusterLocation: [String!]
    "List of cluster types to filter on."
    clusterType: [ClusterTypeEnum!]
    complianceStatus: [ComplianceStatusEnum!]
    failoverStatus: [FailoverStatusEnum!]
    failoverType: FailoverTypeEnum
    "Anomalous value to filter data on."
    isAnomaly: Boolean
    "List of activity statuses to filter on."
    lastActivityStatus: [ActivityStatusEnum!]
    "List of activity types to filter on."
    lastActivityType: [ActivityTypeEnum!]
    "List of managed ids to filter data on."
    managedId: [String!]
    "List of snappable types to filter on."
    objectType: [ObjectTypeEnum!]
    "List of policy IDs to filter on."
    policyId: [String!]
    protectionStatus: [ProtectionStatusEnum!]
    replicationSource: [String!]
    searchTerm: String
    slaDomain: [SlaDomain!]
    sonarObjectTypes: [HierarchyObjectTypeEnum!]
    source: [String!]
    targetSite: [String!]
    taskCategory: [String!]
    taskStatus: [String!]
    taskType: [String!]
    "Start and end time range to filter data on."
    timeRange: GenericTimeRange
    "List of object types to filter on for Audits."
    userAuditObjectType: [UserAuditObjectTypeEnum!]
    "List of user audit status to filter on."
    userAuditStatus: [UserAuditStatusEnum!]
    "List of user audit types to filter on."
    userAuditType: [UserAuditTypeEnum!]
}

"CustomReport data with groupby info applied to it."
type CustomReportGroupBy {
    "The data groupby info."
    groupByInfo: CustomReportGroupByInfo!
    "Paginated snappable data."
    reportConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "sort by field"
        sortBy: CustomReportSortByEnum = UpdateTime,
        "sort order"
        sortOrder: SortOrderEnum
    ): CustomReportConnection!
    "Further provide groupings for the data."
    reportGroupBy(
        after: String,
        before: String,
        first: Int,
        "group by field"
        groupBy: CustomReportGroupByEnum!,
        last: Int
    ): [CustomReportGroupBy!]!
}

type CustomReportGroupByConnection {
    count: Int!
    edges: [CustomReportGroupByEdge!]!
    nodes: [CustomReportGroupBy!]!
    pageInfo: PageInfo!
}

type CustomReportGroupByEdge {
    cursor: String!
    node: CustomReportGroupBy!
}

type DailySnapshotSchedule {
    basicSchedule: BasicSnapshotSchedule
}

type DataLocation {
    clusterUuid: UUID!
    createDate: DateTime!
    id: String!
    isActive: Boolean!
    isArchived: Boolean!
    "the name of the data location"
    name: String!
    type: LocationTypeEnum!
}

"Cluster specific info for supported cluster"
type DataLocationSupportedCluster {
    name: String!
    uuid: String!
    version: String!
}

type DatagovAuditCfg {
    auditTargetType: DataGovAuditTargetTypeEnum!
    clusterUuid: String!
    hostId: String!
    id: String!
    offset: Int!
    shareName: String!
    snappableFid: String!
}

type DatagovAuditCfgConnection {
    count: Int!
    edges: [DatagovAuditCfgEdge!]!
    nodes: [DatagovAuditCfg!]!
    pageInfo: PageInfo!
}

type DatagovAuditCfgEdge {
    cursor: String!
    node: DatagovAuditCfg!
}

type DatagovFileActivity {
    auditStatus: String!
    auditTs: String!
    cfgId: String!
    domainName: String!
    eventId: String!
    eventName: String!
    paginationId: String!
    path: String!
    sid: String!
    userName: String!
}

type DatagovFileActivityConnection {
    count: Int!
    edges: [DatagovFileActivityEdge!]!
    nodes: [DatagovFileActivity!]!
    pageInfo: PageInfo!
}

type DatagovFileActivityEdge {
    cursor: String!
    node: DatagovFileActivity!
}

type DatagovUserActivity {
    auditStatus: String!
    auditTs: String!
    cfgId: String!
    domainName: String!
    eventId: String!
    eventName: String!
    objectName: String!
    paginationId: String!
    userName: String!
}

type DatagovUserActivityConnection {
    count: Int!
    edges: [DatagovUserActivityEdge!]!
    nodes: [DatagovUserActivity!]!
    pageInfo: PageInfo!
}

type DatagovUserActivityEdge {
    cursor: String!
    node: DatagovUserActivity!
}

"Objects containing Datastore names for a given ESXi host"
type Datastore {
    name: String!
}

"Datastores for a given ESXi host"
type DatastoreListResponse {
    data: [Datastore!]!
    hasMore: Boolean
    total: Long
}

type DayOfWeekOpt {
    day: DayOfWeekEnum!
}

"An db parameter group on AWS."
type DbParameterGroup {
    arn: String!
    family: String!
    name: String!
}

"Reply for deletion of aws compute setting"
type DeleteAwsCloudComputeSettingReply {
    success: Boolean!
}

type DeleteAwsNativeAccountReply {
    taskchainUuid: String!
}

type DeleteBlueprintRecoverySpecReply {
    recoverySpecIds: [RecoverySpecId!]!
}

"Response from the delete subscription job. The response contains the taskchain Id, enabling the internal caller to be able to track progress of the job."
type DeleteSubscriptionReply {
    taskchainUuid: String!
}

"Statistic result for certain file/folder"
type DiffData {
    bytesCreated: Long!
    bytesDeleted: Long!
    bytesModified: Long!
    filesCreated: Long!
    filesDeleted: Long!
    filesModified: Long!
    isDeleted: Boolean!
    isFolder: Boolean!
    lastModifiedTime: Long!
    mode: Int!
    path: String!
    suspiciousFilesAdded: Long!
    totalSize: Long!
}

"Browse diff fmd result under given path"
type DiffFMDReply {
    data: [DiffData!]!
    previousSnapshotDate: Long!
    previousSnapshotId: String!
}

"Taskchain ID of the taskchain to disable the specified project"
type DisableProjectReply {
    taskchainUuid: String!
}

type DisplayableValueBoolean implements DisplayableValue {
    displayValue: String!
    serializedValue: String!
    value: Boolean
}

type DisplayableValueDateTime implements DisplayableValue {
    displayValue: String!
    serializedValue: String!
    value: DateTime
}

type DisplayableValueFloat implements DisplayableValue {
    displayValue: String!
    serializedValue: String!
    value: Float
}

type DisplayableValueInteger implements DisplayableValue {
    displayValue: String!
    serializedValue: String!
    value: Int
}

type DisplayableValueLong implements DisplayableValue {
    displayValue: String!
    serializedValue: String!
    value: Long
}

type DisplayableValueNull implements DisplayableValue {
    displayValue: String!
    serializedValue: String!
}

type DisplayableValueString implements DisplayableValue {
    displayValue: String!
    serializedValue: String!
    value: String
}

type DownloadCdmUpgradesPdfReply {
    downloadLink: String!
}

"The status of download cloud native files req. It contains thetaskchain id of the download job if succeeded"
type DownloadFilesReply {
    taskchainId: String!
}

type DownloadJobInfo {
    eventId: String!
    jobInstanceId: String!
    progress: Float!
    remainingTimeEstimateInSeconds: Long!
    status: String!
}

"Link to report"
type DownloadLink {
    "The link to the report."
    link: String!
}

type DownloadPackageReply {
    jobId: String!
}

type DownloadPackageReplyWithUuid {
    jobId: String!
    uuid: String!
}

type DownloadPackageStatusReply {
    availability: String!
    description: String!
    downloadJobInfo: DownloadJobInfo
    md5Sum: String!
    size: Long!
    version: String!
}

type DownloadResultsCsvReply {
    downloadLink: String!
}

type DownloadSnapshotResultsCsvReply {
    downloadLink: String!
}

type Ec2Blueprint implements Blueprint & HierarchyObject & HierarchySnappable & PolarisHierarchyObject & PolarisHierarchySnappable {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The list of children snappable"
    childConnection: BlueprintChildConnection!
    children: [Ec2InstanceChild!]!
    "The cloud account of EC2 Blueprint"
    cloudAccount: AwsNativeAccount
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    currentFailoverStatus: AppBlueprintFailoverStatusEnum!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    isRelic: Boolean!
    "last failover"
    lastFailover: Failover
    lastFailoverStatus: AppBlueprintLastFailoverStatusEnum!
    lastFailoverTimeMillisOpt: Long
    "last test failover"
    lastTestFailover: Failover
    lastTestFailoverStatus: AppBlueprintLastFailoverStatusEnum!
    lastTestFailoverTimeMillisOpt: Long
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "the newest snapshot archived to AWS."
    newestArchivedSnapshot: PolarisSnapshot
    "The newest snapshot ready for failover"
    newestFailoverReadySnapshot(isTestFailover: Boolean!): PolarisSnapshot
    "the newest snapshot that is indexed and unexpired, and therefore restorable."
    newestIndexedSnapshot: PolarisSnapshot
    "the newest snapshot replicated to a cluster."
    newestReplicatedSnapshot: PolarisSnapshot
    "the most recent snapshot of this snappable"
    newestSnapshot: PolarisSnapshot
    "number of child snappables of the Blueprint"
    numChildren: Int!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "the oldest snapshot of this snappable"
    oldestSnapshot: PolarisSnapshot
    "the number of on-demand snapshots"
    onDemandSnapshotCount: Int!
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    rmStatus: AppBlueprintRmStatusEnum!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The list of snapshots taken for this snappable"
    snapshotConnection(
        after: String,
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        first: Int,
        last: Int,
        "sort polaris snapshots by field"
        sortBy: PolarisSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): PolarisSnapshotConnection
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByConnection(
        after: String,
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        first: Int,
        "group polaris snapshots by field"
        groupBy: PolarisSnapshotGroupByEnum!,
        last: Int,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByConnection
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByNewConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "filter polaris snapshot connection"
        snapshotFilter: [PolarisSnapshotFilterNewInput!]!,
        "group polaris snapshots by field"
        snapshotGroupBy: SnapshotGroupByTimeEnum!,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByNewConnection
    "The list of snapshots taken for this snappable"
    snapshotsOfSnappableConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        snappableId: String!,
        "filter for snapshot connection"
        snapshotFilter: [SnapshotQueryFilterInput!],
        sortBy: SnapshotQuerySortByField,
        "sort order"
        sortOrder: SortOrderEnum,
        timeRange: TimeRangeInput
    ): GenericSnapshotConnection
    status: AppBlueprintStatusEnum!
}

type Ec2BlueprintChildFailoverInstance implements BlueprintFailoverInstance {
    snappableId: String!
}

type Ec2InstanceChild implements BlueprintChild {
    bootPriority: Int!
    "failover instance of child snappable"
    failoverInstance: Ec2BlueprintChildFailoverInstance
    fid: UUID!
    "recoverySpec of child snappable"
    recoverySpec: RecoverySpec
    "resourceSpec of child snappable"
    resourceSpec: Ec2InstanceResourceSpec
    "the child snappable"
    snappable: AwsNativeEc2Instance
    snappableType: ObjectTypeEnum!
}

type Ec2InstanceNic {
    key: String!
    secGroup: SnappableSecurityGroup
    subnet: SnappableSubnet
}

type Ec2InstanceRecoverySpec implements RecoverySpec {
    availabilityZone: String
    awsNicSpecs: [AwsVMNicSpec!]!
    awsVolumeSpecs: [AwsVMVolumeSpec!]!
    dedicatedHostId: String
    hostAffinity: String
    instanceTypeId: Int!
    instanceTypeName: String!
    keyName: String
    placementGroup: String
    tenancy: AwsInstanceTenancyEnum!
    userData: String
    version: Long!
}

type Ec2InstanceResourceDesc {
    instanceType: String!
    instanceTypeMemoryMbs: Int!
    instanceTypeVcpus: Int!
    isArchived: Boolean!
    nativeId: String!
    networkInterfaces: [Ec2InstanceNic!]!
    osType: String!
    region: String!
    snappableId: String!
    snappableName: String!
    snapshotId: String!
    storageVolumes: [Ec2InstanceVolume!]!
}

type Ec2InstanceResourceSpec implements ResourceSpec {
    ec2InstanceNics: [Ec2InstanceNic!]!
    ec2InstanceVolumeSpecs: [Ec2InstanceVolume!]!
    instanceType: String!
    instanceTypeMemoryMbs: Int!
    instanceTypeVCpus: Int!
    isArchived: Boolean!
    nativeId: String!
    osType: String!
    region: String!
    snappableId: String!
    snappableName: String!
    snapshotId: String!
}

type Ec2InstanceVolume {
    key: String!
    sizeGbs: Int!
}

"Status of 'enable automatic upload' service on certain cluster"
type EnableAutomaticFmdUploadReply {
    clusterId: String!
    enabled: Boolean!
}

"Status of 'enable lambda service' on certain cluster"
type EnableLambdaForSnappableReply {
    diffFmdEnabled: Boolean!
    fullFmdEnabled: Boolean!
    snappableFid: String!
}

type EventDigest {
    account: String!
    digestId: Int!
    digestName: String!
    eventDigestConfigJson: String!
    frequency: Int!
    includeAudits: Boolean!
    includeEvents: Boolean!
    isImmediate: Boolean!
    recipientUserId: String!
}

"Taskchain ID of the taskchain to export GCP native disk"
type ExportDiskReply {
    taskchainUuid: String!
}

"Taskchain information for export azure native disk job"
type ExportDiskSnapshotReply {
    taskchainUuid: String!
}

type ExportEbsVolumeSnapshotReply {
    taskchainUuid: String!
}

type ExportEc2InstanceSnapshotReply {
    taskchainUuid: String!
}

"Taskchain ID of the taskchain to export GCP native instance"
type ExportGCEInstanceReply {
    taskchainUuid: String!
}

"The taskchainUuid of the Export Rds Instance request."
type ExportRdsInstanceReply {
    taskchainUuid: String!
}

"Taskchain information for export azure native virtual machine job"
type ExportVMReply {
    taskchainUuid: String!
}

"A protection task."
type Failover {
    "ID of the associated appblueprint."
    appBlueprintId: UUID!
    "Name of the associated appblueprint."
    appBlueprintName: String!
    "Duration of the appflows failover job, number of millis."
    duration: Long
    "The timestamp that the job ends."
    endTime: DateTime
    "The failover job status."
    failoverStatus: FailoverStatusEnum!
    "The type of the failover job."
    failoverType: FailoverTypeEnum!
    "ID of the failover job."
    id: String!
    "The status of the last test."
    lastTestStatus: LastTestStatusEnum
    "The timestamp of the last test."
    lastTestTime: DateTime
    "The report for the failover job."
    report(
        "failover report ID"
        failoverReportId: String!
    ): FailoverReport
    "Source of the snappable associated with this appflows failover job."
    source: String!
    "The timestamp that the job starts."
    startTime: DateTime!
    "Target site of the appflows failover job."
    targetSite: String!
    taskchainId: UUID!
}

type FailoverChart {
    focus: ReportFocusEnum!
    groupBy: [FailoverGroupByEnum!]
    name: String!
}

type FailoverConnection {
    count: Int!
    edges: [FailoverEdge!]!
    nodes: [Failover!]!
    pageInfo: PageInfo!
}

type FailoverEdge {
    cursor: String!
    node: Failover!
}

"Appflows failover jobs data with groupby info applied to it."
type FailoverGroupBy {
    "Paginated appflows failover jobs data."
    failoverConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "sort appflows failover jobs by field"
        sortBy: FailoverSortByEnum = AppBlueprintName,
        "failover jobs sort order"
        sortOrder: SortOrderEnum = Desc
    ): FailoverConnection!
    failoverGroupBy(
        "group appflows failover jobs by a field"
        groupBy: FailoverGroupByEnum!
    ): [FailoverGroupBy!]!
    "The data groupby info."
    groupByInfo: FailoverGroupByInfo!
}

type FailoverGroupByConnection {
    count: Int!
    edges: [FailoverGroupByEdge!]!
    nodes: [FailoverGroupBy!]!
    pageInfo: PageInfo!
}

type FailoverGroupByEdge {
    cursor: String!
    node: FailoverGroupBy!
}

"Failover report."
type FailoverReport {
    expireTime: DateTime!
    id: String!
    reportUrl: String
    "status of the failover report"
    status: AppflowsBlueprintFailoverReportStatusEnum!
}

"All source sites."
type FailoverSource {
    "Source of the snappable associated with this appflows failover job."
    source: String!
}

type FailoverSourceConnection {
    count: Int!
    edges: [FailoverSourceEdge!]!
    nodes: [FailoverSource!]!
    pageInfo: PageInfo!
}

type FailoverSourceEdge {
    cursor: String!
    node: FailoverSource!
}

type FailoverStatus {
    enumValue: FailoverStatusEnum!
}

type FailoverTable {
    focus: ReportFocusEnum!
    groupBy: [FailoverGroupByEnum!]
    name: String!
    selectedColumns: [FailoverTableColumnEnum!]!
    sortBy: FailoverSortByEnum
    sortOrder: SortOrderEnum
}

"All target sites."
type FailoverTargetSite {
    "Target site of the appflows failover job."
    targetSite: String!
}

type FailoverTargetSiteConnection {
    count: Int!
    edges: [FailoverTargetSiteEdge!]!
    nodes: [FailoverTargetSite!]!
    pageInfo: PageInfo!
}

type FailoverTargetSiteEdge {
    cursor: String!
    node: FailoverTargetSite!
}

type FailoverType {
    enumValue: FailoverTypeEnum!
}

"Feature specific details for a cloud account."
type FeatureDetail {
    "Aws regions."
    awsRegions: [AwsCloudAccountRegionEnum!]!
    "Feature enum."
    feature: CloudAccountFeatureEnum!
    "Role arn for feature."
    roleArn: String!
    "Stack arn for feature."
    stackArn: String!
    "Feature status for a cloud account."
    status: CloudAccountStatusEnum!
}

"A flag with a dynamically computed value."
type FeatureFlag {
    "Name of the flag."
    name: FeatureFlagNameEnum!
    "Computed value of this flag."
    variant: String
}

"A collection of all feature flags"
type FeatureFlagAll {
    "List of flags."
    flags: [FeatureFlag!]!
}

type FileResult {
    analyzerGroupResults: [AnalyzerGroupResult!]!
    analyzerResults: [AnalyzerResult!]!
    directory: String!
    errorCode: AnalyzerErrorCodeEnum!
    filename: String!
    filesWithHits: Hits
    hits: Hits!
    lastAccessTime: Long!
    lastModifiedTime: Long!
    mode: DataGovFileModeEnum!
    nativePath: String!
    numDescendantErrorFiles: Long!
    numDescendantFiles: Int!
    numDescendantFolders: Long!
    numDescendantSkippedExtFiles: Long!
    numDescendantSkippedSizeFiles: Long!
    openAccessFiles: Hits
    openAccessFilesWithHits: Hits
    openAccessFolders: Hits
    openAccessStaleFiles: Hits
    openAccessType: OpenAccessTypeEnum!
    paginationId: String!
    size: Long!
    snappable: HierarchyObject!
    staleFiles: Hits
    staleFilesWithHits: Hits
    stalenessType: StalenessTypeEnum!
    stdPath: String!
}

type FileResultConnection {
    count: Int!
    edges: [FileResultEdge!]!
    nodes: [FileResult!]!
    pageInfo: PageInfo!
}

type FileResultEdge {
    cursor: String!
    node: FileResult!
}

"""

Supported in v5.0+
"""
type FileVersion {
    """

    Supported in v5.0+
    The type of file, either a regular file or a directory
    """
    fileMode: String
    """

    Supported in v5.0+
    """
    lastModified: String
    """

    Supported in v5.0+
    """
    size: Long
    """

    Supported in v5.0+
    The snapshot this file belongs to
    """
    snapshotId: String
    """

    Supported in v5.0+
    The location where the file is stored, either in the cloud or locally
    """
    source: String
}

"""

Supported in v5.0+
"""
type FilesetArraySpec {
    """

    Supported in v5.0+
    ID assigned to a proxy host for array-enabled backups. This property is only required for array-enabled backups.
    """
    proxyHostId: String
}

"""

Supported in v5.0+
"""
type FilesetDetail {
    """

    Supported in v5.0+
    """
    archiveStorage: Long
    """

    Supported in v5.0+
    """
    archivedSnapshotCount: Int
    """

    Supported in v5.0+
    Action taken if script fails. Options are "abort", "continue"
  """
    backupScriptErrorHandling: String
    """

    Supported in v5.0+
    Number of seconds after which the script is killed if it has not completed execution
    """
    backupScriptTimeout: Long
    filesetSummary: FilesetSummary
    filesetUpdate: FilesetUpdate
    """

    Supported in v5.0+
    """
    localStorage: Long
    """

    Supported in v5.0+
    Script to run after backup of this Fileset ends
    """
    postBackupScript: String
    """

    Supported in v5.0+
    Script to run before backup of this Fileset starts
    """
    preBackupScript: String
    """

    Supported in v5.0+
    """
    protectionDate: DateTime
    """

    Supported in v5.0+
    """
    snapshotCount: Int!
    """

    Supported in v5.0+
    """
    snapshots: [FilesetSnapshotSummary!]!
}

"""

Supported in v5.0+
"""
type FilesetDetailListResponse {
    """

    Supported in v5.0+
    List of matching objects
    """
    data: [FilesetDetail!]!
    """

    Supported in v5.0+
    If there is more
    """
    hasMore: Boolean
    """

    Supported in v5.0+
    Total list responses
    """
    total: Long
}

"""

Supported in v5.0+
"""
type FilesetOptions {
    """

    Supported in v5.0+
    Include or exclude hidden folders inside locally-mounted remote file systems from backups.
    """
    allowBackupHiddenFoldersInNetworkMounts: Boolean
    """

    Supported in v5.0+
    Include or exclude locally-mounted remote file systems from backups.
    """
    allowBackupNetworkMounts: Boolean
    """

    Supported in v5.0+
    Use VSS during Windows backups.
    """
    useWindowsVss: Boolean
}

"""

Supported in v5.0+
"""
type FilesetSnapshotDetail {
    filesetSnapshotSummary: FilesetSnapshotSummary
    """

    Supported in v5.0+
    """
    lastModified: String!
    """

    Required. Supported in v5.0+
    """
    size: Long!
    """

    Supported in v5.0+
    """
    verbose: FilesetSnapshotVerbose
}

"""

Supported in v5.0+
"""
type FilesetSnapshotSummary {
    baseSnapshotSummary: BaseSnapshotSummary
    """

    Supported in v5.0+
    """
    fileCount: Long
    """

    Supported in v5.0+
    """
    filesetName: String!
    """

    Supported in v5.1+
    """
    snapdiffUsed: Boolean
}

"""

Supported in v5.0+
"""
type FilesetSnapshotVerbose {
    """

    Supported in v5.0+
    Whether or not the fileset snapshot has fingerprint info
    """
    hasFingerprint: Boolean!
    """

    Supported in v5.0+
    List a partition paths for the fileset snapshot
    """
    partitionPaths: [String!]!
}

"""

Supported in v5.0+
"""
type FilesetSummary {
    """

    Supported in v5.0+
    """
    arraySpec: FilesetArraySpec
    """

    Supported in v5.0+
    v5.0: The ID of the effective SLA domain for this Fileset
    v5.1+: The ID of the effective SLA Domain for this fileset.
    """
    effectiveSlaDomainId: String
    """

    Supported in v5.0+
    v5.0: The name of the effective SLA domain for this Fileset
    v5.1+: The name of the effective SLA Domain for this fileset.
    """
    effectiveSlaDomainName: String
    """

    Supported in v5.0+
    v5.0: Optional field containing Polaris managed id of the effective SLA domain if it is Polaris managed.
    v5.1+: Optional field containing Polaris managed ID of the effective SLA domain if it is Polaris managed.
    """
    effectiveSlaDomainPolarisManagedId: String
    """

    Supported in v5.1+
    A Boolean value that determines whether to recognize and dedupe hardlinks in a fileset. When 'true,' performs a hardlink deduplication. When 'false,' performs a normal backup that treats hardlinks as normal files. If not specified, this defaults to false.
    """
    enableHardlinkSupport: Boolean
    """

    Supported in v5.1+
    A Boolean value that determines whether to resolve symlink in a fileset. When 'true,' performs a symlink resolution. When 'false,' performs no symlink resolution. If not specified, this defaults to false.
    """
    enableSymlinkResolution: Boolean
    """

    Supported in v5.0+
    """
    exceptions: [String!]!
    """

    Supported in v5.0+
    """
    excludes: [String!]!
    """

    Supported in v5.2+
    ID of the failover cluster app.
    """
    failoverClusterAppId: String
    """

    Supported in v5.3
    The name of the failover cluster app.
    """
    failoverClusterAppName: String
    filesetOptions: FilesetOptions
    """

    Supported in v5.0+
    """
    hostId: String
    """

    Supported in v5.0+
    """
    hostName: String!
    """

    Required. Supported in v5.0+
    """
    includes: [String!]!
    """

    Supported in v5.1+
    An optional Boolean value that specifies whether the effective SLA Domain of a fileset is Retention Locked. When this value is 'true,' the SLA Domain is retention locked. When this value is 'false,' the SLA Domain is not Retention Locked.
    """
    isEffectiveSlaDomainRetentionLocked: Boolean
    """

    Supported in v5.0+
    v5.0: A Boolean value that determines whether to take a direct archive backup. When 'true,' performs a direct archive backup. When 'false,' performs a normal backup.
    v5.1+: A Boolean value that determines whether to take a direct archive backup. When 'true,' performs a direct archive backup. When 'false,' performs a normal backup. If not specified, this defaults to false.
    """
    isPassthrough: Boolean
    """

    Supported in v5.0+
    """
    isRelic: Boolean!
    """

    Supported in v5.0+
    """
    operatingSystemType: String
    """

    Supported in v5.2+
    v5.2: Describes any pending SLA Domain assignment to this object.
    v5.3: Describes any pending SLA Domain assignment on this object.
    """
    pendingSlaDomain: ManagedObjectPendingSlaInfo
    """

    Supported in v5.0+
    """
    shareId: String
    slaAssignable: SlaAssignable
    """

    Supported in v5.0+
    """
    templateId: String!
    """

    Supported in v5.0+
    """
    templateName: String!
}

type FilesetTemplate implements CdmHierarchyObject & HierarchyObject {
    allowBackupHiddenFoldersInNetworkMounts: Boolean!
    allowBackupNetworkMounts: Boolean!
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    backupScriptErrorHandling: String!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "List of descendants"
    descendantConnection(
        after: String,
        filter: [Filter!],
        first: Int,
        "provide optional snappable hierarchy for RBAC and SLA, none value is assumed to be All snappable hierarchy"
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): FilesetTemplateDescendantTypeConnection!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    exceptions: [String!]!
    excludes: [String!]!
    "The fid of the hierarchy object."
    id: UUID!
    includes: [String!]!
    isArrayEnabled: Boolean!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    osType: FilesetOSType!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "List of physical children"
    physicalChildConnection(
        after: String,
        filter: [Filter!],
        first: Int,
        "provide optional snappable hierarchy for RBAC and SLA, none value is assumed to be All snappable hierarchy"
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): FilesetTemplatePhysicalChildTypeConnection!
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    postBackupScript: String!
    preBackupScript: String!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "Share type of this fileset template"
    shareType: ShareTypeEnum!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

type FilesetTemplateConnection {
    count: Int!
    edges: [FilesetTemplateEdge!]!
    nodes: [FilesetTemplate!]!
    pageInfo: PageInfo!
}

"""

Supported in v5.0+
"""
type FilesetTemplateCreate {
    """

    Supported in v5.0+
    Action taken if script fails. Options are "abort", "continue"
  """
    backupScriptErrorHandling: String
    """

    Supported in v5.0+
    Number of seconds after which the script is killed if it has not completed execution
    """
    backupScriptTimeout: Long
    """

    Supported in v5.0+
    """
    exceptions: [String!]!
    """

    Supported in v5.0+
    """
    excludes: [String!]!
    filesetOptions: FilesetOptions
    """

    Required. Supported in v5.0+
    """
    includes: [String!]!
    """

    Supported in v5.0+
    Boolean value that determines whether the fileset is array-enabled. Set to true to indicate that the fileset is array-enabled. Set to false to indicate that the fileset is not array-enabled. When a fileset is array-enabled, the includes must be top-level LVM logical volume mount points.
    """
    isArrayEnabled: Boolean
    """

    Required. Supported in v5.0+
    """
    name: String!
    """

    Supported in v5.0+
    Operating system type of filesets created by template.
    """
    operatingSystemType: FilesetTemplateCreateOperatingSystemTypeEnum!
    """

    Supported in v5.0+
    Script to run after backup of this fileset ends
    """
    postBackupScript: String
    """

    Supported in v5.0+
    Script to run before backup of this fileset starts
    """
    preBackupScript: String
    """

    Supported in v5.0+
    """
    shareType: FilesetTemplateCreateShareTypeEnum!
}

type FilesetTemplateDescendantTypeConnection {
    count: Int!
    edges: [FilesetTemplateDescendantTypeEdge!]!
    nodes: [FilesetTemplateDescendantType!]!
    pageInfo: PageInfo!
}

type FilesetTemplateDescendantTypeEdge {
    cursor: String!
    node: FilesetTemplateDescendantType!
}

"""

Supported in v5.0+
"""
type FilesetTemplateDetail {
    filesetTemplateCreate: FilesetTemplateCreate
    """

    Supported in v5.0+
    Number of hosts where this template has been applied
    """
    hostCount: Int
    """

    Required. Supported in v5.0+
    """
    id: String!
    """

    Supported in v5.0+
    """
    isArchived: Boolean
    """

    Supported in v5.0+
    """
    primaryClusterId: String!
    """

    Supported in v5.0+
    Number of shares where this template has been applied
    """
    shareCount: Int
}

"""

Supported in v5.0+
"""
type FilesetTemplateDetailListResponse {
    """

    Supported in v5.0+
    List of matching objects
    """
    data: [FilesetTemplateDetail!]!
    """

    Supported in v5.0+
    If there is more
    """
    hasMore: Boolean
    """

    Supported in v5.0+
    Total list responses
    """
    total: Long
}

type FilesetTemplateEdge {
    cursor: String!
    node: FilesetTemplate!
}

type FilesetTemplatePhysicalChildTypeConnection {
    count: Int!
    edges: [FilesetTemplatePhysicalChildTypeEdge!]!
    nodes: [FilesetTemplatePhysicalChildType!]!
    pageInfo: PageInfo!
}

type FilesetTemplatePhysicalChildTypeEdge {
    cursor: String!
    node: FilesetTemplatePhysicalChildType!
}

"""

Supported in v5.0+
"""
type FilesetUpdate {
    """

    Supported in v5.0+
    v5.0-v5.1: Assign Fileset to SLA domain
    v5.2+: Assign Fileset to SLA domain. Existing snapshots of the object will be retained with the configuration of specified SLA Domain.
    """
    configuredSlaDomainId: String
    """

    Supported in v5.2+
    Whether to force a full on the whole fileset or certain partitions of the fileset. If this is set to true and no partitionIds are provided, then a full will be forced on the whole fileset. If set to true and partitionIds are provided, then we will force a full on only those partitions.
    """
    forceFull: Boolean
    """

    Supported in v5.2+
    Assign partition ids to set the force full. In order for this to be valid input, forceFull must be set to true.
    """
    forceFullPartitionIds: [Int!]!
}

type FilterOption {
    displayValue: String!
    value: String
}

"Detail of the Gcp Cloud Account Add operations."
type GcpCloudAccountAddProjectDetail {
    error: String!
    projectId: String!
    uuid: String!
}

"Gcp Cloud Account Add Projects Response."
type GcpCloudAccountAddProjectsResponse {
    details: [GcpCloudAccountAddProjectDetail!]!
}

"Details of the Gcp Cloud Account feature."
type GcpCloudAccountFeatureDetail {
    feature: CloudAccountFeatureEnum!
    status: CloudAccountStatusEnum!
}

"List of permissions missing for project addition for projects ineligible for addition."
type GcpCloudAccountMissingPermissionsForAddition {
    missingPermissions: [String!]!
    projectId: String!
}

"Gcp Cloud Account OAuth Complete Response."
type GcpCloudAccountOAuthCompleteResponse {
    userInfo: GcpOAuthUserInfo
}

"Gcp Cloud Account OAuth Initiate Response."
type GcpCloudAccountOAuthInitiateResponse {
    clientId: String!
    redirectUrl: String!
    scope: [String!]!
    sessionId: String!
    state: String!
}

"Gcp Cloud Account Project Type."
type GcpCloudAccountProject {
    id: String!
    name: String!
    projectId: String!
    projectNumber: Long!
    roleId: String!
}

"Status of the Gcp Cloud Account delete operation."
type GcpCloudAccountProjectDeleteStatus {
    error: String!
    projectUuid: String!
    success: Boolean!
}

"Details of the Gcp Cloud Account project configured for a feature."
type GcpCloudAccountProjectDetail {
    featureDetail: GcpCloudAccountFeatureDetail
    project: GcpCloudAccountProject
}

"Status of the Gcp Cloud Account upgrade operation."
type GcpCloudAccountProjectUpgradeStatus {
    error: String!
    projectUuid: String!
    success: Boolean!
}

"Gcp List Projects For OAuth Response"
type GcpListProjectsForOAuthResponse {
    missingPermissions: [String!]
    name: String!
    projectId: String!
}

"Represents the attachment details of a GCP native disk "
type GcpNativeAttachmentDetails {
    deviceName: String!
    diskID: String!
    diskName: String!
    instanceID: String!
    instanceName: String!
    instanceZone: String!
    isBootDisk: Boolean!
    isExcluded: Boolean!
    sizeInGBs: Int!
}

type GcpNativeDisk implements GcpNativeProjectDescendantType & GcpNativeProjectLogicalChildType & HierarchyObject & PolarisHierarchyObject & PolarisHierarchySnappable {
    "Instances to which the disk is attached"
    attachedInstances: [GcpNativeAttachmentDetails!]!
    "The authorized operations on the object."
    authorizedOperations: [PolarisSnappableAuthorizedOperationsEnum!]!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    diskID: String!
    diskName: String!
    diskType: String!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "GCP Project of the Disk"
    gcpNativeProject: GcpNativeProject!
    "The fid of the hierarchy object."
    id: UUID!
    isRelic: Boolean!
    kmsKey: String!
    labels: [Label!]!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "the newest snapshot that is indexed and unexpired, and therefore restorable."
    newestIndexedSnapshot: PolarisSnapshot
    "the most recent snapshot of this snappable"
    newestSnapshot: PolarisSnapshot
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "the oldest snapshot of this snappable"
    oldestSnapshot: PolarisSnapshot
    "the number of on-demand snapshots"
    onDemandSnapshotCount: Int!
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    projectId: String!
    region: String!
    replicaZones: [String!]!
    sizeInGBs: Int!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The list of snapshots taken for this snappable"
    snapshotConnection(
        after: String,
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        first: Int,
        last: Int,
        "sort polaris snapshots by field"
        sortBy: PolarisSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): PolarisSnapshotConnection
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByConnection(
        after: String,
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        first: Int,
        "group polaris snapshots by field"
        groupBy: PolarisSnapshotGroupByEnum!,
        last: Int,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByConnection
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByNewConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "filter polaris snapshot connection"
        snapshotFilter: [PolarisSnapshotFilterNewInput!]!,
        "group polaris snapshots by field"
        snapshotGroupBy: SnapshotGroupByTimeEnum!,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByNewConnection
    "The list of snapshots taken for this snappable"
    snapshotsOfSnappableConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        snappableId: String!,
        "filter for snapshot connection"
        snapshotFilter: [SnapshotQueryFilterInput!],
        sortBy: SnapshotQuerySortByField,
        "sort order"
        sortOrder: SortOrderEnum,
        timeRange: TimeRangeInput
    ): GenericSnapshotConnection
    zone: String!
}

type GcpNativeDiskConnection {
    count: Int!
    edges: [GcpNativeDiskEdge!]!
    nodes: [GcpNativeDisk!]!
    pageInfo: PageInfo!
}

type GcpNativeDiskEdge {
    cursor: String!
    node: GcpNativeDisk!
}

"Represents a GCP native firewall rule"
type GcpNativeFirewallRule {
    name: String!
    targetTags: [String!]!
}

type GcpNativeGCEInstance implements GcpNativeProjectDescendantType & GcpNativeProjectLogicalChildType & HierarchyObject & PolarisHierarchyObject & PolarisHierarchySnappable {
    "Attached disks"
    attachedDisks: [GcpNativeAttachmentDetails!]!
    "The authorized operations on the object."
    authorizedOperations: [PolarisSnappableAuthorizedOperationsEnum!]!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "GCP Project of the GCE Instance"
    gcpNativeProject: GcpNativeProject!
    "The fid of the hierarchy object."
    id: UUID!
    isRelic: Boolean!
    labels: [Label!]!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    machineType: String!
    "The name of the hierarchy object."
    name: String!
    nativeId: String!
    nativeName: String!
    networkHostProjectNativeId: String!
    "the newest snapshot that is indexed and unexpired, and therefore restorable."
    newestIndexedSnapshot: PolarisSnapshot
    "the most recent snapshot of this snappable"
    newestSnapshot: PolarisSnapshot
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "the oldest snapshot of this snappable"
    oldestSnapshot: PolarisSnapshot
    "the number of on-demand snapshots"
    onDemandSnapshotCount: Int!
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    projectId: String!
    region: String!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The list of snapshots taken for this snappable"
    snapshotConnection(
        after: String,
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        first: Int,
        last: Int,
        "sort polaris snapshots by field"
        sortBy: PolarisSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): PolarisSnapshotConnection
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByConnection(
        after: String,
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        first: Int,
        "group polaris snapshots by field"
        groupBy: PolarisSnapshotGroupByEnum!,
        last: Int,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByConnection
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByNewConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "filter polaris snapshot connection"
        snapshotFilter: [PolarisSnapshotFilterNewInput!]!,
        "group polaris snapshots by field"
        snapshotGroupBy: SnapshotGroupByTimeEnum!,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByNewConnection
    "The list of snapshots taken for this snappable"
    snapshotsOfSnappableConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        snappableId: String!,
        "filter for snapshot connection"
        snapshotFilter: [SnapshotQueryFilterInput!],
        sortBy: SnapshotQuerySortByField,
        "sort order"
        sortOrder: SortOrderEnum,
        timeRange: TimeRangeInput
    ): GenericSnapshotConnection
    vpcName: String!
    zone: String!
}

type GcpNativeGCEInstanceConnection {
    count: Int!
    edges: [GcpNativeGCEInstanceEdge!]!
    nodes: [GcpNativeGCEInstance!]!
    pageInfo: PageInfo!
}

type GcpNativeGCEInstanceEdge {
    cursor: String!
    node: GcpNativeGCEInstance!
}

"Represents a GCP native VPC network"
type GcpNativeNetwork {
    firewallRules: [GcpNativeFirewallRule!]!
    name: String!
    nativeProjectId: String!
    subnetworks: [GcpNativeSubnetwork!]!
}

type GcpNativeProject implements HierarchyObject & PolarisHierarchyObject {
    "The authorized operations on the object."
    authorizedOperations: [PolarisObjectAuthorizedOperationsEnum!]!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    diskCount: Int!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "List of all GCE instances under this GCP project"
    gcpNativeGceInstanceConnection(after: String, before: String, first: Int, gceInstanceFilters: GcpNativeGceInstanceFilters, last: Int, sortBy: HierarchySortByField, sortOrder: HierarchySortOrder): GcpNativeGCEInstanceConnection!
    "The fid of the hierarchy object."
    id: UUID!
    lastRefreshedAt: DateTime
    "List of logical children"
    logicalChildConnection(
        after: String,
        filter: [Filter!],
        first: Int,
        "provide optional snappable hierarchy for RBAC and SLA, none value is assumed to be All snappable hierarchy"
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): GcpNativeProjectLogicalChildTypeConnection!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    nativeId: String!
    nativeName: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    organizationName: String!
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    projectNumber: String!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
    status: GcpNativeProjectStatusEnum!
    vmCount: Int!
}

type GcpNativeProjectConnection {
    count: Int!
    edges: [GcpNativeProjectEdge!]!
    nodes: [GcpNativeProject!]!
    pageInfo: PageInfo!
}

type GcpNativeProjectEdge {
    cursor: String!
    node: GcpNativeProject!
}

type GcpNativeProjectLogicalChildTypeConnection {
    count: Int!
    edges: [GcpNativeProjectLogicalChildTypeEdge!]!
    nodes: [GcpNativeProjectLogicalChildType!]!
    pageInfo: PageInfo!
}

type GcpNativeProjectLogicalChildTypeEdge {
    cursor: String!
    node: GcpNativeProjectLogicalChildType!
}

"Represents a GCP native region"
type GcpNativeRegion {
    name: String!
    zones: [String!]!
}

"Represents a GCP native subnetwork"
type GcpNativeSubnetwork {
    name: String!
    region: String!
}

type GcpOAuthUserInfo {
    domain: String!
    emailId: String!
    firstName: String!
}

type GenericSnapshotConnection {
    count: Int!
    edges: [GenericSnapshotEdge!]!
    nodes: [GenericSnapshot!]!
    pageInfo: PageInfo!
}

type GenericSnapshotEdge {
    cursor: String!
    node: GenericSnapshot!
}

type GenericTimeRange {
    absoluteTimeRange: TimeRange
    relativeTimeRange: RelativeTimeRange
}

type GeoLocation {
    address: String!
    latitude: Float!
    longitude: Float!
}

type GetAppBlueprintOngoingFailoverTaskchainUuidsRsp {
    taskchains: [TaskchainInfo!]!
}

type GetAppBlueprintSnapshotCloudImagesRsp {
    snapshotCloudImages: [AppBlueprintSnapshotCloudImage!]!
}

"A list of availability zones in the given region."
type GetAvailabilityZonesFromAwsReply {
    availabilityZones: [String!]!
}

type GetAzureO365ExocomputeResp {
    cluster: AzureO365ExocomputeCluster
}

"It contains the list of all label rules visible to the user"
type GetCloudNativeLabelRulesReply {
    labelRules: [LabelRule!]!
}

"It contains the list of all tag rules visible to the user"
type GetCloudNativeTagRulesReply {
    tagRules: [CloudNativeTagRule!]!
}

type GetDashboardSummaryReply {
    analyzerResults: [AnalyzerResult!]!
    policyResults: [AnalyzerGroupResult!]!
}

"Lambda configuration details of given cluster"
type GetLambdaConfigReply {
    accountId: String!
    clusterId: String!
    defaultDiffFmdUploadPrefix: String!
    enableAutomaticFmdUpload: Boolean!
    enableFmdUploadForAllResources: Boolean!
    maxSnapshotsToUploadAutomatically: Int!
}

"The PIT restore window of the RDS instance."
type GetPITRestoreWindowReply {
    earliestTime: DateTime
    latestTime: DateTime
}

type GetPoliciesTimelineReply {
    policyFilesHitsEntries: [TimelineEntry!]!
    policyHitsEntries: [TimelineEntry!]!
    policyOaFilesHitsEntries: [TimelineEntry!]!
    policyStaleFilesHitsEntries: [TimelineEntry!]!
    policySummaries: [ClassificationPolicySummary!]!
    totalFilesHitsEntries: [TimelineEntry!]!
    totalHitsEntries: [TimelineEntry!]!
    totalOaFilesEntries: [TimelineEntry!]!
    totalOaFilesHitsEntries: [TimelineEntry!]!
    totalOaFoldersEntries: [TimelineEntry!]!
    totalStaleFilesHitsEntries: [TimelineEntry!]!
    totalStaleOaFilesEntries: [TimelineEntry!]!
}

"RDS DB Instance details from AWS."
type GetRdsInstanceDetailsFromAWSReply {
    allocatedStorageInGb: Long!
    backupRetentionPeriod: Long!
    dbEngine: String!
    dbInstanceClass: String!
    dbInstanceStatus: String!
    dbMaintenanceWindow: String!
    dbParameterGroupName: String!
    dbSubnetGroupName: String!
    engineVersion: String!
    iops: Long!
    isMultiAz: Boolean!
    kmsKeyId: String!
    optionGroupName: String!
    port: Long!
    primaryAz: String!
    rdsInstanceArn: String!
    storageType: String!
    vpcId: String!
}

type GetSMTPConfigurationReply {
    defaultFromEmail: String!
    hostname: String!
    isValid: Boolean!
    port: Int!
    securityType: SMTPSecurityTypeEnum!
    trustedCerts: String!
    username: String!
}

type GetSPExplicitReply {
    applicationCallbackUrl: String!
    encryptionCertificate: String!
    signingCertificate: String!
    spEntityId: String!
}

"Taskchain status reply"
type GetTaskchainStatusReply {
    taskchain: Taskchain
}

"Get IP whitelist configuration"
type GetWhitelistReply {
    enabled: Boolean!
    ipCidrs: [String!]!
    mode: WhitelistModeEnum!
}

"Metadata for rendering a global sla."
type GlobalSla implements SlaDomain {
    archivalSpec: ArchivalSpec
    backupWindows: [BackupWindow!]!
    baseFrequency: SlaDuration
    clusterToSyncStatusMap: [PolarisSLASyncStatus!]!
    clusterUUID: String!
    description: String!
    firstFullBackupWindows: [BackupWindow!]!
    id: String!
    isArchived: Boolean!
    isDefault: Boolean!
    localRetentionLimit: SlaDuration
    logConfig: LogConfigResult
    name: String!
    objectSpecificConfigs: ObjectSpecificConfigs
    objectTypeList: [SLAObjectTypeEnum!]!
    protectedObjectCount: Int!
    replicationSpec: ReplicationSpec
    replicationSpecV2: [ReplicationSpecV2!]!
    snapshotSchedule: SnapshotSchedule
    snapshotScheduleLastUpdatedAt: DateTime
    stateVersion: Long!
    uiColor: String!
}

"Metadata for rendering a sla for filter."
type GlobalSlaForFilter {
    id: String!
    name: String!
}

type GlobalSlaForFilterConnection {
    count: Int!
    edges: [GlobalSlaForFilterEdge!]!
    nodes: [GlobalSlaForFilter!]!
    pageInfo: PageInfo!
}

type GlobalSlaForFilterEdge {
    cursor: String!
    node: GlobalSlaForFilter!
}

type Group {
    groupId: String!
    roles: [Role!]!
    users: [User!]!
}

type GroupCount {
    count: Int!
    group: String!
}

type GroupCountListWithTotal {
    groupList: [GroupCount!]!
    totalCount: Int!
}

type GrowthResponse {
    growthList: [GrowthResponseSnapshot!]!
}

type GrowthResponseSnapshot {
    awsPrice: Float!
    azurePrice: Float!
    cumArchiveStorage: Float!
    date: Long!
    storageInGb: Float!
}

"""

Supported in v5.2+
"""
type HdfsBaseConfig {
    """

    Supported in v5.2+
    API token to access Hdfs
    """
    apiToken: String
    """

    Required. Supported in v5.2+
    List of Hdfs Namenode Hosts
    """
    hosts: [HdfsHost!]!
    """

    Supported in v5.2+
    Ticket Cache Path of Kerberos Ticket
    """
    kerberosTicket: String
    """

    Supported in v5.2+
    Logical name for nameservice for Hdfs HA
    """
    nameservices: String
    """

    Supported in v5.2+
    Username to access Hdfs API
    """
    username: String
}

"""

Supported in v5.2+
"""
type HdfsHost {
    """

    Required. Supported in v5.2+
    Hostname or Ip of Namenode
    """
    hostname: String!
    """

    Required. Supported in v5.2+
    Port number of Namenode
    """
    port: Int!
}

type HierarchyObjectConnection {
    count: Int!
    edges: [HierarchyObjectEdge!]!
    nodes: [HierarchyObject!]!
    pageInfo: PageInfo!
}

type HierarchyObjectEdge {
    cursor: String!
    node: HierarchyObject!
}

type HierarchySnappableConnection {
    count: Int!
    edges: [HierarchySnappableEdge!]!
    nodes: [HierarchySnappable!]!
    pageInfo: PageInfo!
}

type HierarchySnappableEdge {
    cursor: String!
    node: HierarchySnappable!
}

type HierarchySnappableFileVersion {
    fileMode: FileModeEnum!
    lastModified: DateTime!
    size: Long!
    snapshot: CdmSnapshot
    snapshotId: String!
    source: FileVersionSourceEnum!
}

type Hits {
    permittedHits: Int!
    permittedHitsDelta: Int!
    totalHits: Int!
    totalHitsDelta: Int!
    violations: Int!
    violationsDelta: Int!
}

"The connection status of a host"
type HostConnectionStatus {
    connectivity: HostConnectivityStatusEnum!
    timestampMillis: DateTime
}

"""

Supported in v5.0+
"""
type HostConnectivitySummary {
    """

    Required. Supported in v5.0+
    """
    action: String!
    """

    Required. Supported in v5.0+
    """
    status: String!
}

"""

Supported in v5.0+
"""
type HostDetail {
    """

    Supported in v5.0+
    v5.0-v5.2:
    v5.3: ID of the Rubrik Backup Service (RBS) installed on the host.
    """
    agentId: String
    """

    Supported in v5.0+
    v5.0-v5.2:
    v5.3: Indicates if compression is enabled while transferring data between the host and the Rubrik cluster.
    """
    compressionEnabled: Boolean
    hostSummary: HostSummary
    """

    Supported in v5.0+
    Specifies the installation status of the VFD driver on a Windows host. The value is 'NotInstalled' when the driver is absent. The value is 'Installed' when the driver is present. The value is 'RestartRequred' when the driver is present but requires a restart of the Windows host in order to function.
    """
    hostVfdDriverState: HostVfdStateEnum!
    """

    Supported in v5.0+
    Specifies the status of VFD-based volume backups on Windows hosts. The value is 'Enabled' when VFD-based volume backups are enabled. The value is 'Disabled' when VFD-based volume backups are disabled.
    """
    hostVfdEnabled: HostVfdInstallConfigEnum!
    """

    Supported in v5.2+
    v5.2: Specifies whether the host is an Oracle host. When the host is an Oracle host, the UI displays the Oracle discovery fields.
    v5.3: Specifies whether this is an Oracle host. This indicates whether to show Oracle discovery fields in the UI.
    """
    isOracleHost: Boolean
    """

    Supported in v5.0+
    A relic host is deleted, but still may have snapshots associated with its children (e.g. Fileset)
    """
    isRelic: Boolean!
    """

    Supported in v5.0+
    v5.0-v5.2: Boolean value that indicates whether the CBT driver is installed for SQL Server instances on the specified Windows host. Set to true when the CBT driver is installed. Set to false when the CBT driver is not installed
    v5.3: Indicates if the CBT driver is installed for SQL Server instances on the specified Windows host. Set to true when the CBT driver is installed. Set to false when the CBT driver is not installed
    """
    mssqlCbtDriverInstalled: Boolean!
    """

    Supported in v5.0+
    Specifies the Oracle username for an account with query privileges.
    """
    oracleQueryUser: String
    """

    Supported in v5.0+
    Specifies the Oracle username for an account with sysdba privileges.
    """
    oracleSysDbaUser: String
}

"""

Supported in v5.0+
"""
type HostDetailListResponse {
    """

    Supported in v5.0+
    List of matching objects
    """
    data: [HostDetail!]!
    """

    Supported in v5.0+
    If there is more
    """
    hasMore: Boolean
    """

    Supported in v5.0+
    Total list responses
    """
    total: Long
}

"""

Supported in v5.0+
"""
type HostDiagnosisSummary {
    """

    Supported in v5.0+
    """
    connectivity: [HostConnectivitySummary!]!
}

type HostShare implements CdmHierarchyObject & HierarchyObject & PhysicalHostDescendantType & PhysicalHostPhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "List of descendants"
    descendantConnection(
        after: String,
        filter: [Filter!],
        first: Int,
        "provide optional snappable hierarchy for RBAC and SLA, none value is assumed to be All snappable hierarchy"
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): HostShareDescendantTypeConnection!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "List of physical children"
    physicalChildConnection(
        after: String,
        filter: [Filter!],
        first: Int,
        "provide optional snappable hierarchy for RBAC and SLA, none value is assumed to be All snappable hierarchy"
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): HostSharePhysicalChildTypeConnection!
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

type HostShareConnection {
    count: Int!
    edges: [HostShareEdge!]!
    nodes: [HostShare!]!
    pageInfo: PageInfo!
}

type HostShareDescendantTypeConnection {
    count: Int!
    edges: [HostShareDescendantTypeEdge!]!
    nodes: [HostShareDescendantType!]!
    pageInfo: PageInfo!
}

type HostShareDescendantTypeEdge {
    cursor: String!
    node: HostShareDescendantType!
}

type HostShareEdge {
    cursor: String!
    node: HostShare!
}

type HostSharePhysicalChildTypeConnection {
    count: Int!
    edges: [HostSharePhysicalChildTypeEdge!]!
    nodes: [HostSharePhysicalChildType!]!
    pageInfo: PageInfo!
}

type HostSharePhysicalChildTypeEdge {
    cursor: String!
    node: HostSharePhysicalChildType!
}

"""

Supported in v5.0+
"""
type HostSummary {
    """

    Supported in v5.1+
    A user-specified string that returns this host in searches.
    """
    alias: String
    """

    Supported in v5.2+
    """
    hdfsBaseConfig: HdfsBaseConfig
    """

    Required. Supported in v5.0+
    Deprecated. Please use 'name' instead.
    """
    hostname: String!
    """

    Required. Supported in v5.0+
    v5.0-v5.2:
    v5.3: Unique identifier for host.
    """
    id: String!
    """

    Supported in v5.0+
    Property that indicates whether CBT is enabled for backups of SQL Server databases on a Windows host. When the value of mssqlCbtEnabled is Default, this property has the same value as the global CBT setting. In all other cases, this property has the same value as mssqlCbtEnabled. To change the global CBT setting, use the SQL Server default property update endpoint.
    """
    mssqlCbtEffectiveStatus: MssqlCbtEffectiveStatusTypeEnum!
    """

    Supported in v5.0+
    Property that indicates whether CBT is enabled for backups of SQL Server databases on a Windows host. Set to Enabled when CBT based backups of SQL Server databases for the specified Windows host is enabled. Set to Disabled when CBT based backups of SQL Server databases for the specified Windows host is turned off. Set to Default when the Windows host inherits the global CBT setting
    """
    mssqlCbtEnabled: MssqlCbtStatusTypeEnum!
    """

    Supported in v5.0+
    v5.0-v5.2:
    v5.3: IP address or hostname of the host.
    """
    name: String
    """

    Supported in v5.0+
    """
    nasBaseConfig: NasBaseConfig
    """

    Supported in v5.0+
    v5.0-v5.2:
    v5.3: Operating system of the host. One of Windows, Linux, AIX, HPUX, and SunOS.
    """
    operatingSystem: String
    """

    Supported in v5.0+
    v5.0-v5.2:
    v5.3: The operating system of the host. Possible choices are Windows, Linux, AIX, HPUX, SunOS.
    """
    operatingSystemType: String
    """

    Supported in v5.0+
    The ID of the organization to which the host is assigned (set by envoy).
    """
    organizationId: String
    """

    Supported in v5.0+
    The name of the organization to which the host is assigned (set by envoy).
    """
    organizationName: String
    """

    Supported in v5.0+
    v5.0-v5.2:
    v5.3: ID of the Rubrik cluster to which the host belongs.
    """
    primaryClusterId: String
    """

    Supported in v5.0+
    v5.0-v5.2:
    v5.3: Specifies the connect status for the host. Status is Refreshing while discovery is running or Connected once discovery was successful and the host is available.
    """
    status: String
}

type HourlySnapshotSchedule {
    basicSchedule: BasicSnapshotSchedule
}

type IdentityProvider {
    entityId: String!
    expirationDate: DateTime
    name: String!
    signInUrl: String!
    signOutUrl: String!
    spInitiatedSignInUrl: String!
    spInitiatedTestUrl: String!
}

type InfrastructureChart {
    focus: ReportFocusEnum!
    groupBy: [ClusterGroupByEnum!]
    name: String!
}

type InfrastructureTable {
    focus: ReportFocusEnum!
    groupBy: [ClusterGroupByEnum!]
    name: String!
    selectedColumns: [InfrastructureTableColumnEnum!]!
    sortBy: ClusterSortByEnum
    sortOrder: SortOrderEnum
}

"Interface CIDR Info."
type InterfaceCidr {
    cidr: String!
    interfaceType: InterfaceTypeEnum!
    selected: Boolean!
}

type InternalBulkUpdateHostResponse {
    items: [HostDetail!]!
}

type InventoryRoot {
    "List of descendants"
    descendantConnection(
        after: String,
        filter: [Filter!],
        first: Int,
        "provide optional snappable hierarchy for RBAC and SLA, none value is assumed to be All snappable hierarchy"
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): HierarchyObjectConnection!
}

type InventorySubHierarchyRoot {
    "List of children"
    childConnection(
        after: String,
        filter: [Filter!],
        first: Int,
        "provide optional snappable hierarchy for RBAC and SLA, none value is assumed to be All snappable hierarchy"
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): HierarchyObjectConnection!
    "List of descendants"
    descendantConnection(
        after: String,
        filter: [Filter!],
        first: Int,
        "provide optional snappable hierarchy for RBAC and SLA, none value is assumed to be All snappable hierarchy"
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): HierarchyObjectConnection!
    rootEnum: InventorySubHierarchyRootEnum!
    "List of top-level descendants (with respect to RBAC)"
    topLevelDescendantConnection(after: String, filter: [Filter!], first: Int, sortBy: HierarchySortByField, sortOrder: HierarchySortOrder, typeFilter: [HierarchyObjectTypeEnum!]): HierarchyObjectConnection!
}

"It checks if the rule name is unique or not"
type IsCloudNativeTagRuleNameUniqueReply {
    isUnique: Boolean!
}

"A boolean specifying whether the volume snapshot is restorable"
type IsVolumeSnapshotRestorableReply {
    isRestorable: Boolean!
}

type Issue {
    events: [IssueEvent!]!
    fileResult: FileResult!
    id: String!
    latestPolicyObj: PolicyObj!
    openTime: Long!
    paginationId: String!
    policies: [ClassificationPolicySummary!]!
    resolvedTime: Long!
    violations: Int!
}

type IssueConnection {
    count: Int!
    edges: [IssueEdge!]!
    nodes: [Issue!]!
    pageInfo: PageInfo!
}

type IssueEdge {
    cursor: String!
    node: Issue!
}

type IssueEvent {
    snapshotFid: String!
    timestamp: Long!
    type: IssueEventTypeEnum!
    violations: Int!
    violationsDelta: Int!
}

type JobMetadata {
    createdAt: DateTime
    currentInstance: Int!
    id: Long!
    info: String!
    jobType: String!
    lastFailure: DateTime
    lastOwner: String!
    lastSkipped: DateTime
    lastSuccess: DateTime
    logLevel: LogLevelEnum!
    numScheduledRuns: Int!
    numSuccessfulRuns: Int!
    owner: String!
    progress: String!
    progressedAt: DateTime
    retryAttempts: Int!
    startTime: DateTime
    startedAt: DateTime
    state: String!
    updatedAt: DateTime
}

type JobReply {
    clusterName: String!
    clusterUuid: String!
    customerAccount: String!
    metadata: JobMetadata
    version: String!
}

type JobsReply {
    jobs: [JobReply!]!
}

"Represents a fully qualified GCP native KMS Crypto Key"
type KMSCryptoKey {
    key: String!
    keyRing: String!
    location: String!
    projectNativeId: String!
}

"A kms key in AWS realm."
type KMSEncryptionKeyType {
    aliases: [String!]!
    arn: String!
    id: String!
}

type KMSKey {
    arn: String!
    id: String!
    name: String!
}

type LDAPConfig {
    clusterId: String!
    domain: String!
    id: Long!
    ldapName: String!
    password: String!
    userName: String!
}

type Label {
    key: String!
    value: String!
}

"A single Label Rule"
type LabelRule {
    Label: CloudNativeLabel
    cloudNativeAccounts: [CloudNativeAccountIdWithName!]!
    effectiveSla: TagRuleEffectiveSla
    hasPermissionToModify: Boolean!
    id: String!
    name: String!
    objectType: ManagedObjectType!
}

type LambdaSettings {
    anomalyThreshold: Float
    isAnomalyAlertEnabled: Boolean
    ransomwareThreshold: Float
}

type LastTestStatus {
    enumValue: LastTestStatusEnum!
}

"Ldap Integration Information"
type LdapIntegration {
    baseDn: String!
    bindUserName: String!
    dynamicDnsName: String!
    groupMemberAttr: String
    groupMembershipAttr: String
    groupSearchFilter: String
    id: String!
    ldapServers: [LdapServer!]!
    name: String!
    trustedCerts: String
    userNameAttr: String
    userSearchFilter: String
}

type LdapIntegrationConnection {
    count: Int!
    edges: [LdapIntegrationEdge!]!
    nodes: [LdapIntegration!]!
    pageInfo: PageInfo!
}

type LdapIntegrationEdge {
    cursor: String!
    node: LdapIntegration!
}

"Ldap Server Information"
type LdapServer {
    hostname: String!
    port: Int!
    useTls: Boolean!
}

"""

Supported in v5.0+
"""
type Link {
    """

    Required. Supported in v5.0+
    v5.0: The link's destination.
    v5.1+: The destination of the link.
    """
    href: String!
    """

    Required. Supported in v5.0+
    v5.0: The relation of this link's destination to the current resource.
    v5.1+: The relation of the destination of this link to the current resource.
    """
    rel: String!
}

type LinuxFileset implements CdmHierarchyObject & CdmHierarchySnappableNew & FilesetTemplateDescendantType & FilesetTemplatePhysicalChildType & HierarchyObject & HierarchySnappable & PhysicalHostDescendantType & PhysicalHostPhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    cdmId: String!
    "A link to view the snappable on the CDM cluster. For dev use only."
    cdmLink: String!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    hardlinkSupportEnabled: Boolean!
    host: PhysicalHost!
    "The fid of the hierarchy object."
    id: UUID!
    isPassThrough: Boolean!
    isRelic: Boolean!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The list of missed snapshots for this VM"
    missedSnapshotConnection(
        after: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        first: Int
    ): MissedSnapshotCommonConnection
    "The list of missed snapshots for this VM"
    missedSnapshotGroupByConnection(
        after: String,
        before: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        first: Int,
        "group snapshots by field"
        groupBy: MissedSnapshotGroupByEnum!,
        last: Int,
        timezoneOffset: Float = 0.0
    ): MissedSnapshotGroupByConnection
    "The name of the hierarchy object."
    name: String!
    "the newest snapshot archived to AWS."
    newestArchivedSnapshot: CdmSnapshot
    "the newest snapshot replicated to a cluster."
    newestReplicatedSnapshot: CdmSnapshot
    "the most recent snapshot of this snappable"
    newestSnapshot: CdmSnapshot
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "the oldest snapshot of this snappable"
    oldestSnapshot: CdmSnapshot
    "the number of on-demand snapshots"
    onDemandSnapshotCount: Int!
    pathExceptions: [String!]!
    pathExcluded: [String!]!
    pathIncluded: [String!]!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The list of snapshots taken for this VM"
    snapshotConnection(
        after: String,
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        first: Int,
        last: Int,
        "sort snapshots by field"
        sortBy: CdmSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): CdmSnapshotConnection
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this VM's snapshots."
    snapshotGroupByConnection(
        after: String,
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        first: Int,
        "group snapshots by field"
        groupBy: CdmSnapshotGroupByEnum!,
        last: Int,
        timezoneOffset: Float = 0.0
    ): cdmSnapshotGroupByConnection
    symlinkResolutionEnabled: Boolean!
}

"List CIDRs for Compute Setting."
type ListCidrsForComputeSetting {
    clusterInterfaceCidrs: [ClusterInfCidrs!]!
}

"List of locations where customer's GCP disks are present"
type ListStoredDiskLocationsReply {
    regions: [String!]!
    zones: [String!]!
}

type LogConfigResult {
    slaLogFrequencyConfig: SlaLogFrequencyConfigResult
}

"""

Supported in v5.2+
"""
type ManagedObjectPendingSlaInfo {
    """

    Supported in v5.2+
    """
    isPendingSlaDomainRetentionLocked: Boolean
    """

    Supported in v5.2+
    Managed ID of the object
    """
    objectId: String!
    """

    Supported in v5.2+
    """
    pendingSlaDomainId: String!
    """

    Supported in v5.2+
    """
    pendingSlaDomainName: String!
}

type Metadata {
    key: String!
    value: Value
}

type MinuteSnapshotSchedule {
    basicSchedule: BasicSnapshotSchedule
}

"The missed snapshot object associated with the vm"
type MissedSnapshotCommon {
    archivalLocationType: [String!]!
    date: DateTime!
}

type MissedSnapshotCommonConnection {
    count: Int!
    edges: [MissedSnapshotCommonEdge!]!
    nodes: [MissedSnapshotCommon!]!
    pageInfo: PageInfo!
}

type MissedSnapshotCommonEdge {
    cursor: String!
    node: MissedSnapshotCommon!
}

"Missed Snapshot data with groupby info applied to it."
type MissedSnapshotGroupBy {
    "The data groupby info."
    groupByInfo: MissedSnapshotGroupByInfo!
    "Paginated missed snapshot data."
    missedSnapshotConnection(
        after: String,
        first: Int,
        "sort snapshots by field"
        sortBy: MissedSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): MissedSnapshotCommonConnection!
    "Further provide groupings for the data."
    missedSnapshotGroupBy(
        "group snapshots by field"
        groupBy: MissedSnapshotGroupByEnum!
    ): [MissedSnapshotGroupBy!]!
}

type MissedSnapshotGroupByConnection {
    count: Int!
    edges: [MissedSnapshotGroupByEdge!]!
    nodes: [MissedSnapshotGroupBy!]!
    pageInfo: PageInfo!
}

type MissedSnapshotGroupByEdge {
    cursor: String!
    node: MissedSnapshotGroupBy!
}

type MonthlySnapshotSchedule {
    basicSchedule: BasicSnapshotSchedule
    dayOfMonth: DayOfMonthEnum!
}

type Mutation {
    "Acknowledges and resets cluster status"
    ackAndResetStatus(
        "Cluster state to be acknowledged and reset"
        AckClusterStatus: AckClusterStatus!,
        "Cluster uuid"
        clusterUuid: UUID!
    ): Boolean!
    activateUser(ids: [String!]!): [String!]!
    "Add ldap config"
    addLdapConfig(adDomain: String!, clusterUuid: String!, ldapName: String!, password: String!, userName: String!): UpdateLdapConfigReply!
    addO365Org(exocomputeClusterId: String!, o365AppTypes: [String!]!, stateToken: String!, tenantId: String!): AddO365OrgResponse!
    "Add policies to objects."
    addPolicyObjects(objectIds: [String!]!, policyIds: [String!]!): String!
    addRoleAssignments(adGroupIds: [String!], roleIds: [String!]!, userIds: [String!]): Boolean!
    addSapHanaSystem(
        "UUID used to identify the cluster the request goes to"
        clusterUuid: String!,
        "Add a SAP HANA system to the Rubrik cluster. Contains parameters like username, list of hosts, password required while adding a SAP HANA system."
        sapHanaSystem: SapHanaSystemConfigInput!
    ): SapHanaAddSystemResponse!
    "Archive a crawl"
    archiveCrawl(crawlId: String!): String!
    assignRetentionSLAToSnappables(
        "Provide optional snappable type under the object for SLA assignment. This is meant to be used only for objects that support multiple snappable hierarchies. This allows an SLA to be set for one/more specific snappable types under the object, instead of applying the SLA for all the snappable types. For example, an AWS account object can potentially have 2 different snappable types under it - AwsNativeEc2Instance and AwsNativeRdsInstance. This field can be set with the appropriate type so that the SLA only gets applied to snappables of the selected type under that account. If the SLA must be applicable for all the snappable types under the object, then this field can be set to `AllSubHierarchyType` or left blank. This field must either be left blank or set to `AllSubHierarchyType` when assigning SLA to a snappable or to an object that does not support multiple snappable types."
        applicableSnappableType: SnappableLevelHierarchyTypeEnum,
        "Corresponds to the assignment type for the global SLA"
        globalSlaAssignType: SlaAssignTypeEnum!,
        "Corresponds to optional global SLA forever UUID in Polaris tables"
        globalSlaOptionalFid: UUID,
        "Provide list of object forever IDS you want to assign Global SLA"
        objectIds: [UUID!]!
    ): SlaAssignResult!
    assignRetentionSLAToSnapshots(
        "Corresponds to the assignment type for the global SLA"
        globalSlaAssignType: SlaAssignTypeEnum!,
        "Corresponds to optional global SLA forever UUID in Polaris tables"
        globalSlaOptionalFid: UUID,
        "List of UUIDs of objects"
        snapshotFids: [UUID!]!
    ): SlaAssignResult!
    assignSla(
        "Provide optional snappable type under the object for SLA assignment. This is meant to be used only for objects that support multiple snappable hierarchies. This allows an SLA to be set for one/more specific snappable types under the object, instead of applying the SLA for all the snappable types. For example, an AWS account object can potentially have 2 different snappable types under it - AwsNativeEc2Instance and AwsNativeRdsInstance. This field can be set with the appropriate type so that the SLA only gets applied to snappables of the selected type under that account. If the SLA must be applicable for all the snappable types under the object, then this field can be set to `AllSubHierarchyType` or left blank. This field must either be left blank or set to `AllSubHierarchyType` when assigning SLA to a snappable or to an object that does not support multiple snappable types."
        applicableSnappableType: SnappableLevelHierarchyTypeEnum,
        "Choose what to do with existing snapshot in case of do not protect slas'"
        existingSnapshotRetention: ExistingSnapshotRetentionEnum,
        "Corresponds to the assignment type for the global SLA"
        globalSlaAssignType: SlaAssignTypeEnum!,
        "Corresponds to optional global SLA forever UUID in Polaris tables"
        globalSlaOptionalFid: UUID,
        "Provide list of object forever IDS you want to assign Global SLA"
        objectIds: [UUID!]!,
        "Boolean value to indicate whether to apply changes made to the SLA to existing snapshots. If not specified, this defaults to true."
        shouldApplyToExistingSnapshots: Boolean
    ): SlaAssignResult!
    "Initiate deletion of cloud account."
    awsCloudAccountDeleteInitiate(
        "Args for initiate aws cloud accounts for deletion."
        awsCloudAccountDeleteInitiateArg: AwsCloudAccountDeleteInitiateInput!,
        "The id of the cloud account"
        cloudAccountUuid: UUID!
    ): AwsCloudAccountDeleteInitiateReply!
    "Process deletion of cloud account."
    awsCloudAccountDeleteProcess(
        "Arguments for processing deletion of cloud accounts."
        awsCloudAccountDeleteProcessArg: AwsCloudAccountDeleteProcessInput!,
        "The id of the cloud account"
        cloudAccountUuid: UUID!
    ): AwsCloudAccountDeleteProcessReply!
    "Initiate create cloud account."
    awsCloudAccountInitiate(
        "Arguments for initiate aws cloud accounts for creation."
        awsCloudAccountInitiateArg: AwsCloudAccountInitiateInput!
    ): AwsCloudAccountInitiate!
    "Process cloud account."
    awsCloudAccountProcess(
        "Arguments for process cloud accounts."
        awsCloudAccountProcessArg: AwsCloudAccountProcessInput!
    ): AwsCloudAccountProcessResponse!
    "Save details for a given cloud account."
    awsCloudAccountSave(
        "Arguments to save cloud account's role arn, stack arn and regions."
        awsCloudAccountSaveArg: AwsCloudAccountSaveInput!,
        "The id of the cloud account"
        cloudAccountUuid: UUID!
    ): AwsCloudAccountSaveResponse!
    "Update features to latest version."
    awsCloudAccountUpdateFeature(
        "The id of the cloud account"
        cloudAccountUuid: UUID!,
        "Cloud Account Features."
        features: [CloudAccountFeatureEnum!]!
    ): AwsCloudAccountUpdateFeatureResponse!
    "Initiate manual update features to latest version."
    awsCloudAccountUpdateFeatureInitiate(
        "The id of the cloud account"
        cloudAccountUuid: UUID!,
        "Cloud Account Features."
        features: [CloudAccountFeatureEnum!]!
    ): AwsCloudAccountUpdateFeatureInitiateResponse!
    "Validate given aws accounts for creation."
    awsCloudAccountValidate(
        "Arguments for validate aws cloud accounts."
        awsCloudAccountValidateArg: AwsCloudAccountValidateInput!
    ): AwsCloudAccountValidateResponse!
    "Validate and initiate given aws accounts for creation."
    awsCloudAccountValidateAndInitiate(
        "Arguments for initiate aws cloud accounts for creation."
        awsCloudAccountInitiateArg: AwsCloudAccountInitiateInput!
    ): AwsCloudAccountValidateAndInitateResponse!
    "Create AWS Exocompute configs."
    awsExocomputeAdd(
        "List of exocompute configs to add."
        awsExocomputeAddRequestsArg: [AwsExocomputeAddConfigInputType!]!,
        "The id of the cloud account"
        cloudAccountUuid: UUID!
    ): AwsExocomputeConfigsCreateResponse!
    "Deletes AWS Exocompute configs."
    awsExocomputeConfigsDelete(
        "List of AWS exocompute config UUIDs."
        awsExocomputeConfigIdsArg: [UUID!]!
    ): AwsExocomputeConfigsDeleteResponse!
    "Add aws account for native protection."
    awsNativeProtectionAccountAdd(
        "Arguments to add account for native protection."
        awsNativeProtectionAccountAddArg: AwsNativeProtectionAccountAddRequest!
    ): AwsNativeProtectionAccountAddResponse!
    "Add the Azure Subscriptions cloud account for given feature."
    azureCloudAccountAdd(
        "Cloud Account Feature."
        feature: CloudAccountFeatureEnum!,
        "List of Azure Regions."
        regions: [AzureCloudAccountRegionEnum!]!,
        "Session ID of the current OAuth session."
        sessionId: String!,
        "List of subscriptions to be added."
        subscriptions: [AzureSubscriptionInput!]!,
        "Domain Name of the Azure tenant."
        tenantDomainName: String!
    ): AzureCloudAccountAddResponse!
    "Delete the Azure Subscriptions cloud account for given feature."
    azureCloudAccountDelete(
        "Cloud Account Feature."
        feature: CloudAccountFeatureEnum!,
        "Session ID of the current OAuth session."
        sessionId: String!,
        "List of subscription Ids."
        subscriptionIds: [UUID!]!
    ): AzureCloudAccountDeleteResponse!
    "Complete the Azure OAuth flow and pass the authorization code."
    azureCloudAccountOAuthComplete(
        "Client ID of the Application. Can be empty if using rubrik app or the custom app is already configured for the tenant."
        appId: String,
        "Client secret key of the Application. Can be empty if using rubrik app or the custom app is already configured for the tenant."
        appSecretKey: String,
        "Authorization code received after the oauth consent flow."
        authorizationCode: String!,
        "Azure cloud type."
        azureCloudType: AzureCloudTypeEnum,
        "Cloud Account Feature."
        feature: CloudAccountFeatureEnum!,
        "Redirect URL used in the oauth flow."
        redirectUrl: String!,
        "Session ID of the current OAuth session."
        sessionId: String!,
        "Whether to skip permission checks of Azure subscriptions required for addition"
        skipPermissionChecks: Boolean!,
        "Domain Name of the Azure tenant."
        tenantDomainName: String!
    ): AzureCloudAccountOAuthCompleteResponse!
    "Initiate a session before doing Azure OAuth flow. Returns clientId of default app if tenant domain name is not specified. Returns clientId of the custom app configured for the tenant, if the custom app is not configured returns the clientId of default app."
    azureCloudAccountOAuthInitiate(
        "Azure cloud type."
        azureCloudType: AzureCloudTypeEnum,
        "Domain Name of the Azure tenant."
        tenantDomainName: String
    ): AzureCloudAccountOAuthInitiateResponse!
    "Update names of the Azure Subscriptions cloud account and regionsfor given feature."
    azureCloudAccountUpdate(
        "Cloud Account Feature."
        feature: CloudAccountFeatureEnum!,
        "Regions to be added for the features."
        regionsToAdd: [AzureCloudAccountRegionEnum!],
        "Regions to be removed for the features."
        regionsToRemove: [AzureCloudAccountRegionEnum!],
        "Subscriptions to update (id and updated name)"
        subscriptions: [AzureCloudAccountSubscriptionInput!]!
    ): AzureCloudAccountUpdateResponse!
    "Update permissions of the Azure Subscriptions cloud account for given feature."
    azureCloudAccountUpgrade(
        "Cloud Account Feature."
        feature: CloudAccountFeatureEnum!,
        "Session ID of the current OAuth session."
        sessionId: String!,
        "List of subscription Ids."
        subscriptionIds: [UUID!]!
    ): AzureCloudAccountUpgradeResponse!
    azureOAuthConsentComplete(AzureAppID: String, AzureAppSecret: String, code: String!, redirectUrl: String!, sessionState: String!, stateToken: String!, tenantId: String!): RequestStatus!
    azureOAuthConsentKickoff: AzureOAuthConsentKickoffResp!
    backupO365Mailbox(mailboxId: UUID!): CreateOnDemandJobReply!
    backupO365Onedrive(onedriveUUID: UUID!): CreateOnDemandJobReply!
    backupO365SharepointDrive(sharepointDriveUUID: UUID!): CreateOnDemandJobReply!
    batchDeassignRoleFromUserGroups(userGroupToRoles: [UserGroupToRolesInput!]!): Boolean!
    blueprintFailback(failbackJobConfig: FailoverAppBlueprintJobInfo!): CreateOnDemandJobReply!
    blueprintFailoverReportGenerate(failoverReportGeneratorJobConfig: BlueprintFailoverReportGeneratorJobInfo!): CreateOnDemandJobReply!
    bulkCreateFilesetTemplates(
        "UUID used to identify the cluster the request goes to"
        clusterUuid: String!,
        "Provide an array containing a separate object for each fileset template definition."
        definitions: [FilesetTemplateCreateInput!]!
    ): FilesetTemplateDetailListResponse!
    bulkCreateFilesets(
        "UUID used to identify the cluster the request goes to"
        clusterUuid: String!,
        "For each fileset, specify a template id along with either host id or share id. If a share id is provided, the host id will be inferred from the host share"
        definitions: [FilesetCreateInput!]!
    ): FilesetDetailListResponse!
    bulkDeleteFilesetTemplates(
        "Provide an array with the ID of each fileset template to remove."
        ids: [String!]!,
        "Flag to indicate whether to convert snapshots of filesets of the deleted templates to relics or to delete them. Applies to all templates being deleted. Default is true."
        preserveSnapshots: Boolean
    ): ResponseSuccess!
    bulkDeleteFilesets(
        "Provide a comma-separated list of fileset IDs."
        ids: [String!]!,
        "Flag to indicate whether to convert snapshots of all deleted filesets to relics or to delete them. Applies to all filesets. Default is true."
        preserveSnapshots: Boolean
    ): ResponseSuccess!
    bulkDeleteHosts(
        "Provide the ID of each host to deregister."
        ids: [String!]!
    ): ResponseSuccess!
    bulkEditFilesetTemplates(
        "Provide an array containing a separate object for each fileset template being modified."
        definitions: [FilesetTemplatePatchInput!]!
    ): FilesetTemplateDetailListResponse!
    bulkEditHosts(
        "Properties to update for each host."
        hostUpdateProperties: [HostUpdateIdInput!]!
    ): InternalBulkUpdateHostResponse!
    bulkRegisterHosts(
        "UUID used to identify the cluster the request goes to"
        clusterUuid: String!,
        "Array containing a registration definition for each host."
        hosts: [HostRegisterInput!]!
    ): HostDetailListResponse!
    cancelActivitySeries(
        "The id of the activity series"
        activitySeriesId: UUID!,
        "The id of the cluster"
        clusterUuid: UUID!
    ): Boolean!
    "Cancels download package job of a cluster"
    cancelDownloadPackage(
        "Cluster uuid"
        clusterUuid: UUID!
    ): CancelJobReply!
    cancelFailoverAppBlueprint(taskchainId: UUID!): Result!
    "Cancels scheduled upgrade job of a cluster"
    cancelScheduledUpgrade(
        "Cluster uuid"
        clusterUuid: UUID!
    ): CancelJobReply!
    cancelTaskchain(taskchainId: String!): RequestStatus!
    cleanupFailback(cleanupJobConfig: CleanupFailoverJobInfo!): CreateOnDemandJobReply!
    cleanupFailover(cleanupJobconfig: CleanupFailoverJobInfo!): CreateOnDemandJobReply!
    "Download files from cloudnative snapshot"
    cloudNativeDownloadFiles(
        "Create the download location"
        createDownloadLoaction: Boolean!,
        "Location where the files would be downloaded"
        downloadLocation: String!,
        "File/Directory(s) to download"
        filePaths: [String!]!,
        "Snapshot UUID"
        snapshotId: UUID!
    ): DownloadFilesReply!
    createAppBlueprint(children: [AppBlueprintChildInput!]!, name: String!, primaryClusterUuid: UUID!): Blueprint!
    createAppBlueprintDownloadSnapshotJobFromCloud(appSnapshotFid: UUID!): Result!
    createAppBlueprintExport(exportJobConfig: AppBlueprintExportSnapshotJobConfig!, fid: UUID!): Result!
    createAppBlueprintInstantRecovery(fid: UUID!, instantRecoveryJobConfig: InstantRecoveryJobConfig): Result!
    createAppBlueprintMount(fid: UUID!, mountJobConfig: AppBlueprintMountSnapshotJobConfig!): Result!
    createAutomaticAwsTargetMapping(automaticAwsTargetMappingCreateRequest: AutomaticAwsTargetMappingCreateRequest!): TargetMapping!
    createAutomaticAzureTargetMapping(automaticAzureTargetMappingCreateRequest: AutomaticAzureTargetMappingCreateRequest!): TargetMapping!
    createAwsAccount(
        "Request arg for creating a new AWS account"
        awsAccountCreateRequest: AwsAccountCreateRequest!
    ): CloudAccount!
    createAwsComputeSetting(
        "Request for creating a new Aws Compute Setting"
        awsComputeSettingsCreateRequest: AwsComputeSettingsCreateRequest!
    ): AwsComputeSettings!
    "Create snapshots of EBS Volumes with given IDs"
    createAwsNativeEbsVolumeSnapshots(
        "List of UUIDs of the EBS Volumes"
        ebsVolumeIds: [UUID!]!,
        retentionSlaId: String
    ): CreateAwsNativeEbsVolumeSnapshotsReply!
    createAwsNativeEc2InstanceSnapshots(ec2InstanceIds: [UUID!]!, retentionSlaId: String): CreateAwsNativeEc2InstanceSnapshotsReply!
    "Create snapshots of RDS Instances with given IDs"
    createAwsNativeRdsInstanceSnapshot(
        "List of UUIDs of the RDS Instances"
        rdsInstanceIds: [UUID!]!
    ): CreateAwsNativeRdsInstanceSnapshotsReply!
    createAwsTarget(
        "Request for creating a new AWS target"
        awsTargetCreateRequest: AwsTargetCreateRequest!
    ): Target!
    createAzureAccount(
        "Request arg for creating a new Azure account"
        azureAccountCreateRequest: AzureAccountCreateRequest!
    ): CloudAccount!
    "Trigger azure native create disk snapshot job for given disk IDs"
    createAzureNativeDiskSnapshots(
        "List of Disk IDs"
        diskIds: [UUID!]!,
        "Retention SLA ID of the on-demand snapshot"
        retentionSlaId: String
    ): CreateAzureNativeDiskSnapshotsReply!
    "Trigger azure native create virtual machine snapshot job for given vm IDs"
    createAzureNativeVirtualMachineSnapshots(
        "Retention SLA ID of the on-demand snapshot"
        retentionSlaId: String,
        "List of Virtual Machine IDs"
        vmIds: [UUID!]!
    ): CreateAzureNativeVirtualMachineSnapshotsReply!
    createAzureTarget(
        "Request for creating a new Azure target"
        azureTargetCreateRequest: AzureTargetCreateRequest!
    ): Target!
    "create a list of blueprint recovery specs with a list of child snappable/snapshot recovery specs"
    createBlueprintRecoverySpec(
        "the fid of the app blueprint"
        appBlueprintId: UUID!,
        "the fid of the app blueprint snapshot"
        appBlueprintSnapshotId: UUID,
        "the blueprint recovery spec parameters to be created"
        blueprintRecoverySpecCreateArg: [AppBlueprintRecoverySpecCreateReqInputType!]!,
        "the recovery type of the recovery spec (AWS_EC2, VMWARE_VM)"
        recoverySpecType: RecoverySpecTypeEnum!
    ): [AppBlueprintRecoverySpecMap!]!
    createBlueprintSnapshot(BaseOnDemandSnapshotConfig: BaseOnDemandSnapshotConfig, fid: UUID!): Result!
    "Create cloud native label rule"
    createCloudNativeLabelRule(
        "cloud native accounts on which tag rule will be applied"
        cloudNativeAccountIds: CloudNativeIDs,
        "Corresponds to optional global SLA forever UUID in Polaris tables"
        globalSlaOptionalFid: UUID,
        "Label key-value pair for label rule"
        label: LabelType!,
        "Type of managed object on which label rule will be applied"
        objectType: CloudNativeLabelObjectType!,
        "Name for the rule"
        ruleName: String!,
        "Corresponds to the assignment type for the SLA"
        ruleSlaAssignType: TagRuleSlaAssignTypeEnum!
    ): CreateCloudNativeLabelRuleReply!
    "Create cloud native tag rule"
    createCloudNativeTagRule(
        "cloud native accounts on which tag rule will be applied"
        cloudNativeAccountIds: CloudNativeIDs,
        "Corresponds to optional global SLA forever UUID in Polaris tables"
        globalSlaOptionalFid: UUID,
        "Type of managed object on which tag rule will be applied"
        objectType: CloudNativeTagObjectType!,
        "Name for the rule"
        ruleName: String!,
        "Corresponds to the assignment type for the SLA"
        ruleSlaAssignType: TagRuleSlaAssignTypeEnum!,
        "Tag key-value pair for tag rule"
        tag: TagType!
    ): CreateCloudNativeTagRuleReply!
    "Create a new custom analyzer"
    createCustomAnalyzer(analyzer: AnalyzerInput!): Analyzer!
    createCustomReport(config: CustomReportCreate!): CustomReport!
    createFilesetSnapshot(
        "Configuration for the on-demand backup."
        config: BaseOnDemandSnapshotConfigInput!,
        "ID of the Fileset"
        id: String!
    ): AsyncRequestStatus!
    createGlobalSla(globalSlaCreateRequest: GlobalSlaCreateRequest!): GlobalSla!
    createManualTargetMapping(manualTargetMappingCreateRequest: ManualTargetMappingCreateRequest!): TargetMapping!
    createNfsTarget(
        "Request for creating a new NFS target"
        nfsTargetCreateRequest: NfsTargetCreateRequest!
    ): Target!
    createO365AppComplete(o365AppClientId: String!, stateToken: String!, tenantId: String!): RequestStatus!
    createO365AppKickoff(o365AppType: String!, o365SubscriptionName: String!): CreateO365AppKickoffResp!
    createOrg(name: String!): UUID!
    "Create a classification policy"
    createPolicy(policy: ClassificationPolicyInput!): ClassificationPolicyDetail!
    createReport(reportConfig: ReportConfigInput!): Int!
    createRole(description: String!, name: String!, permissions: [PermissionInput!]!): UUID!
    createSapHanaDatabaseSnapshot(
        "Configuration for the on demand backup."
        config: BaseOnDemandSnapshotConfigInput!,
        "ID of the Fileset"
        id: String!
    ): AsyncRequestStatus!
    createScheduledReport(scheduledReport: ScheduledReportCreate!): ScheduledReport!
    createUser(email: String!, roleIds: [String!]!): String!
    "Deactivate a custom analyzer"
    deactivateCustomAnalyzer(analyzerId: String!): String!
    "Deactivate a classification policy"
    deactivatePolicy(policyId: String!, runAsync: Boolean!): [String!]!
    deactivateUser(ids: [String!]!): [String!]!
    "Delete account settings value."
    deleteAccountSettingValue(
        "Name of component that uses ASP in account setting table"
        aspComponent: ComponentEnum!,
        "Name of parameter (ASP) in account setting table"
        aspName: String!
    ): Boolean!
    deleteAppBlueprint(fid: UUID!): Boolean!
    deleteAppBlueprintSnapshot(fid: UUID!, location: String!): Result!
    deleteAppBlueprintSnapshots(fid: UUID!): Result!
    deleteAwsComputeSetting(
        "Id of aws compute setting."
        awsComputeSettingId: UUID!
    ): DeleteAwsCloudComputeSettingReply!
    deleteAwsNativeAccount(awsNativeAccountId: UUID!, awsNativeProtectionFeature: AwsNativeProtectionFeatureEnum!, deleteNativeSnapshots: Boolean!): DeleteAwsNativeAccountReply!
    "Deletes an azure subscription."
    deleteAzureNativeSubscription(
        "If the snapshots on Azure should be deleted along with the subscription."
        shouldDeleteNativeSnapshots: Boolean!,
        "Subscription ID"
        subscriptionId: UUID!
    ): DeleteSubscriptionReply!
    "Delete cloud native label rule"
    deleteCloudNativeLabelRule(
        "UUID for the tag or label rule"
        ruleId: UUID!
    ): String!
    "Delete cloud native tag rule"
    deleteCloudNativeTagRule(
        "UUID for the tag or label rule"
        ruleId: UUID!
    ): String!
    deleteCustomReport(id: Int!): Int!
    deleteEventDigest(recipientUserIDs: [String!]!): Boolean!
    deleteFilesetSnapshots(
        "ID of the fileset."
        id: String!
    ): ResponseSuccess!
    deleteGlobalSla(
        "Corresponds to global SLA forever UUID in Polaris tables"
        globalSlaFid: UUID!
    ): SlaResult!
    deleteIdentityProvider: IdentityProvider!
    deleteLdapPrincipals(principalIds: [String!]!): Boolean!
    deleteO365AzureApp(o365AppClientId: String!, o365AppType: String!): RequestStatus!
    deleteO365Org(orgId: UUID!): CreateOnDemandJobReply!
    deleteO365ServiceAccount(orgId: UUID!): RequestStatus!
    "Deletes the polaris on-demand snapshot by id"
    deletePolarisSnapshot(
        "Corresponds to snapshot forever UUID in Polaris tables"
        snapshotFid: UUID!
    ): Boolean!
    "delete the recovery specs with the given app blueprint"
    deleteRecoverySpec(
        "the fid of the app blueprint"
        appBlueprintId: UUID!,
        "the fid of the app blueprint snapshot"
        appBlueprintSnapshotId: UUID
    ): DeleteBlueprintRecoverySpecReply!
    deleteReport(reportID: Int!): Boolean!
    deleteRole(roleId: String!): Boolean!
    "Delete SMTP configuration value."
    deleteSMTPConfiguration: Boolean!
    deleteSapHanaDatabaseSnapshot(
        "ID assigned to a SAP HANA database full snapshot."
        id: String!
    ): ResponseSuccess!
    deleteSapHanaSystem(
        "The ID of the SAP HANA system."
        id: String!
    ): AsyncRequestStatus!
    deleteScheduledReport(id: Int!): Int!
    deleteSnapshotsOfUnmanagedObjects(
        "List of UUIDs of objects"
        objectIds: [UUID!]!
    ): RequestSuccess!
    deleteTarget(
        "Corresponds to ID of target in Polaris"
        targetId: UUID!
    ): TargetDeleteResult!
    deleteTargetMapping(targetMappingDeleteRequest: TargetMappingDeleteRequest!): TargetMappingDeletionResult!
    deleteUnmanagedSnapshots(
        "List of UUIDs of snapshots"
        snapshotIds: [UUID!]!
    ): RequestSuccess!
    deleteUsersFromAccount(ids: [String!]!): Boolean!
    downloadFilesetSnapshot(
        "ID of snapshot"
        id: String!
    ): AsyncRequestStatus!
    "Download file results csv"
    downloadResultsCsv(crawlId: String!, downloadFilter: DownloadResultsCsvFiltersInput): DownloadResultsCsvReply!
    "Download snapshot policy results csv"
    downloadSnapshotResultsCsv(downloadFilter: DownloadResultsCsvFiltersInput, snappableFid: String!, snapshotFid: String!): DownloadSnapshotResultsCsvReply!
    editAutomaticAwsTargetMapping(automaticAwsTargetMappingEditRequest: AutomaticAwsTargetMappingEditRequest!): TargetMapping!
    editAutomaticAzureTargetMapping(automaticAzureTargetMappingEditRequest: AutomaticAzureTargetMappingEditRequest!): TargetMapping!
    editAwsAccount(
        "Request for editing an existing AWS account"
        awsAccountEditRequest: AwsAccountEditRequest!
    ): CloudAccount!
    editAwsTarget(
        "Request for updating an existing AWS target"
        awsTargetEditRequest: AwsTargetEditRequest!
    ): Target!
    editAzureAccount(
        "Request for editing an existing Azure account"
        azureAccountEditRequest: AzureAccountEditRequest!
    ): CloudAccount!
    editAzureTarget(
        "Request for updating an existing Azure target"
        azureTargetEditRequest: AzureTargetEditRequest!
    ): Target!
    editClusterLocation(
        clusterLocation: ClusterLocationEdit!,
        "The id of the cluster"
        clusterUuid: UUID!
    ): Cluster!
    editCustomReport(config: CustomReportCreate!, id: Int!): CustomReport!
    editGlobalSla(globalSlaEditRequest: GlobalSlaEditRequest!): GlobalSla!
    editManualTargetMapping(manualTargetMappingEditRequest: ManualTargetMappingEditRequest!): TargetMapping!
    editNfsTarget(
        "Request for updating an existing NFS target"
        nfsTargetEditRequest: NfsTargetEditRequest!
    ): Target!
    editSapHanaSystem(
        "The ID of the SAP HANA system."
        id: String!,
        "An object that contains the updated SLA Domain ID for the SAP HANA system."
        updateProperties: SapHanaSystemPatchInput!
    ): SapHanaPatchSystemResponse!
    editScheduledReport(id: Int!, scheduledReport: ScheduledReportCreate!): ScheduledReport!
    "Enable/disable auto fmd upload on given cluster"
    enableAutomaticFmdUpload(
        "The id of the cluster"
        clusterUuid: UUID!,
        "enable or disable lambda service"
        enabled: Boolean!
    ): EnableAutomaticFmdUploadReply!
    "Enable/disable lambda service for given snappable on given cluster"
    enableLambdaForSnappable(
        "enable or disable diff fmd upload"
        enableDiffFmd: Boolean!,
        "enable or disable full fmd upload"
        enableFullFmd: Boolean!,
        "the fid of the snappable"
        snappableId: UUID!
    ): EnableLambdaForSnappableReply!
    excludeDisksFromSnapshot(
        "Mapping from disk ID to excluded flag"
        diskIdToIsExcluded: [DiskIdToIsExcluded!]!,
        "Virtual Machine ID"
        vmId: UUID!
    ): String!
    excludeVolumesFromSnapshot(ec2InstanceId: UUID!, volumeIdsToIsExcluded: [VolumeIdToIsExcluded!]!): String!
    exportAwsNativeEbsVolumeSnapshot(
        availabilityZone: String!,
        "Target AWS account ID for the EC2 instance snapshot export"
        destinationAwsNativeAccountId: UUID!,
        destinationRegionNativeId: AwsNativeRegionEnum!,
        iops: Int!,
        kmsKeyId: String,
        replaceAttached: Boolean!,
        shouldCopyTags: Boolean!,
        "UUID of the snapshot"
        snapshotId: String!,
        "Specifies if the volume should be exported using the replica"
        useReplica: Boolean!,
        volumeName: String!,
        volumeSize: Int!,
        volumeType: AwsNativeEbsVolumeTypeEnum!
    ): ExportEbsVolumeSnapshotReply!
    "Trigger azure native export disk job for given snapshot"
    exportAzureNativeDisk(
        "Availability Zone in which to export the disk, empty for regions types which do not support availability zones"
        destinationAvailabilityZone: String,
        "Region in which to export the disk"
        destinationRegionName: AzureNativeRegionEnum!,
        "Subscription ID in which to export the disk. If it is empty it means disk is being exported to same subscription"
        destinationSubscriptionId: UUID,
        "Name of the exported disk"
        diskName: String!,
        "Size of the exported disk in GiB"
        diskSize: Int!,
        "Type of the exported disk"
        diskStorageTier: AzureNativeManagedDiskTypeEnum!,
        "Whether to only run export job or export and replace job"
        replaceAttached: Boolean!,
        "Name of the resource group to be associated with exported disk"
        resourceGroupName: String!,
        "Whether to export tags from the snapshot"
        shouldExportTags: Boolean!,
        "Snapshot ID"
        snapshotId: UUID!,
        "Whether to recover from replica of source snapshot or not."
        useReplica: Boolean
    ): ExportDiskSnapshotReply!
    "Trigger azure native export virtual machine job for given snapshot"
    exportAzureNativeVirtualMachine(
        "Availability Zone in which to export the virtual machine, empty for regions/virtual machine types which do not support availability zones"
        destinationAvailabilityZone: String,
        "Region in which to export the virtual machine"
        destinationRegionName: AzureNativeRegionEnum!,
        "Subscription ID in which to export the virtual machine. If it is empty it means disk is being exported to same subscription"
        destinationSubscriptionId: UUID,
        "Azure ID of the network security group to be attached to the exported virtual machine. If specified, it must be in the destination region"
        networkSecurityGroupNativeId: String,
        "Name of the resource group to be associated with exported virtual machine"
        resourceGroupName: String!,
        "Whether to export tags from the snapshot"
        shouldExportTags: Boolean!,
        "Whether to power off the virtual machine after exporting"
        shouldPowerOff: Boolean!,
        "Snapshot ID"
        snapshotId: UUID!,
        "Azure ID of the subnet in which to launch the virtual machine. It must be in the destination region"
        subnetNativeId: String!,
        "Whether to recover from replica of source snapshot or not."
        useReplica: Boolean,
        "Name of the exported virtual machine"
        vmName: String!,
        "Size of the exported virtual machine"
        vmSize: String!
    ): ExportVMReply!
    exportEc2InstanceSnapshot(
        copyTags: Boolean!,
        "Target AWS account ID for the EC2 instance snapshot export"
        destinationAwsNativeAccountId: UUID!,
        destinationRegionId: AwsNativeRegionEnum!,
        instanceName: String!,
        instanceType: AwsNativeEc2InstanceTypeEnum!,
        kmsKeyId: String,
        securityGroupIds: [String!]!,
        "UUID of the snapshot"
        snapshotId: String!,
        "Name of the key pair for the exported instance"
        sshKeyPairName: String,
        subnetId: String!,
        "Specifies if the instance should be exported using the replica"
        useReplica: Boolean!
    ): ExportEc2InstanceSnapshotReply!
    exportO365Mailbox(exportConfig: ExportO365MailboxInput!): CreateOnDemandJobReply!
    "Export of RDS Instance with given identifier"
    exportRdsInstance(
        "DB class of the exported RDS DB instance."
        dbClass: AwsNativeRdsDbInstanceClassEnum!,
        "Name of the exported RDS DB instance."
        dbInstanceName: String!,
        "Region in which the exported RDS DB instance will be launched."
        destinationRegionNativeId: AwsNativeRegionEnum!,
        "Export timestamp for PiTR of the instance."
        exportTime: DateTime,
        "IOPs of the exported RDS DB instance."
        iops: Int,
        "Whether the exported RDS DB instance is multi-AZ or not."
        isMultiAz: Boolean!,
        "Whether the export of the instance is manual or point-in-time."
        isPointInTime: Boolean!,
        "Whether the new RDS instance must be launched in a powered-off state."
        isPoweredOff: Boolean!,
        "Whether the new RDS instance is publicly accessible or not."
        isPubliclyAccessible: Boolean!,
        "KMS Key ID of the exported RDS DB instance."
        kmsKeyId: String,
        "Port on which the exported RDS DB instance accepts connections."
        port: Long!,
        "AZ in which the exported RDS DB instance must be launched."
        primaryAz: String,
        "ID of the RDS instance to be exported."
        rdsInstanceId: UUID!,
        "List of security group IDs for the new RDS instance."
        securityGroupIds: [String!],
        "Whether the option group of the source region must be copied to the destination region, and associated with the exported RDS DB Instance."
        shouldCopyOptionGroup: Boolean!,
        "Whether the parameter group associated with the source RDS instance must be copied to the destination region, and associated with the exported RDS DB instance."
        shouldCopyParameterGroup: Boolean!,
        "Whether tags will be exported to the new RDS instance."
        shouldExportTags: Boolean!,
        "UUID of the snapshot if the export is manual."
        snapshotId: String,
        "Name of the option group selected by the user for the new RDS instance."
        sourceOptionGroupName: String,
        "Name of the DB parameter group selected by the user for the new RDS instance."
        sourceParameterGroupName: String,
        "Storage type of the exported RDS DB instance."
        storageType: AwsNativeRdsStorageTypeEnum,
        "Name of the subnet group for the new RDS instance."
        subnetGroupName: String,
        "List of subnet IDs for the newly created subnet group, which will be associated with the exported RDS DB instance."
        subnetIds: [String!]
    ): ExportRdsInstanceReply!
    failoverAppBlueprint(jobconfig: FailoverAppBlueprintJobInfo!): CreateOnDemandJobReply!
    filesetAddHost(
        "host name"
        hostName: String!,
        snappableFid: UUID!
    ): RequestSuccess!
    filesetDownloadSnapshotFiles(
        "Configuration information for a job to download files and folders from a fileset backup."
        config: FilesetDownloadFilesJobConfigInput!,
        deltaTypeFilter: [DeltaTypeEnum!],
        "ID assigned to a fileset backup object."
        id: String!,
        nextSnapshotFid: UUID
    ): AsyncRequestStatus!
    filesetExportSnapshotFiles(
        "The configuration of a job that exports one or more files or folders from a fileset backup."
        config: FilesetExportFilesJobConfigInput!,
        deltaTypeFilter: [DeltaTypeEnum!],
        "ID of snapshot"
        id: String!,
        nextSnapshotFid: UUID,
        "os type"
        osType: GuestOsTypeEnum!,
        "share type"
        shareType: ShareTypeEnum! = NoShareType
    ): AsyncRequestStatus!
    filesetRecoverFiles(
        "Configuration for job to restore one or more files or folders from a fileset backup."
        config: FilesetRestoreFilesJobConfigInput!,
        deltaTypeFilter: [DeltaTypeEnum!],
        nextSnapshotFid: UUID,
        "os type"
        osType: GuestOsTypeEnum!,
        "List of restore path pairs"
        restorePathPairList: [OldRestorePathPairInput!]!,
        "share type"
        shareType: ShareTypeEnum! = NoShareType,
        "Corresponds to snapshot forever UUID in Polaris tables"
        snapshotFid: UUID!
    ): AsyncRequestStatus!
    "Add cloud account for Gcp Projects for the given features."
    gcpCloudAccountAddProjects(
        "List of cloud account project native Ids."
        cloudAccountsProjectIds: [String!]!,
        "List of Gcp project native Ids to be added for native protection."
        nativeProtectionProjectIds: [String!]!,
        "Session ID of the current OAuth session."
        sessionId: String!,
        "List of Gcp shared VPC host project native Ids."
        sharedVpcHostProjectIds: [String!]!
    ): GcpCloudAccountAddProjectsResponse!
    "Delete cloud account for the given Gcp Project UUIDs and feature."
    gcpCloudAccountDeleteProjects(
        "List of cloud account project native Uuids."
        cloudAccountsProjectUuids: [UUID!]!,
        "List of Gcp project native Uuids to be added for native protection."
        nativeProtectionProjectUuids: [UUID!]!,
        "Session ID of the current OAuth session."
        sessionId: String!,
        "List of Gcp shared VPC host project native Uuids."
        sharedVpcHostProjectUuids: [UUID!]!
    ): [GcpCloudAccountProjectDeleteStatus!]!
    "Complete the OAuth flow and pass the authorization code."
    gcpCloudAccountOAuthComplete(
        "Authorization code received after the oauth consent flow."
        authorizationCode: String!,
        "Redirect URL used in the oauth flow."
        redirectUrl: String!,
        "Session ID of the current OAuth session."
        sessionId: String!
    ): GcpCloudAccountOAuthCompleteResponse!
    "Initiate a session before doing Gcp OAuth flow."
    gcpCloudAccountOAuthInitiate(
        "Customer Url."
        customerUrl: String!
    ): GcpCloudAccountOAuthInitiateResponse!
    "Upgrade cloud account for the given Gcp Project UUIDs and feature."
    gcpCloudAccountUpgradeProjects(
        "Cloud Account Feature."
        feature: CloudAccountFeatureEnum!,
        "List of Gcp project UUIDs."
        projectUuids: [UUID!]!,
        "Session ID of the current OAuth session."
        sessionId: String!
    ): [GcpCloudAccountProjectUpgradeStatus!]!
    "Triggers GCPNative disable project job for the given project ID"
    gcpNativeDisableProject(
        "UUID of the Project"
        projectId: UUID!,
        "Whether to delete the native snapshots while disabling the project"
        shouldDeleteNativeSnapshots: Boolean!
    ): DisableProjectReply!
    gcpNativeExcludeDisksFromInstanceSnapshot(
        "Mapping from disk ID to excluded flag"
        diskIdToIsExcluded: [DiskIdToIsExcluded!]!,
        "GCP GCE instance ID"
        instanceId: UUID!
    ): String!
    "Trigger GCP native export disk job for the given disk snapshot"
    gcpNativeExportDisk(
        "Encryption type for created disk(s)"
        diskEncryptionType: DiskEncryptionType!,
        "Customer managed Key to encrypt created disk, applicable when encryption type is CustomerManagedKey"
        kmsCryptoKey: kmsCryptoKey,
        "Customer managed Key to encrypt created disk, applicable when encryption type is CustomerManagedKeyResourceId"
        kmsCryptoKeyResourceId: String,
        "Whether the exported disk should replace source disk from attached instance"
        replaceAttached: Boolean!,
        "The zones where the regional exported disk should be replicated"
        replicaZones: [String!],
        "Whether to allow Rubrik labels on Rubrik created/manipulated resources"
        shouldAddRubrikLabels: Boolean!,
        "The labels will be copied to the Rubrik created/manipulated resource from the source resource that were there at the time of taking the snapshot"
        shouldCopyLabels: Boolean!,
        "UUID of snapshot"
        snapshotId: UUID!,
        "The disk name of the to-be-created disk."
        targetDiskName: String!,
        "Size of the exported disk in GB"
        targetDiskSizeGb: Int!,
        "The disk type of the to-be-created disk."
        targetDiskType: String!,
        "The region of the to-be-created disk."
        targetRegion: String!,
        "The zone of the to-be-created disk."
        targetZone: String
    ): ExportDiskReply!
    "Trigger GCP native export instance job for the given instance snapshot"
    gcpNativeExportGceInstance(
        "Encryption type for created disk(s)"
        diskEncryptionType: DiskEncryptionType!,
        "Customer managed Key to encrypt created disk, applicable when encryption type is CustomerManagedKey"
        kmsCryptoKey: kmsCryptoKey,
        "Customer managed Key to encrypt created disk, applicable when encryption type is CustomerManagedKeyResourceId"
        kmsCryptoKeyResourceId: String,
        "Native ID of the shared VPC host project for the current service project"
        sharedVPCHostProjectNativeID: String,
        "Whether to allow Rubrik labels on Rubrik created/manipulated resources"
        shouldAddRubrikLabels: Boolean!,
        "The labels will be copied to the Rubrik created/manipulated resource from the source resource that were there at the time of taking the snapshot"
        shouldCopyLabels: Boolean!,
        "The to-be-created instance will be created in a powered-off state"
        shouldPowerOff: Boolean!,
        "UUID of snapshot"
        snapshotId: UUID!,
        "The instance name of the to-be-created instance."
        targetInstanceName: String!,
        "The machine type of the to-be-created instance."
        targetMachineType: String!,
        "The network tags of the to-be-created instance."
        targetNetworkTags: [String!],
        "The subnet name of the to-be-created instance."
        targetSubnetName: String!,
        "The zone of the to-be-created instance."
        targetZone: String!
    ): ExportGCEInstanceReply!
    "Trigger GCP native refresh project job for the given project IDs"
    gcpNativeRefreshProjects(
        "List of Project IDs"
        projectIds: [UUID!]!
    ): RefreshGCPNativeProjectsReply!
    "Triggers GCPNative restore instance job for the given snapshot ID"
    gcpNativeRestoreGceInstance(
        "Whether to allow Rubrik labels on Rubrik created/manipulated resources"
        shouldAddRubrikLabels: Boolean!,
        "Whether to restore labels of the instance from snapshot"
        shouldRestoreLabels: Boolean!,
        "Whether the restored instance should be started"
        shouldStartRestoredInstance: Boolean!,
        "UUID of snapshot"
        snapshotId: UUID!
    ): RestoreGCEInstanceReply!
    insertCustomerO365App(o365AppClientId: String!, o365AppClientSecret: String!, o365AppType: String!, o365SubscriptionName: String!): RequestStatus!
    "List CIDRs for compute setting."
    listCidrsForComputeSetting(
        "Optional List of Cluster UUIDs."
        clusterIdsArg: [UUID!]
    ): ListCidrsForComputeSetting!
    "Login to Rubrik support portal using username and password"
    loginToRubrikSupportPortal(
        "Support portal hostname"
        hostname: String! = "rubrik.force.com",
        "Support portal organization ID"
        organizationId: String! = "00D40000000N3x2",
        "Support portal password to login"
        password: String!,
        "Support portal username to login"
        username: String!
    ): SupportPortalLoginReply!
    "Logout from Rubrik support portal using username"
    logoutFromRubrikSupportPortal: SupportPortalLogoutReply!
    "Mutate LDAP Integration"
    mutateLdapIntegration(
        "BaseDn for your LDAP integration"
        baseDn: String,
        "BindUserName for your LDAP integration"
        bindUserName: String!,
        "BindUserPassword for your LDAP integration"
        bindUserPassword: String!,
        "dynamic dns name for your LDAP integration"
        dynamicDnsName: String,
        "group member attribute for your LDAP integration"
        groupMemberAttr: String,
        "group membership attribute for your LDAP integration"
        groupMembershipAttr: String,
        "group search filter for your LDAP integration"
        groupSearchFilter: String,
        "ID for your LDAP integration"
        id: UUID,
        "LdapServers for your LDAP integration"
        ldapServers: [LdapServerInput!],
        "Name for your LDAP integration"
        name: String!,
        "TrustedCerts for your LDAP integration"
        trustedCerts: String,
        "user name attribute for your LDAP integration"
        userNameAttr: String,
        "user search filter for your LDAP integration"
        userSearchFilter: String
    ): String!
    mutateRole(description: String!, name: String!, permissions: [PermissionInput!]!, protectableClusters: [String!]!, roleId: String): UUID!
    o365SetupKickoff: O365SetupKickoffResp!
    "Open a support tunnel in cluster"
    openSupportTunnel(
        "Cluster uuid"
        clusterUuid: UUID!,
        "Close existing tunnel if any, before attempting to open the tunnel"
        force: Boolean! = false,
        "Activity timeout of support tunnel"
        timeout: Int! = 0
    ): OpenSupportTunnelReply!
    pauseTarget(
        "Corresponds to ID of target in Polaris"
        targetId: UUID!
    ): TargetPauseResult!
    refreshAwsNativeAccounts(awsNativeAccountIds: [UUID!]!, awsNativeProtectionFeatures: [AwsNativeProtectionFeatureEnum!]!): RefreshAwsAccountsReply!
    "Trigger Refresh for AWS Accounts"
    refreshAwsSources(
        "AWS Sources to Refresh"
        awsSourceIds: [UUID!]!
    ): RefreshAwsSourcesReply!
    "Trigger azure native refresh subscription job for the given subscription IDs"
    refreshAzureNativeSubscriptions(
        "List of Subscription IDs"
        subscriptionIds: [UUID!]!
    ): RefreshAzureNativeSubscriptionsReply!
    refreshHost(
        "ID assigned to a host object."
        id: String!
    ): HostDetail!
    refreshO365Org(orgId: UUID!): CreateOnDemandJobReply!
    refreshSapHanaSystem(
        "The ID of the SAP HANA system."
        id: String!
    ): AsyncRequestStatus!
    "Remove LDAP Integration"
    removeLdapIntegration(
        "ID for your LDAP integration"
        id: UUID!
    ): Boolean!
    "Remove policies from objects."
    removePolicyObjects(objectIds: [String!]!, policyIds: [String!]!, runAsync: Boolean!): [String!]!
    restoreAwsNativeEc2InstanceSnapshot(
        shouldPowerOn: Boolean!,
        shouldRestoreTags: Boolean!,
        "UUID of the snapshot"
        snapshotId: String!
    ): RestoreEc2InstanceSnapshotReply!
    "Trigger azure native restore virtual machine job for given snapshot"
    restoreAzureNativeVirtualMachine(
        "Whether to power on virtual machine after restoring"
        shouldPowerOn: Boolean!,
        "Whether to restore tags from the snapshot"
        shouldRestoreTags: Boolean!,
        "Snapshot ID"
        snapshotId: UUID!
    ): RestoreVMReply!
    restoreO365Mailbox(restoreConfig: RestoreO365MailboxInput!): CreateOnDemandJobReply!
    restoreO365Onedrive(destOnedriveUUID: UUID!, filesToRestore: [FileInfo!]!, foldersToRestore: [FolderInfo!]!, restoreFolderPath: String!, sourceOnedriveUUID: UUID!): CreateOnDemandJobReply!
    restoreO365SharepointDrive(destSharepointDriveUUID: UUID!, filesToRestore: [FileInfo!]!, foldersToRestore: [FolderInfo!]!, restoreFolderPath: String!, sourceSharepointDriveUUID: UUID!): CreateOnDemandJobReply!
    resumeTarget(
        "Corresponds to ID of target in Polaris"
        targetId: UUID!
    ): TargetResumeResult!
    "Resumes previously failed upgrade"
    resumeUpgrade(
        "Cluster uuid"
        clusterUuid: UUID!,
        "Context Tag"
        context_tag: String = "{\"client\": \"polaris\"}"
    ): StartUpgradeReply!
    "Rolls back the cluster to starting version of previously failed upgrade"
    rollbackUpgrade(
        "Cluster uuid"
        clusterUuid: UUID!,
        "Context Tag"
        context_tag: String = "{\"client\": \"polaris\"}"
    ): StartUpgradeReply!
    runCustomAnalyzer(runCustomAnalyzerRequest: RunCustomAnalyzerInput!): RunCustomAnalyzerReply!
    saveEventDigest(eventDigestConfig: EventDigestConfig!, frequency: Int, includeAudits: Boolean, includeEvents: Boolean, isImmediate: Boolean, name: String, recipientUserIDs: [String!]!): [EventDigest!]!
    "Schedule an upgrade job in batch"
    scheduleUpgradeBatchJob(
        "Upgrade action"
        action: ActionEnum!,
        "Context Tag"
        context_tag: String = "{\"client\": \"polaris\"}",
        "List of cluster uuids"
        listClusterUuid: [UUID!]!,
        "Upgrade mode"
        mode: String!,
        "ISO8601 Timestamp string"
        scheduleAt: DateTime!,
        "CDM upgrade tarball version"
        version: String!
    ): [UpgradeJobReplyWithUuid!]!
    "Schedule an upgrade job"
    scheduleUpgradeJob(
        "Upgrade action"
        action: ActionEnum!,
        "Cluster uuid"
        clusterUuid: UUID!,
        "Context Tag"
        context_tag: String = "{\"client\": \"polaris\"}",
        "Upgrade mode"
        mode: String!,
        "ISO8601 Timestamp string"
        scheduleAt: DateTime!,
        "CDM upgrade tarball version"
        version: String!
    ): UpgradeJobReply!
    "Seed account with enabled policies."
    seedEnabledPolicies: SeedEnabledPoliciesReply!
    "DEPRECATED (use seedEnabledPolicies instead) Seed account with initial policies."
    seedInitialPolicies: SeedInitialPoliciesReply!
    sendScheduledReport(id: Int!, recipients: [String!]!): Boolean!
    setIdentityProvider(
        "Entity id of your IdP"
        entityId: String!,
        "Sign-in URL id of your IdP"
        signInUrl: String!,
        "Signing certificate of your IdP"
        signingCertificate: String!
    ): IdentityProvider!
    setIpWhitelistEnabled(enabled: Boolean!): Boolean!
    setO365ServiceAccount(appPassword: String!, orgId: UUID!, username: String!): RequestStatus!
    setSMTPConfiguration(
        "Email to use as from for your SMTP configuration"
        defaultFromEmail: String!,
        "Host name for your SMTP configuration"
        hostName: String!,
        "Password for your SMTP configuration"
        password: String!,
        "Port number for your SMTP configuration"
        port: Int!,
        "Security type to use "
        securityType: SMTPSecurityTypeEnum!,
        "Trusted certificate to use for your SMTP configuration"
        trustedCerts: String!,
        "User name for your SMTP configuration"
        userName: String!
    ): Boolean!
    setupAzureO365Exocompute(exocomputeConfig: AzureO365ExocomputeConfig!, subscriptionId: UUID!, tenantId: String!): SetupAzureO365ExocomputeResp!
    "Start a crawl"
    startCrawl(analyzerGroups: [AnalyzerGroupInput!]!, extWhiteList: [String!], name: String!, resources: [ResourceInput!]!): StartCrawlReply!
    "Starts CDM job to download installer package in batch"
    startDownloadPackageBatchJob(
        "CDM download package version"
        downloadVersion: String,
        "List of cluster uuids"
        listClusterUuid: [UUID!]!,
        "MD5CheckSum of CDM installer package"
        md5checksum: String!,
        "CDM upgrade package URL"
        packageUrl: String!,
        "Size, in bytes of CDM package"
        size: Long
    ): [DownloadPackageReplyWithUuid!]!
    "Starts CDM job to download installer package"
    startDownloadPackageJob(
        "Cluster uuid"
        clusterUuid: UUID!,
        "CDM download package version"
        downloadVersion: String,
        "MD5CheckSum of CDM installer package"
        md5checksum: String!,
        "CDM upgrade package URL"
        packageUrl: String!,
        "Size, in bytes of CDM package"
        size: Long
    ): DownloadPackageReply!
    "Start Datagov NAS audit"
    startNasAudit(accountId: String!, auditTargetType: DataGovAuditTargetTypeEnum!, clusterUuid: String!, hostId: String!, shareName: String!): StartNasAuditReply!
    "Starts an on demand periodic upgrade prechecks job in CDM cluster"
    startPeriodicUpgradePrechecksOnDemandJob(
        "Cluster uuid"
        clusterUuid: UUID!
    ): PrechecksJobReply!
    "Start Sonar audit"
    startSonarAudit(accountId: String!, auditObjectInfo: [AuditObjectInfo!]!): StartSonarAuditReply!
    "Starts the upgrade with given tarball path"
    startUpgrade(
        "Cluster uuid"
        clusterUuid: UUID!,
        "Context Tag"
        context_tag: String = "{\"client\": \"polaris\"}",
        "Upgrade mode"
        mode: String!,
        "CDM upgrade tarball version"
        version: String!
    ): StartUpgradeReply!
    "Starts cdm upgrades instantly, monitors the upgrade until terminal state is reached"
    startUpgradeBatchJob(
        "Upgrade action"
        action: ActionEnum!,
        "Context Tag"
        context_tag: String = "{\"client\": \"polaris\"}",
        "List of cluster uuids"
        listClusterUuid: [UUID!]!,
        "Upgrade mode"
        mode: String!,
        "CDM upgrade tarball version"
        version: String!
    ): [UpgradeJobReplyWithUuid!]!
    "Starts cdm upgrade instantly, monitors the upgrade until terminal state is reached"
    startUpgradeJob(
        "Upgrade action"
        action: ActionEnum!,
        "Cluster uuid"
        clusterUuid: UUID!,
        "Context Tag"
        context_tag: String = "{\"client\": \"polaris\"}",
        "Upgrade mode"
        mode: String!,
        "CDM upgrade tarball version"
        version: String!
    ): UpgradeJobReply!
    "Stop Datagov NAS audit"
    stopNasAudit(accountId: String!, datagovAuditCfgId: String!): StopNasAuditReply!
    "Stop Sonar audit"
    stopSonarAudit(accountId: String!, datagovAuditCfgId: String!): StopSonarAuditReply!
    "Triggers on-demand snapshot for the given Snappables."
    takeOnDemandSnapshot(
        "The SLA ID."
        slaId: String!,
        "List of Snappable IDs"
        snappableIds: [UUID!]!
    ): TakeOnDemandSnapshotReply!
    toggleFeatureEnabled(enableFeature: Boolean!, featureName: FeatureNameEnum!): Boolean!
    toggleVMwareManagementEnabled(enableVmwareManagement: Boolean!): Boolean!
    "Trigger detect ransomware job for given snapshot"
    triggerRansomwareDetection(
        "The id of the cluster"
        clusterUuid: UUID!,
        "Snappable managed ID"
        managedId: String!,
        "Corresponds to previous snapshot ID of the target snapshot"
        previousSnapshotId: String!,
        "Corresponds to snapshot ID in CDM tables"
        snapshotId: String!
    ): TriggerRansomwareDetectionReply!
    updateAccountOwner(userId: String!): Boolean!
    "This endpoint is deprecated."
    updateAccountSettings(
        "Flag to represent if email notification is enabled"
        isEmailNotificationEnabled: Boolean,
        "Flag to represent if the EULA has been accepted"
        isEulaAccepted: Boolean
    ): AccountSetting!
    updateAppBlueprint(children: [AppBlueprintChildInput!]!, fid: UUID!, name: String!, primaryClusterUuid: UUID!): Blueprint!
    updateAwsComputeSetting(
        "Request arguments for updating a Aws Compute Setting"
        awsComputeSettingsUpdateRequest: AwsComputeSettingsEditRequest!
    ): AwsComputeSettings!
    "Update indexing status for cloudnative snappables"
    updateCloudNativeIndexingStatus(
        "Is indexing enabled or disabled for snappables"
        isIndexingEnabled: Boolean!,
        "List of snappable IDs"
        snappableIds: [UUID!]!
    ): UpdateCloudNativeIndexingStatusReply!
    "Update cloud native label rule"
    updateCloudNativeLabelRule(
        "cloud native accounts on which tag rule will be applied"
        cloudNativeAccountIds: CloudNativeIDs,
        "Corresponds to optional global SLA forever UUID in Polaris tables"
        globalSlaOptionalFid: UUID,
        "UUID for the tag or label rule"
        ruleId: UUID!,
        "Name for the rule"
        ruleName: String!,
        "Corresponds to the assignment type for the SLA"
        ruleSlaAssignType: TagRuleSlaAssignTypeEnum!
    ): String!
    "Update cloud native tag rule"
    updateCloudNativeTagRule(
        "cloud native accounts on which tag rule will be applied"
        cloudNativeAccountIds: CloudNativeIDs,
        "Corresponds to optional global SLA forever UUID in Polaris tables"
        globalSlaOptionalFid: UUID,
        "UUID for the tag or label rule"
        ruleId: UUID!,
        "Name for the rule"
        ruleName: String!,
        "Corresponds to the assignment type for the SLA"
        ruleSlaAssignType: TagRuleSlaAssignTypeEnum!
    ): String!
    "Update a custom analyzer"
    updateCustomAnalyzer(analyzer: AnalyzerInput!): Analyzer!
    updateHostCertificate(
        "ID of the host."
        id: String!
    ): HostDetail!
    updateIpWhitelist(ipCidrs: [String!]!, whitelistMode: WhitelistModeEnum!): Boolean!
    updateLambdaSettings(
        "Probability threshold for anomaly detector"
        anomalyThreshold: Float,
        "Flag to represent if alert on anomaly snappable is enabled"
        isAnomalyAlertEnabled: Boolean,
        "Probability threshold for ransomware detector"
        ransomwareThreshold: Float
    ): LambdaSettings!
    "Update ldap config"
    updateLdapConfig(adDomain: String!, clusterUuid: String!, ldapId: Long!, ldapName: String!, password: String!, userName: String!): UpdateLdapConfigReply!
    "Update a classification policy"
    updatePolicy(policy: ClassificationPolicyInput!): ClassificationPolicyDetail!
    "Update previewer cluster config"
    updatePreviewerClusterConfig(previewerClusterConfig: PreviewerClusterConfigInput!): Cluster!
    updateReport(reportConfig: ReportConfigInput!, reportID: Int!): Boolean!
    updateRole(description: String!, name: String!, permissions: [PermissionInput!]!, roleId: String!): Boolean!
    updateRoleAssignments(adGroupIds: [String!], roleIds: [String!]!, userIds: [String!]): Boolean!
    "API to open or close a support tunnel. nodeId must be the id of the current node, isTunnelEnabled is to open or close the tunnel, and inactivityTimeoutInSeconds is to set the timeout (if not provided, defaults to 4 days)"
    updateSupportTunnel(
        "The id of the cluster"
        clusterUuid: UUID!,
        inactivityTimeoutInSeconds: Long,
        isTunnelEnabled: Boolean!,
        nodeId: String!
    ): SupportTunnelInfoResp!
    "Update whitelisted analyzers for a path"
    updateWhitelistedAnalyzers(analyzerIds: [String!]!, runAsync: Boolean!, snappableFid: String!, snapshotFid: String!, stdPath: String!): String!
    "Create (or update if already exists) the account settings value."
    upsertAccountSettingValue(
        "Name of component that uses ASP in account setting table"
        aspComponent: ComponentEnum!,
        "Name of parameter (ASP) in account setting table"
        aspName: String!,
        "Value of ASP in account setting table"
        aspValue: String!
    ): ASPValue!
    vSphereVMBatchLiveMount(
        clusterUuid: UUID!,
        "Configuration object containing an array of virtual machine IDs, a way to indicate the snapshot to be chosen and mount configs."
        config: BatchMountSnapshotJobConfigInput!
    ): BatchAsyncRequestStatus!
    "validate the recovery specs with the given app blueprint snappable or snapshot fid"
    validateBlueprintRecoverySpec(
        "the fid of the app blueprint"
        appBlueprintId: UUID!,
        "the fid of the app blueprint snapshot"
        appBlueprintSnapshotId: UUID,
        "Flag to represent if it should validate snapshot recovery spec"
        validateSnapshotRecoverySpec: Boolean
    ): RecoverySpecValidityCheckReply!
    vpshereVMRecoveryPointMount(createDatastoreOnly: Boolean, datastoreName: String, disableNetwork: Boolean, hostID: String, keepMacAddresses: Boolean, powerOn: Boolean, recoveryPoint: String, removeNetworkDevices: Boolean, shouldRecoverTags: Boolean, snappableFid: UUID!, snapshotFid: UUID, unregsiterVm: Boolean, vlan: Int, vmName: String): vSphereAsyncRequestStatus!
    vsphereCreateVCenter(caCert: String, clusterUuid: UUID!, conflictResolutionAuthz: ConflictResolutionAuthzEnum!, hostname: String!, password: String!, username: String!): vSphereAsyncRequestStatus!
    vsphereDeleteVCenter(vcenterId: UUID!): vSphereAsyncRequestStatus!
    vsphereEditVCenter(caCert: String, conflictResolutionAuthz: ConflictResolutionAuthzEnum!, hostname: String!, password: String!, username: String!, vcenterId: UUID!): RequestSuccess!
    vsphereExcludeVMDisks(virtualDiskUpdate: [VmDiskUpdateInput!]!): RequestSuccess!
    vsphereExportSnapshotToStandaloneHost(
        datastoreName: String!,
        disableNetwork: Boolean,
        hostIpAddress: String!,
        hostPassword: String!,
        hostUsername: String!,
        keepMacAddresses: Boolean,
        powerOn: Boolean,
        removeNetworkDevices: Boolean,
        "Corresponds to snapshot forever UUID in Polaris tables"
        snapshotFid: UUID!,
        vmName: String
    ): vSphereAsyncRequestStatus!
    vsphereOnDemandSnapshot(
        "The SLA id of the snappable"
        slaID: String,
        snappableFid: UUID!
    ): vSphereAsyncRequestStatus!
    vsphereRefreshVCenter(vcenterId: UUID!): vSphereAsyncRequestStatus!
    vsphereVMDeleteLiveMount(force: Boolean, livemountId: UUID!): vSphereAsyncRequestStatus!
    vsphereVMDeleteSnapshot(
        location: String!,
        "Corresponds to snapshot forever UUID in Polaris tables"
        snapshotFid: UUID!
    ): RequestSuccess!
    vsphereVMDownloadSnapshot(
        "Corresponds to snapshot forever UUID in Polaris tables"
        snapshotFid: UUID!
    ): vSphereAsyncRequestStatus!
    vsphereVMDownloadSnapshotFiles(
        deltaTypeFilter: [DeltaTypeEnum!],
        nextSnapshotFid: UUID,
        "paths of files"
        paths: [String!]!,
        "Corresponds to snapshot forever UUID in Polaris tables"
        snapshotFid: UUID!
    ): vSphereAsyncRequestStatus!
    vsphereVMExportSnapshot(
        datastoreId: UUID!,
        disableNetwork: Boolean,
        hostID: String,
        keepMacAddresses: Boolean,
        powerOn: Boolean,
        removeNetworkDevices: Boolean,
        shouldRecoverTags: Boolean,
        "Corresponds to snapshot forever UUID in Polaris tables"
        snapshotFid: UUID!,
        unregsiterVm: Boolean,
        vmName: String
    ): vSphereAsyncRequestStatus!
    vsphereVMInitiateDiskMount(
        "Corresponds to snapshot forever UUID in Polaris tables"
        snapshotFid: UUID!,
        targetVmID: String,
        vlan: Int,
        vmdkIDs: [String!]!
    ): vSphereAsyncRequestStatus!
    vsphereVMInitiateInstantRecovery(
        disableNetwork: Boolean,
        hostID: String,
        keepMacAddresses: Boolean,
        powerOn: Boolean,
        preserveMOID: Boolean,
        removeNetworkDevices: Boolean,
        shouldRecoverTags: Boolean,
        "Corresponds to snapshot forever UUID in Polaris tables"
        snapshotFid: UUID!,
        vlan: Int,
        vmName: String
    ): vSphereAsyncRequestStatus!
    vsphereVMInitiateLiveMount(
        createDatastoreOnly: Boolean,
        datastoreName: String,
        disableNetwork: Boolean,
        hostID: String,
        keepMacAddresses: Boolean,
        powerOn: Boolean,
        removeNetworkDevices: Boolean,
        shouldRecoverTags: Boolean,
        "Corresponds to snapshot forever UUID in Polaris tables"
        snapshotFid: UUID!,
        vlan: Int,
        vmName: String
    ): vSphereAsyncRequestStatus!
    "Retrieve a list of the datastores for a specified ESXi host"
    vsphereVMListESXiDatastores(clusterUuid: UUID!, ipAddress: String!, password: String!, username: String!): DatastoreListResponse!
    vsphereVMMountRelocate(datastoreId: UUID!, livemountId: UUID!): vSphereAsyncRequestStatus!
    vsphereVMPowerOnOffLiveMount(livemountId: UUID!, powerStatus: Boolean!): RequestSuccess!
    vsphereVMRecoverFiles(
        "vm restore parameters"
        restoreConfig: RestoreConfig!,
        "Corresponds to snapshot forever UUID in Polaris tables"
        snapshotFid: UUID!
    ): vSphereAsyncRequestStatus!
    vsphereVMRecoverFilesNew(
        clusterUuid: UUID!,
        "Configuration for the restore request."
        config: RestoreFilesJobConfigInput!,
        "ID of a snapshot."
        id: String!
    ): AsyncRequestStatus!
    vsphereVMRecoveryPointExport(datastoreId: UUID!, disableNetwork: Boolean, hostID: String, keepMacAddresses: Boolean, powerOn: Boolean, recoveryPoint: String, removeNetworkDevices: Boolean, shouldRecoverTags: Boolean, snappableFid: UUID!, snapshotFid: UUID, unregsiterVm: Boolean, vmName: String): vSphereAsyncRequestStatus!
    vsphereVMRecoveryPointInstantRecovery(disableNetwork: Boolean, hostID: String, keepMacAddresses: Boolean, powerOn: Boolean, preserveMOID: Boolean, recoveryPoint: String, removeNetworkDevices: Boolean, shouldRecoverTags: Boolean, snappableFid: UUID!, snapshotFid: UUID, vlan: Int, vmName: String): vSphereAsyncRequestStatus!
    vsphereVMRegisterAgent(snappableFid: UUID!): RequestSuccess!
    vsphereVMUpdate(
        isArrayIntegrationEnabled: Boolean,
        postBackupScript: PostBackupScriptInputType,
        postSnapScript: PostSnapScriptInputType,
        preBackupScript: PreBackupScriptInputType,
        snappableFid: UUID!,
        "The snapshot consistency mandate of the snappable."
        snapshotConsistencyMandate: String
    ): RequestSuccess!
    "Warm cache for search in cloud native snappables"
    warmCloudNativeIndexCache(
        "Snappable ID"
        snappableId: UUID!
    ): Boolean!
    warmSearchCache(snappableFid: UUID!): Boolean!
}

"""

Supported in v5.0+
"""
type NasBaseConfig {
    """

    Supported in v5.0+
    TLS certification to validate NAS server
    """
    apiCertificate: String
    """

    Supported in v5.0+
    API endpoint to access NAS API 'FLASHBLADE'
    """
    apiEndpoint: String
    """

    Supported in v5.0+
    Hostname or IP used in the NAS API calls
    """
    apiHostname: String
    """

    Supported in v5.0+
    username to access NAS API
    """
    apiUsername: String
    """

    Supported in v5.2+
    v5.2: A Boolean value that specifies whether Changelist is enabled on Isilon NAS share. When this value is 'true', metadata fetches during backup operations use the Isilon Changelist feature. The Changelist feature improves incremental backup performance by tracking the difference between two snapshots, reducing the metadata scanning time during a backup job.
    v5.3: Indicates if Changelist is enabled on Isilon NAS share. When this value is 'true', metadata fetches during backup operations use the Isilon Changelist feature. The Changelist feature improves incremental backup performance by tracking the difference between two snapshots, reducing the metadata scanning time during a backup job.
    """
    isIsilonChangelistEnabled: Boolean
    """

    Supported in v5.2+
    v5.2: A Boolean value that specifies whether SnapDiff is enabled on NetApp NAS share. When this value is 'true', metadata fetches during backup operations use the NetApp SnapDiff feature. The SnapDiff feature improves incremental backup performance by tracking the difference between two snapshots, reducing the metadata scanning time during a backup job.
    v5.3: Indicates if SnapDiff is enabled on NetApp NAS share. When this value is 'true', metadata fetches during backup operations use the NetApp SnapDiff feature. The SnapDiff feature improves incremental backup performance by tracking the difference between two snapshots, reducing the metadata scanning time during a backup job.
    """
    isNetAppSnapDiffEnabled: Boolean
    """

    Supported in v5.3
    Specifies whether shares on the NAS host are automatically discovered. When this value is 'true', Rubrik periodically (every 30 minutes by default) connects to the NAS host to discover NFS and SMB shares.
    """
    isShareAutoDiscoveryEnabled: Boolean
    """

    Supported in v5.1
    If snapdiff is enabled on NetApp NAS host
    """
    isSnapdiffEnabled: Boolean
    """

    Supported in v5.0+
    Type of NAS vendor 'ISILON/NETAPP/FLASHBLADE'
    """
    vendorType: String!
    """

    Supported in v5.0+
    Name of the Isilon zone that data IP belongs to
    """
    zoneName: String
}

"Represents a GCP native network host project"
type NetworkHostProject {
    name: String!
    nativeId: String!
    projectId: String!
}

"List of status for each node"
type NodeStatus {
    brikId: String!
    id: String!
    ipAddress: String
    status: String!
    supportTunnel: SupportTunnelInfoResp
}

"Response type for getting information on every node in a cluster"
type NodeStatusListResp {
    data: [NodeStatus!]!
    hasMore: Boolean
    id: String!
    total: Long
}

type O365App implements O365AppObject {
    addedAt: DateTime!
    appId: String!
    appOwner: String!
    appType: String!
    isAuthenticated: Boolean!
    subscription: String!
}

type O365AppConnection {
    count: Int!
    edges: [O365AppEdge!]!
    nodes: [O365App!]!
    pageInfo: PageInfo!
}

type O365AppEdge {
    cursor: String!
    node: O365App!
}

type O365Calendar implements HierarchyObject & HierarchySnappable & O365OrgDescendant & O365UserDescendant & PolarisHierarchyObject & PolarisHierarchySnappable {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "object id"
    id: UUID!
    isRelic: Boolean!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "the newest snapshot that is indexed and unexpired, and therefore restorable."
    newestIndexedSnapshot: PolarisSnapshot
    "the most recent snapshot of this snappable"
    newestSnapshot: PolarisSnapshot
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "the oldest snapshot of this snappable"
    oldestSnapshot: PolarisSnapshot
    "the number of on-demand snapshots"
    onDemandSnapshotCount: Int!
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The list of snapshots taken for this snappable"
    snapshotConnection(
        after: String,
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        first: Int,
        last: Int,
        "sort polaris snapshots by field"
        sortBy: PolarisSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): PolarisSnapshotConnection
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByConnection(
        after: String,
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        first: Int,
        "group polaris snapshots by field"
        groupBy: PolarisSnapshotGroupByEnum!,
        last: Int,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByConnection
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByNewConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "filter polaris snapshot connection"
        snapshotFilter: [PolarisSnapshotFilterNewInput!]!,
        "group polaris snapshots by field"
        snapshotGroupBy: SnapshotGroupByTimeEnum!,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByNewConnection
    "The list of snapshots taken for this snappable"
    snapshotsOfSnappableConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        snappableId: String!,
        "filter for snapshot connection"
        snapshotFilter: [SnapshotQueryFilterInput!],
        sortBy: SnapshotQuerySortByField,
        "sort order"
        sortOrder: SortOrderEnum,
        timeRange: TimeRangeInput
    ): GenericSnapshotConnection
}

type O365CalendarEvent implements O365ExchangeObject {
    attendees: [String!]!
    endDateTime: DateTime
    eventType: CalendarEventTypeEnum!
    id: String!
    name: String
    organizer: String
    parentFolderId: String
    snapshotId: UUID
    startDateTime: DateTime
    versionStartSnapshotId: UUID
}

type O365CalendarFolder implements O365ExchangeObject {
    id: String!
    name: String
    parentFolderId: String
    snapshotId: UUID
}

type O365Email implements O365ExchangeObject {
    from: String
    id: String!
    parentFolderId: String
    receivedDateTime: DateTime
    sentDateTime: DateTime
    snapshotId: UUID
    subject: String
    toRecipients: [String!]!
}

type O365ExchangeObjectConnection {
    count: Int!
    edges: [O365ExchangeObjectEdge!]!
    nodes: [O365ExchangeObject!]!
    pageInfo: PageInfo!
}

type O365ExchangeObjectEdge {
    cursor: String!
    node: O365ExchangeObject!
}

type O365Folder implements O365ExchangeObject {
    id: String!
    name: String
    parentFolderId: String
    snapshotId: UUID
}

type O365Mailbox implements HierarchyObject & HierarchySnappable & O365OrgDescendant & O365UserDescendant & PolarisHierarchyObject & PolarisHierarchySnappable {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "object id"
    id: UUID!
    isRelic: Boolean!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "the newest snapshot that is indexed and unexpired, and therefore restorable."
    newestIndexedSnapshot: PolarisSnapshot
    "the most recent snapshot of this snappable"
    newestSnapshot: PolarisSnapshot
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "the oldest snapshot of this snappable"
    oldestSnapshot: PolarisSnapshot
    "the number of on-demand snapshots"
    onDemandSnapshotCount: Int!
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The list of snapshots taken for this snappable"
    snapshotConnection(
        after: String,
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        first: Int,
        last: Int,
        "sort polaris snapshots by field"
        sortBy: PolarisSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): PolarisSnapshotConnection
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByConnection(
        after: String,
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        first: Int,
        "group polaris snapshots by field"
        groupBy: PolarisSnapshotGroupByEnum!,
        last: Int,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByConnection
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByNewConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "filter polaris snapshot connection"
        snapshotFilter: [PolarisSnapshotFilterNewInput!]!,
        "group polaris snapshots by field"
        snapshotGroupBy: SnapshotGroupByTimeEnum!,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByNewConnection
    "The list of snapshots taken for this snappable"
    snapshotsOfSnappableConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        snappableId: String!,
        "filter for snapshot connection"
        snapshotFilter: [SnapshotQueryFilterInput!],
        sortBy: SnapshotQuerySortByField,
        "sort order"
        sortOrder: SortOrderEnum,
        timeRange: TimeRangeInput
    ): GenericSnapshotConnection
    userPrincipalName: String!
}

type O365MailboxConnection {
    count: Int!
    edges: [O365MailboxEdge!]!
    nodes: [O365Mailbox!]!
    pageInfo: PageInfo!
}

type O365MailboxEdge {
    cursor: String!
    node: O365Mailbox!
}

type O365Onedrive implements HierarchyObject & HierarchySnappable & O365OrgDescendant & O365UserDescendant & PolarisHierarchyObject & PolarisHierarchySnappable {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "object id"
    id: UUID!
    isRelic: Boolean!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "the newest snapshot that is indexed and unexpired, and therefore restorable."
    newestIndexedSnapshot: PolarisSnapshot
    "the most recent snapshot of this snappable"
    newestSnapshot: PolarisSnapshot
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "the oldest snapshot of this snappable"
    oldestSnapshot: PolarisSnapshot
    "the number of on-demand snapshots"
    onDemandSnapshotCount: Int!
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The list of snapshots taken for this snappable"
    snapshotConnection(
        after: String,
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        first: Int,
        last: Int,
        "sort polaris snapshots by field"
        sortBy: PolarisSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): PolarisSnapshotConnection
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByConnection(
        after: String,
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        first: Int,
        "group polaris snapshots by field"
        groupBy: PolarisSnapshotGroupByEnum!,
        last: Int,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByConnection
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByNewConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "filter polaris snapshot connection"
        snapshotFilter: [PolarisSnapshotFilterNewInput!]!,
        "group polaris snapshots by field"
        snapshotGroupBy: SnapshotGroupByTimeEnum!,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByNewConnection
    "The list of snapshots taken for this snappable"
    snapshotsOfSnappableConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        snappableId: String!,
        "filter for snapshot connection"
        snapshotFilter: [SnapshotQueryFilterInput!],
        sortBy: SnapshotQuerySortByField,
        "sort order"
        sortOrder: SortOrderEnum,
        timeRange: TimeRangeInput
    ): GenericSnapshotConnection
    totalStorageInBytes: Long!
    usedStorageInBytes: Long!
    userID: String!
    userName: String!
    userPrincipalName: String!
}

type O365OnedriveConnection {
    count: Int!
    edges: [O365OnedriveEdge!]!
    nodes: [O365Onedrive!]!
    pageInfo: PageInfo!
}

type O365OnedriveEdge {
    cursor: String!
    node: O365Onedrive!
}

type O365OnedriveFile implements O365OnedriveObject {
    createTime: DateTime
    fileType: String
    id: String!
    modifiedTime: DateTime
    name: String
    parentFolderId: String
    size: Long
    snapshotId: UUID
    snapshotNum: Int
}

type O365OnedriveFolder implements O365OnedriveObject {
    createTime: DateTime
    id: String!
    itemCount: Int
    modifiedTime: DateTime
    name: String
    parentFolderId: String
    size: Long
    snapshotId: UUID
    snapshotNum: Int
}

type O365OnedriveObjectConnection {
    count: Int!
    edges: [O365OnedriveObjectEdge!]!
    nodes: [O365OnedriveObject!]!
    pageInfo: PageInfo!
}

type O365OnedriveObjectEdge {
    cursor: String!
    node: O365OnedriveObject!
}

type O365Org implements HierarchyObject & PolarisHierarchyObject {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "List of direct children of O365Org"
    childConnection(after: String, filter: [Filter!], first: Int, sortBy: HierarchySortByField, sortOrder: HierarchySortOrder): O365UserConnection!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    exocomputeId: String!
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    past1DayMailboxComplianceCount: Int!
    past1DayMailboxOutOfComplianceCount: Int!
    past1DayOnedriveComplianceCount: Int!
    past1DayOnedriveOutOfComplianceCount: Int!
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "List of all descendants of O365Org"
    searchDescendantConnection(after: String, filter: [Filter!], first: Int, sortBy: HierarchySortByField, sortOrder: HierarchySortOrder): O365OrgDescendantConnection!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
    status: OrgStatusEnum!
    "Number of O365 Users with no SLA assigned"
    unprotectedUsersCount: Int!
    "List of Users with mailboxId"
    userWithMailboxIdConnection(after: String, filter: [Filter!], first: Int, sortBy: HierarchySortByField, sortOrder: HierarchySortOrder): O365UserWithMailboxIdConnection!
}

type O365OrgConnection {
    count: Int!
    edges: [O365OrgEdge!]!
    nodes: [O365Org!]!
    pageInfo: PageInfo!
}

type O365OrgDescendantConnection {
    count: Int!
    edges: [O365OrgDescendantEdge!]!
    nodes: [O365OrgDescendant!]!
    pageInfo: PageInfo!
}

type O365OrgDescendantEdge {
    cursor: String!
    node: O365OrgDescendant!
}

type O365OrgEdge {
    cursor: String!
    node: O365Org!
}

type O365ServiceAccountStatusResp {
    status: O365ServiceAccountStatusEnum!
    username: String!
}

"O365 setup kickoff response"
type O365SetupKickoffResp {
    appClientId: String!
    appClientIdsPerType: [AppIDForType!]!
    csrfToken: String!
}

type O365SharepointDrive implements HierarchyObject & HierarchySnappable & O365OrgDescendant & O365SharepointObject & PolarisHierarchyObject & PolarisHierarchySnappable {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "object id"
    id: UUID!
    isRelic: Boolean!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "the newest snapshot that is indexed and unexpired, and therefore restorable."
    newestIndexedSnapshot: PolarisSnapshot
    "the most recent snapshot of this snappable"
    newestSnapshot: PolarisSnapshot
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    objectId: String!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "the oldest snapshot of this snappable"
    oldestSnapshot: PolarisSnapshot
    "the number of on-demand snapshots"
    onDemandSnapshotCount: Int!
    parentId: String!
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The list of snapshots taken for this snappable"
    snapshotConnection(
        after: String,
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        first: Int,
        last: Int,
        "sort polaris snapshots by field"
        sortBy: PolarisSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): PolarisSnapshotConnection
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByConnection(
        after: String,
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        first: Int,
        "group polaris snapshots by field"
        groupBy: PolarisSnapshotGroupByEnum!,
        last: Int,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByConnection
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByNewConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "filter polaris snapshot connection"
        snapshotFilter: [PolarisSnapshotFilterNewInput!]!,
        "group polaris snapshots by field"
        snapshotGroupBy: SnapshotGroupByTimeEnum!,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByNewConnection
    "The list of snapshots taken for this snappable"
    snapshotsOfSnappableConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        snappableId: String!,
        "filter for snapshot connection"
        snapshotFilter: [SnapshotQueryFilterInput!],
        sortBy: SnapshotQuerySortByField,
        "sort order"
        sortOrder: SortOrderEnum,
        timeRange: TimeRangeInput
    ): GenericSnapshotConnection
    title: String!
    totalStorageInBytes: Long!
    usedStorageInBytes: Long!
}

type O365SharepointDriveConnection {
    count: Int!
    edges: [O365SharepointDriveEdge!]!
    nodes: [O365SharepointDrive!]!
    pageInfo: PageInfo!
}

type O365SharepointDriveEdge {
    cursor: String!
    node: O365SharepointDrive!
}

type O365SharepointObjectConnection {
    count: Int!
    edges: [O365SharepointObjectEdge!]!
    nodes: [O365SharepointObject!]!
    pageInfo: PageInfo!
}

type O365SharepointObjectEdge {
    cursor: String!
    node: O365SharepointObject!
}

type O365Site implements HierarchyObject & HierarchySnappable & O365OrgDescendant & O365SharepointObject & PolarisHierarchyObject & PolarisHierarchySnappable {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "object id"
    id: UUID!
    isRelic: Boolean!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "the newest snapshot that is indexed and unexpired, and therefore restorable."
    newestIndexedSnapshot: PolarisSnapshot
    "the most recent snapshot of this snappable"
    newestSnapshot: PolarisSnapshot
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    objectId: String!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "the oldest snapshot of this snappable"
    oldestSnapshot: PolarisSnapshot
    "the number of on-demand snapshots"
    onDemandSnapshotCount: Int!
    parentId: String!
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The list of snapshots taken for this snappable"
    snapshotConnection(
        after: String,
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        first: Int,
        last: Int,
        "sort polaris snapshots by field"
        sortBy: PolarisSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): PolarisSnapshotConnection
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByConnection(
        after: String,
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        first: Int,
        "group polaris snapshots by field"
        groupBy: PolarisSnapshotGroupByEnum!,
        last: Int,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByConnection
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByNewConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "filter polaris snapshot connection"
        snapshotFilter: [PolarisSnapshotFilterNewInput!]!,
        "group polaris snapshots by field"
        snapshotGroupBy: SnapshotGroupByTimeEnum!,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByNewConnection
    "The list of snapshots taken for this snappable"
    snapshotsOfSnappableConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        snappableId: String!,
        "filter for snapshot connection"
        snapshotFilter: [SnapshotQueryFilterInput!],
        sortBy: SnapshotQuerySortByField,
        "sort order"
        sortOrder: SortOrderEnum,
        timeRange: TimeRangeInput
    ): GenericSnapshotConnection
    title: String!
    url: String!
}

type O365SiteConnection {
    count: Int!
    edges: [O365SiteEdge!]!
    nodes: [O365Site!]!
    pageInfo: PageInfo!
}

type O365SiteEdge {
    cursor: String!
    node: O365Site!
}

type O365User implements HierarchyObject & O365OrgDescendant & PolarisHierarchyObject {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "List of direct children of O365User"
    childConnection(after: String, filter: [Filter!], first: Int, sortBy: HierarchySortByField, sortOrder: HierarchySortOrder): O365UserDescendantConnection!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    emailAddress: String
    "The fid of the hierarchy object."
    id: UUID!
    isRelic: Boolean!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

type O365UserConnection {
    count: Int!
    edges: [O365UserEdge!]!
    nodes: [O365User!]!
    pageInfo: PageInfo!
}

type O365UserDescendantConnection {
    count: Int!
    edges: [O365UserDescendantEdge!]!
    nodes: [O365UserDescendant!]!
    pageInfo: PageInfo!
}

type O365UserDescendantEdge {
    cursor: String!
    node: O365UserDescendant!
}

type O365UserEdge {
    cursor: String!
    node: O365User!
}

type O365UserWithMailboxId implements HierarchyObject & HierarchySnappable & PolarisHierarchyObject & PolarisHierarchySnappable {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    emailAddress: String
    "object id"
    id: UUID!
    isRelic: Boolean!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    mailboxId: String
    "The name of the hierarchy object."
    name: String!
    "the newest snapshot that is indexed and unexpired, and therefore restorable."
    newestIndexedSnapshot: PolarisSnapshot
    "the most recent snapshot of this snappable"
    newestSnapshot: PolarisSnapshot
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "the oldest snapshot of this snappable"
    oldestSnapshot: PolarisSnapshot
    "the number of on-demand snapshots"
    onDemandSnapshotCount: Int!
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The list of snapshots taken for this snappable"
    snapshotConnection(
        after: String,
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        first: Int,
        last: Int,
        "sort polaris snapshots by field"
        sortBy: PolarisSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): PolarisSnapshotConnection
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByConnection(
        after: String,
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        first: Int,
        "group polaris snapshots by field"
        groupBy: PolarisSnapshotGroupByEnum!,
        last: Int,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByConnection
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByNewConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "filter polaris snapshot connection"
        snapshotFilter: [PolarisSnapshotFilterNewInput!]!,
        "group polaris snapshots by field"
        snapshotGroupBy: SnapshotGroupByTimeEnum!,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByNewConnection
    "The list of snapshots taken for this snappable"
    snapshotsOfSnappableConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        snappableId: String!,
        "filter for snapshot connection"
        snapshotFilter: [SnapshotQueryFilterInput!],
        sortBy: SnapshotQuerySortByField,
        "sort order"
        sortOrder: SortOrderEnum,
        timeRange: TimeRangeInput
    ): GenericSnapshotConnection
}

type O365UserWithMailboxIdConnection {
    count: Int!
    edges: [O365UserWithMailboxIdEdge!]!
    nodes: [O365UserWithMailboxId!]!
    pageInfo: PageInfo!
}

type O365UserWithMailboxIdEdge {
    cursor: String!
    node: O365UserWithMailboxId!
}

type ObjectIdsForHierarchyType {
    objectIds: [String!]!
    snappableType: SnappableLevelHierarchyTypeEnum!
}

type ObjectSpecificConfigs {
    awsRdsConfig: AwsRdsConfig
    sapHanaConfig: SapHanaConfig
    vmwareVmConfig: VmwareVmConfig
}

type ObjectStatus {
    id: String!
    latestSnapshotResult: SnapshotResult
    policyStatuses: [PolicyStatus!]!
}

type ObjectType {
    enumValue: ObjectTypeEnum!
}

type OpenSupportTunnelReply {
    currentPort: String!
    inactivityTimeout: String!
    isTunnelOpen: String!
    nodeId: String!
}

"An option group on AWS."
type OptionGroup {
    arn: String!
    engine: String!
    majorEngineVersion: String!
    name: String!
    vpcId: String!
}

type PageInfo {
    endCursor: String!
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String!
}

type PathNode {
    fid: UUID!
    name: String!
    objectType: HierarchyObjectTypeEnum!
}

type PathSecInfo {
    owner: String!
    path: String!
    permissions: [SDDLPermission!]!
}

type PendingActionType {
    pendingActionGroupType: PendingActionGroupTypeEnum!
    pendingActionSubGroupType: PendingActionSubGroupTypeEnum!
    pendingActionSyncType: PendingActionSyncTypeEnum!
}

type PendingSnapshotDeletion {
    snapshotFid: UUID!
    status: PendingActionStatusEnum!
}

type PendingSnapshotsOfObjectDeletion {
    objectFid: UUID!
    status: PendingActionStatusEnum!
}

type Permission {
    objectsForHierarchyTypes: [ObjectIdsForHierarchyType!]!
    operation: OperationEnum!
}

type PhysicalHost implements CdmHierarchyObject & HierarchyObject {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    cdmId: String!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    connectionStatus: HostConnectionStatus
    "List of descendants"
    descendantConnection(
        after: String,
        filter: [Filter!],
        first: Int,
        "provide optional snappable hierarchy for RBAC and SLA, none value is assumed to be All snappable hierarchy"
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): PhysicalHostDescendantTypeConnection!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    ipAddresses: [String!]!
    isArchived: Boolean!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    osName: String
    "The OS Type of this Physical Host"
    osType: GuestOsTypeEnum
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "List of physical children"
    physicalChildConnection(
        after: String,
        filter: [Filter!],
        first: Int,
        "provide optional snappable hierarchy for RBAC and SLA, none value is assumed to be All snappable hierarchy"
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): PhysicalHostPhysicalChildTypeConnection!
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

type PhysicalHostConnection {
    count: Int!
    edges: [PhysicalHostEdge!]!
    nodes: [PhysicalHost!]!
    pageInfo: PageInfo!
}

type PhysicalHostDescendantTypeConnection {
    count: Int!
    edges: [PhysicalHostDescendantTypeEdge!]!
    nodes: [PhysicalHostDescendantType!]!
    pageInfo: PageInfo!
}

type PhysicalHostDescendantTypeEdge {
    cursor: String!
    node: PhysicalHostDescendantType!
}

type PhysicalHostEdge {
    cursor: String!
    node: PhysicalHost!
}

type PhysicalHostPhysicalChildTypeConnection {
    count: Int!
    edges: [PhysicalHostPhysicalChildTypeEdge!]!
    nodes: [PhysicalHostPhysicalChildType!]!
    pageInfo: PageInfo!
}

type PhysicalHostPhysicalChildTypeEdge {
    cursor: String!
    node: PhysicalHostPhysicalChildType!
}

type PolarisHierarchyObjectConnection {
    count: Int!
    edges: [PolarisHierarchyObjectEdge!]!
    nodes: [PolarisHierarchyObject!]!
    pageInfo: PageInfo!
}

type PolarisHierarchyObjectEdge {
    cursor: String!
    node: PolarisHierarchyObject!
}

type PolarisHierarchySnappableObject {
    id: String!
    name: String!
}

type PolarisInventorySubHierarchyRoot {
    "List of children"
    childConnection(
        after: String,
        filter: [Filter!],
        first: Int,
        "provide optional snappable hierarchy for RBAC and SLA, none value is assumed to be All snappable hierarchy"
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): PolarisHierarchyObjectConnection!
    "List of descendants"
    descendantConnection(
        after: String,
        filter: [Filter!],
        first: Int,
        "provide optional snappable hierarchy for RBAC and SLA, none value is assumed to be All snappable hierarchy"
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): PolarisHierarchyObjectConnection!
    rootEnum: InventorySubHierarchyRootEnum!
    "List of top-level descendants (with respect to RBAC)"
    topLevelDescendantConnection(after: String, filter: [Filter!], first: Int, sortBy: HierarchySortByField, sortOrder: HierarchySortOrder, typeFilter: [HierarchyObjectTypeEnum!]): PolarisHierarchyObjectConnection!
}

"Specific info for AWS Target created on Polaris"
type PolarisManagedAwsTarget implements Target {
    bucket: String!
    cloudAccount: CloudAccount!
    "The cluster to which this target belongs"
    cluster: Cluster!
    computeSettings: AwsComputeSettings
    encryptionType: TargetEncryptionTypeEnum!
    "The id of this Target"
    id: String!
    "The pause/resume status of this Target"
    isActive: Boolean!
    "Whether this Target is archived"
    isArchived: Boolean!
    isConsolidationEnabled: Boolean!
    "The name of this Target"
    name: String!
    proxySettings: ProxySettings
    region: AwsRegionEnum!
    storageClass: AwsStorageClassTypeEnum!
    syncFailureReason: String!
    syncStatus: TargetSyncStatusEnum!
    "The type of this Target"
    targetType: TargetTypeEnum!
}

"Specific info for Azure Target created on Polaris"
type PolarisManagedAzureTarget implements Target {
    accessKey: String!
    cloudAccount: CloudAccount!
    "The cluster to which this target belongs"
    cluster: Cluster!
    computeSettings: AzureComputeSettings
    containerName: String!
    "The id of this Target"
    id: String!
    instanceType: InstanceTypeEnum!
    "The pause/resume status of this Target"
    isActive: Boolean!
    "Whether this Target is archived"
    isArchived: Boolean!
    isConsolidationEnabled: Boolean!
    "The name of this Target"
    name: String!
    proxySettings: ProxySettings
    storageAccountName: String!
    syncFailureReason: String!
    syncStatus: TargetSyncStatusEnum!
    "The type of this Target"
    targetType: TargetTypeEnum!
}

"Specific info for Nfs Target created on Polaris"
type PolarisManagedNfsTarget implements Target {
    "The cluster to which this target belongs"
    cluster: Cluster!
    destinationFolder: String!
    exportDir: String!
    fileLockPeriodInSeconds: Int!
    host: String!
    "The id of this Target"
    id: String!
    "The pause/resume status of this Target"
    isActive: Boolean!
    "Whether this Target is archived"
    isArchived: Boolean!
    isConsolidationEnabled: Boolean!
    "The name of this Target"
    name: String!
    nfsAuthType: AuthTypeEnum!
    nfsVersion: Int!
    otherNfsOptions: String!
    syncFailureReason: String!
    syncStatus: TargetSyncStatusEnum!
    "The type of this Target"
    targetType: TargetTypeEnum!
}

"SLA Sync status for a given cluster"
type PolarisSLASyncStatus {
    SLASyncStatus: PolarisSLASyncStatusEnum!
    clusterUuid: String!
}

type PolarisSnapshot implements GenericSnapshot {
    date: DateTime!
    expirationDate: DateTime
    expiryHint: Boolean!
    "Whether or not the snapshot has an unexpired replica"
    hasUnexpiredReplica: Boolean!
    id: UUID!
    indexTime: DateTime
    indexingAttempts: Long!
    isCorrupted: Boolean!
    isDeletedFromSource: Boolean!
    isDownloadedSnapshot: Boolean
    "Whether or not the snapshot is expired"
    isExpired: Boolean!
    "Whether or not the snapshot is indexed."
    isIndexed: Boolean!
    isOnDemandSnapshot: Boolean!
    isReplicated: Boolean!
    isUnindexable: Boolean!
    parentSnapshotId: String
    replicationLocations: [DataLocation!]
    sequenceNumber: Int!
    slaDomain: SlaDomain
    snappableId: String!
    unexpiredReplicaCount: Int!
}

type PolarisSnapshotConnection {
    count: Int!
    edges: [PolarisSnapshotEdge!]!
    nodes: [PolarisSnapshot!]!
    pageInfo: PageInfo!
}

type PolarisSnapshotEdge {
    cursor: String!
    node: PolarisSnapshot!
}

"Polaris Snapshot data with groupby info applied to it."
type PolarisSnapshotGroupBy {
    "The data groupby info."
    groupByInfo: PolarisSnapshotGroupByInfo!
    "Paginated snapshot data."
    polarisSnapshotConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "sort polaris snapshots by field"
        sortBy: PolarisSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): PolarisSnapshotConnection!
    "Further provide groupings for the data."
    polarisSnapshotGroupBy(
        "group polaris snapshots by field"
        groupBy: PolarisSnapshotGroupByEnum!
    ): [PolarisSnapshotGroupBy!]!
}

type PolarisSnapshotGroupByConnection {
    count: Int!
    edges: [PolarisSnapshotGroupByEdge!]!
    nodes: [PolarisSnapshotGroupBy!]!
    pageInfo: PageInfo!
}

type PolarisSnapshotGroupByEdge {
    cursor: String!
    node: PolarisSnapshotGroupBy!
}

"Polaris Snapshot data with groupby info applied to it."
type PolarisSnapshotGroupByNew {
    "The data groupby info."
    groupByInfo: PolarisSnapshotGroupByInfo!
    "Paginated snapshot data."
    polarisSnapshotConnection: PolarisSnapshotConnection!
}

type PolarisSnapshotGroupByNewConnection {
    count: Int!
    edges: [PolarisSnapshotGroupByNewEdge!]!
    nodes: [PolarisSnapshotGroupByNew!]!
    pageInfo: PageInfo!
}

type PolarisSnapshotGroupByNewEdge {
    cursor: String!
    node: PolarisSnapshotGroupByNew!
}

type PolicyObj {
    allAnalyzerMappings(stdPath: String!): [AnalyzerMapping!]!
    fileResultConnection(after: String, before: String, filter: ListFileResultFiltersInput, first: Int, last: Int, sort: FileResultSortInput, timezone: String!): FileResultConnection!
    folderChildConnection(after: String, before: String, filter: BrowseDirectoryFiltersInput, first: Int, last: Int, sort: FileResultSortInput, stdPath: String!, timezone: String!): FileResultConnection!
    id: String!
    objectStatus: ObjectStatus!
    osType: DataGovOsTypeEnum!
    policySummaries: [ClassificationPolicySummary!]!
    rootFileResult: FileResult!
    shareType: DataGovShareTypeEnum!
    snappable: HierarchyObject!
    snapshotFid: String!
    snapshotTimestamp: Long!
    timeContext: String!
    whitelistedAnalyzerList(stdPath: String!): [WhitelistedAnalyzer!]!
}

type PolicyObjConnection {
    count: Int!
    edges: [PolicyObjEdge!]!
    nodes: [PolicyObj!]!
    pageInfo: PageInfo!
}

type PolicyObjEdge {
    cursor: String!
    node: PolicyObj!
}

type PolicyObjectUsage {
    hierarchyObject: HierarchyObject!
    policies: [ClassificationPolicySummary!]!
}

type PolicyObjectUsageConnection {
    count: Int!
    edges: [PolicyObjectUsageEdge!]!
    nodes: [PolicyObjectUsage!]!
    pageInfo: PageInfo!
}

type PolicyObjectUsageEdge {
    cursor: String!
    node: PolicyObjectUsage!
}

type PolicyStatus {
    policyId: String!
    status: ObjectPolicyStatus!
}

"Describes a script that is run before / after snapshot or backup"
type PrePostScript {
    failureHandling: PrePostScriptFailureHandlingEnum!
    scriptPath: String!
    timeoutMs: Int!
}

type PrecheckFailure {
    cause: String!
    precheckName: String!
    remedy: String!
    upgradeBlocker: Boolean!
}

type PrecheckStatusNextRunInfo {
    jobInstanceId: String!
    startTime: Long!
    status: String!
}

type PrechecksJobReply {
    jobId: String!
}

type PrechecksStatusReply {
    endTime: Long!
    failureResults: [PrecheckFailure!]!
    nextRunInfo: PrecheckStatusNextRunInfo
    numPrechecks: Int!
    runPeriodInMinutes: Int!
}

type PreviewerClusterConfig {
    clusterId: String!
    enabled: Boolean!
}

"Ldap Principal"
type Principal {
    authDomainId: String!
    description: String
    email: String
    id: String!
    name: String!
    principalType: PrincipalTypeEnum!
}

type PrincipalConnection {
    count: Int!
    edges: [PrincipalEdge!]!
    nodes: [Principal!]!
    pageInfo: PageInfo!
}

type PrincipalEdge {
    cursor: String!
    node: Principal!
}

"Metadata for rendering protected objects."
type ProtectedObjects implements ProtectedObjectSummary {
    effectiveSlaOpt: String
    id: String!
    isArchived: Boolean!
    name: String!
    objectType: ManagedObjectType
}

type ProtectedObjectsConnection {
    count: Int!
    edges: [ProtectedObjectsEdge!]!
    nodes: [ProtectedObjects!]!
    pageInfo: PageInfo!
}

type ProtectedObjectsEdge {
    cursor: String!
    node: ProtectedObjects!
}

type ProtectionStatus {
    enumValue: ProtectionStatusEnum!
}

type ProtectionTaskDetailsTableFilter {
    cluster_location: [FilterOption!]!
    cluster_type: [FilterOption!]!
    object_type: [FilterOption!]!
    replication_source: [FilterOption!]!
    status: [FilterOption!]!
    task_category: [FilterOption!]!
    task_type: [FilterOption!]!
}

"Proxy Settings for Target"
type ProxySettings {
    portNumber: Int!
    protocol: String!
    proxyServer: String!
    username: String!
}

type QuarterlySnapshotSchedule {
    basicSchedule: BasicSnapshotSchedule
    dayOfQuarter: DayOfQuarterEnum!
    quarterStartMonth: MonthEnum!
}

type Query {
    AwsCloudAccountListKMSKeys(
        "The id of the cloud account"
        cloudAccountUuid: UUID!,
        "Cloud Account Feature."
        feature: CloudAccountFeatureEnum!,
        "aws region argument for archival use case"
        region: AwsRegionEnum!
    ): AwsCloudAccountListKMSKeysResponse!
    AwsCloudAccountListSecurityGroups(
        "The id of the cloud account"
        cloudAccountUuid: UUID!,
        "Cloud Account Feature."
        feature: CloudAccountFeatureEnum!,
        "aws region argument for archival use case"
        region: AwsRegionEnum!,
        "vpc native id"
        vpcID: String!
    ): AwsCloudAccountListSecurityGroupsResponse!
    AwsCloudAccountListSubnets(
        "The id of the cloud account"
        cloudAccountUuid: UUID!,
        "Cloud Account Feature."
        feature: CloudAccountFeatureEnum!,
        "aws region argument for archival use case"
        region: AwsRegionEnum!,
        "vpc native id"
        vpcID: String!
    ): AwsCloudAccountListSubnetsResponse!
    AwsCloudAccountListVpcs(
        "The id of the cloud account"
        cloudAccountUuid: UUID!,
        "Cloud Account Feature."
        feature: CloudAccountFeatureEnum!,
        "aws region argument for archival use case"
        region: AwsRegionEnum!
    ): AwsCloudAccountListVpcResponse!
    "Returns a list of availability zones in the specified region on the specified AWS account"
    GetAvailabilityZonesFromAws(awsNativeAccountId: UUID!, region: AwsNativeRegionEnum!): GetAvailabilityZonesFromAwsReply!
    "This endpoint is deprecated."
    accountSettings: AccountSetting!
    activeCustomAnalyzerConnection: AnalyzerConnection!
    activitySeries(
        "The id of the activity series"
        activitySeriesId: UUID!,
        "The id of the cluster"
        clusterUuid: UUID!
    ): ActivitySeries!
    activitySeriesConnection(
        after: String,
        before: String,
        filters: ActivitySeriesFilterInput,
        first: Int,
        last: Int,
        "sort activity series by field"
        sortBy: ActivitySeriesSortByEnum = LastUpdated,
        "activity sort order"
        sortOrder: SortOrderEnum = Desc
    ): ActivitySeriesConnection!
    activitySeriesGroupByConnection(
        after: String,
        before: String,
        filters: ActivitySeriesFilterInput,
        first: Int,
        "group activity series by a field"
        groupBy: ActivitySeriesGroupByEnum!,
        last: Int,
        timezoneOffset: Float = 0.0
    ): ActivitySeriesGroupByConnection!
    "Return AD objects"
    adObjectsConnection(after: String, commonNames: [String!], first: Int, objectCategories: [String!], objectSids: [String!]): ADObjectConnection!
    allClusterConnection(
        after: String,
        before: String,
        filter: ClusterFilterInput,
        first: Int,
        last: Int,
        "sort clusters by field"
        sortBy: ClusterSortByEnum = ClusterType,
        "cluster sort order"
        sortOrder: SortOrderEnum = Desc
    ): ClusterConnection!
    allReportConfigs(dataView: DataViewTypeEnum): [ReportConfig!]!
    allUsersOnAccountConnection(
        after: String,
        before: String,
        emailFilter: String,
        first: Int,
        last: Int,
        roleIdsFilter: [UUID!],
        sortBy: UserFieldEnum = Email,
        "sort order"
        sortOrder: SortOrderEnum
    ): UserConnection!
    allVpcsInRegion(awsNativeAccountId: UUID!, region: AwsNativeRegionEnum!): [AwsVpc!]!
    analyzerGroupConnection: AnalyzerGroupConnection!
    "Returns which policies are using each analyzer"
    analyzerUsageConnection: AnalyzerUsageConnection!
    anomalyResult(
        "The id of the cluster"
        clusterUuid: UUID!,
        "Corresponds to snapshot ID in CDM tables"
        snapshotId: String!
    ): AnomalyResult!
    anomalyResultConnection(
        after: String,
        before: String,
        "filter anomaly results by input"
        filter: AnomalyResultFilterInput,
        first: Int,
        last: Int,
        "sort anomaly results by field"
        sortBy: AnomalyResultSortByEnum,
        "sort order"
        sortOrder: SortOrderEnum,
        timezoneOffset: Float = 0.0
    ): AnomalyResultConnection!
    anomalyResultGroupByConnection(
        after: String,
        before: String,
        "filter anomaly results by input"
        filter: AnomalyResultFilterInput,
        first: Int,
        "group anomaly results by field"
        groupBy: AnomalyResultGroupByEnum!,
        last: Int,
        timezoneOffset: Float = 0.0
    ): AnomalyResultGroupByConnection!
    anomalyResultOpt(
        "The id of the cluster"
        clusterUuid: UUID!,
        "Corresponds to snapshot ID in CDM tables"
        snapshotId: String!
    ): AnomalyResult
    appBlueprintOngoingFailoverTaskchainUuids(fids: [UUID!]!): GetAppBlueprintOngoingFailoverTaskchainUuidsRsp!
    "deprecated - list the recovery specs associated with the given appblueprint"
    appBlueprintRecoverySpecs(
        "the fid of the app blueprint"
        appBlueprintId: UUID!
    ): AppBlueprintSnappableRecoverySpec!
    "deprecated - describes the App Blueprint resource specs"
    appBlueprintResourceSpec(
        "the fid of the app blueprint"
        appBlueprintId: UUID!
    ): AppBlueprintResourceSpec!
    appBlueprintSnapshotImageInfos(appSnapshotFids: [UUID!]!): GetAppBlueprintSnapshotCloudImagesRsp!
    "describes the App Blueprint snapshot resource specs"
    appBlueprintSnapshotResourceSpec(
        "the fid of the snapshot"
        snapshotId: UUID!
    ): [ResourceSpec!]!
    "Get aws cloud account by ID."
    awsCloudAccount(
        "Arguments for get cloud account."
        awsCloudAccountArg: AwsCloudAccountGetAccountInput!,
        "The id of the cloud account"
        cloudAccountUuid: UUID!
    ): AwsCloudAccountGetAccountResponse!
    "Get all active aws cloud accounts."
    awsCloudAccounts(
        "Arguments for get cloud accounts."
        awsCloudAccountsArg: AwsCloudAccountsInput!
    ): AwsCloudAccountGetAccountsResponse!
    awsComputeSettings(
        "Corresponds to Compute Setting Id in Polaris tables"
        computeSettingId: UUID!
    ): AwsComputeSettings!
    awsComputeSettingsList(
        "Specification on what context filter to use"
        contextFilter: ContextFilterTypeEnum,
        "Specification on how to filter a list of compute settings"
        filter: [AwsCloudComputeSettingFilterInput!],
        "Specification on how to sort a list of compute settings"
        sortBy: AwsCloudComputeSettingSortByFieldEnum,
        "sort order"
        sortOrder: SortOrderEnum
    ): [AwsComputeSettings!]!
    "List AWS Exocompute configs with given search query."
    awsExocomputeConfigs(
        "Search query provided by user on exocompute list page. It will search for exocompute configs whose account name or account native ID is prefixed by search query."
        AwsExocomputeSearchQueryArg: String!
    ): AwsExocomputeConfigsResponse!
    awsNativeAccount(awsNativeProtectionFeature: AwsNativeProtectionFeatureEnum!, fid: UUID!): AwsNativeAccount!
    awsNativeAccountConnection(
        accountFilters: AwsNativeAccountFilters,
        after: String,
        authorizedOperationFilter: OperationEnum,
        awsNativeProtectionFeature: AwsNativeProtectionFeatureEnum!,
        before: String,
        first: Int,
        last: Int,
        "Sort fields for list of AWS accounts."
        sortBy: AwsNativeAccountSortFieldsEnum,
        sortOrder: HierarchySortOrder
    ): AwsNativeAccountConnection!
    awsNativeEbsVolume(fid: UUID!): AwsNativeEbsVolume!
    awsNativeEbsVolumeConnection(
        after: String,
        before: String,
        ebsVolumeFilters: AwsNativeEbsVolumeFilters,
        first: Int,
        last: Int,
        "Sort fields for list of AWS EBS volumes."
        sortBy: AwsNativeEbsVolumeSortFieldsEnum,
        sortOrder: HierarchySortOrder
    ): AwsNativeEbsVolumeConnection!
    awsNativeEc2Instance(fid: UUID!): AwsNativeEc2Instance!
    awsNativeEc2InstanceConnection(
        after: String,
        before: String,
        ec2InstanceFilters: AwsNativeEc2InstanceFilters,
        first: Int,
        last: Int,
        "Sort fields for list of AWS EC2 instances."
        sortBy: AwsNativeEc2InstanceSortFieldsEnum,
        sortOrder: HierarchySortOrder
    ): AwsNativeEc2InstanceConnection!
    awsNativeRdsInstance(fid: UUID!): AwsNativeRdsInstance!
    awsNativeRdsInstanceConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        rdsInstanceFilters: AwsNativeRdsInstanceFilters,
        "Sort fields for list of AWS RDS instances."
        sortBy: AwsNativeRdsInstanceSortFieldsEnum,
        sortOrder: HierarchySortOrder
    ): AwsNativeRdsInstanceConnection!
    "Returns the list of Vpcs in the AWS account"
    awsNativeVpcs(awsNativeAccountId: UUID): [AwsVpc!]!
    "Check the permissions on Azure subscriptions and pass the missing permissions."
    azureCheckPermissionsOnSubscription(
        "The cloud account action"
        cloudAccountAction: CloudAccountActionEnum!,
        "Session ID of the current OAuth session."
        sessionId: String!,
        "List of subscription Ids."
        subscriptionIds: [UUID!]!
    ): [AzureCheckPermissionsOnSubscriptionResponse!]!
    "Get the details of the Azure tenant and all subscriptions in it configured for a feature"
    azureCloudAccountTenant(
        "Cloud Account Feature."
        feature: CloudAccountFeatureEnum!,
        "Search text for subscription name and native id."
        subscriptionSearchText: String!,
        "List of subscription status filters to apply."
        subscriptionStatusFilters: [CloudAccountStatusEnum!]!,
        "Tenant ID of the Azure tenant."
        tenantId: UUID!
    ): AzureCloudAccountTenant!
    "List all the tenant domain names of all the tenantswhich are ever configured for any feature."
    azureCloudAccountTenantDomainNames: [String!]!
    "List all the Azure tenants and the subscriptions in them configured for a feature filtered based on feature status, subscription native id and name."
    azureCloudAccountTenants(
        "Cloud Account Feature."
        feature: CloudAccountFeatureEnum!,
        "Should the details of subscriptions in the tenants be included in response."
        includeSubscriptionDetails: Boolean!
    ): [AzureCloudAccountTenant!]!
    "Lists supported disk types when exporting a particular snapshot."
    azureNativeExportCompatibleDiskTypes(
        "The azure region."
        region: AzureNativeRegionEnum!,
        "Subscription ID"
        subscriptionId: UUID!
    ): [AzureNativeDiskTypesForAvailabilityZone!]!
    "Lists supported VM sizes when exporting a particular snapshot."
    azureNativeExportCompatibleVMSizes(
        "The azure region."
        region: AzureNativeRegionEnum!,
        "Subscription ID"
        subscriptionId: UUID!,
        "Snapshot ID"
        vmSnapshotId: UUID!
    ): [AzureNativeVMSizesForAvailabilityZone!]!
    "Get details of an Azure Managed Disk"
    azureNativeManagedDisk(fid: UUID!): AzureNativeManagedDisk!
    "Get list of Azure Managed Disks"
    azureNativeManagedDiskConnection(
        after: String,
        before: String,
        diskFilters: AzureNativeDiskFilters,
        first: Int,
        last: Int,
        "Sort fields for list of Azure disks."
        sortBy: AzureNativeDiskSortFieldsEnum,
        sortOrder: HierarchySortOrder
    ): AzureNativeManagedDiskConnection!
    "Get details of an Azure Resource Group"
    azureNativeResourceGroup(
        "VM Resource group ID or Disk resource group ID"
        resourceGroupId: UUID!
    ): AzureNativeResourceGroup!
    "Lists Azure resource groups"
    azureNativeResourceGroupList(
        resourceGroupFilters: AzureNativeResourceGroupFilters,
        "Sort fields for list of Azure resource groups."
        sortBy: AzureNativeVMResourceGroupSortFieldsEnum,
        sortOrder: HierarchySortOrder
    ): [AzureNativeResourceGroup!]!
    "Lists security groups in the specified regionand subscription."
    azureNativeSecurityGroups(
        "The azure region."
        region: AzureNativeRegionEnum!,
        "Subscription ID"
        subscriptionId: UUID!
    ): [AzureNativeSecurityGroup!]!
    "Lists all VM sizes in the protected subscriptions."
    azureNativeStoredVmSizes(
        "Subscription ID"
        subscriptionId: UUID
    ): [String!]!
    "Lists all virtual networks in the protected subscriptions."
    azureNativeStoredVnets(
        "Subscription ID"
        subscriptionId: UUID
    ): [AzureNativeVnet!]!
    "Lists subnets in the specified region andsubscription."
    azureNativeSubnets(
        "The azure region."
        region: AzureNativeRegionEnum!,
        "Subscription ID"
        subscriptionId: UUID!
    ): [AzureNativeSubnet!]!
    "Get details of an Azure Subscription"
    azureNativeSubscription(fid: UUID!): AzureNativeSubscription!
    "Get list of Azure subscriptions"
    azureNativeSubscriptionConnection(
        after: String,
        "Filters according to the operation given."
        authorizedOperationFilter: OperationEnum,
        before: String,
        first: Int,
        last: Int,
        "Sort fields for list of Azure subscriptions."
        sortBy: AzureNativeSubscriptionSortFieldsEnum,
        sortOrder: HierarchySortOrder,
        subscriptionFilters: AzureNativeSubscriptionFilters
    ): AzureNativeSubscriptionConnection!
    "Get details of an Azure Virtual Machine"
    azureNativeVirtualMachine(fid: UUID!): AzureNativeVirtualMachine!
    "Get list of Azure Virtual Machines"
    azureNativeVirtualMachineConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "Sort fields for list of Azure virtual machines."
        sortBy: AzureNativeVirtualMachineSortFieldsEnum,
        sortOrder: HierarchySortOrder,
        virtualMachineFilters: AzureNativeVirtualMachineFilters
    ): AzureNativeVirtualMachineConnection!
    azureO365CheckNSGOutboundRules(resourceGroupName: String!, subnet_name: String!, subscriptionId: UUID!, tenantId: String!, vnet_name: String!): AzureNetworkSecurityGroupResp!
    azureO365CheckNetworkSubnet(resourceGroupName: String!, strict_addr_check: Boolean!, subnet_name: String!, subscriptionId: UUID!, tenantId: String!, vnet_name: String!): AzureNetworkSubnetResp!
    azureO365CheckResourceGroupName(groupName: String!, subscriptionId: UUID!, tenantId: String!): AzureResourceAvailabilityResp!
    azureO365CheckStorageAccountAccessibility(groupName: String!, storage_account_name: String!, subscriptionId: UUID!, tenantId: String!): AzureResourceAvailabilityResp!
    azureO365CheckStorageAccountName(storage_account_name: String!, subscriptionId: UUID!, tenantId: String!): AzureResourceAvailabilityResp!
    azureO365CheckSubscriptionQuota(regionName: String!, subscriptionId: UUID!, tenantId: String!): AzureResourceAvailabilityResp!
    azureO365CheckVirtualNetworkName(groupName: String!, subscriptionId: UUID!, tenantId: String!, vnet_name: String!): AzureResourceAvailabilityResp!
    azureO365Exocompute(exocomputeClusterId: String!, orgId: UUID!): GetAzureO365ExocomputeResp!
    azureO365GetNetworkSubnetUnusedAddr(resourceGroupName: String!, strict_addr_check: Boolean!, subnet_name: String!, subscriptionId: UUID!, tenantId: String!, vnet_name: String!): AzureNetworkSubnetUnusedAddrResp!
    azureO365ValidateUserRoles(subscriptionId: UUID!, tenantId: String!): AzureUserRoleResp!
    azureRegions(subscriptionId: UUID!, tenantId: String!): RegionConnection!
    azureResourceGroups(subscriptionId: UUID!, tenantId: String!): ResourceGroupConnection!
    azureStorageAccounts(regionName: String!, subscriptionId: UUID!, tenantId: String!): StorageAccountConnection!
    azureSubnets(subscriptionId: UUID!, tenantId: String!, vNetId: String!): SubnetConnection!
    azureSubscriptions(tenantId: String!): AzureSubscriptionConnection!
    azureVNets(regionName: String!, subscriptionId: UUID!, tenantId: String!): VNetConnection!
    blueprint(fid: UUID!): Blueprint!
    blueprintConnection(after: String, filter: [Filter!], first: Int, sortBy: HierarchySortByField, sortOrder: HierarchySortOrder): BlueprintConnection!
    "list the recovery specs associated with the given blueprint"
    blueprintRecoverySpecs(
        "Flag to represent if pending recovery specs should be returned or not"
        IncludePendingRecoverySpec: Boolean,
        "the fid of the app blueprint"
        appBlueprintId: UUID!,
        "the fid of the app blueprint snapshot"
        appBlueprintSnapshotId: UUID,
        "Flag to represent if the invalid recovery specs should be ignored"
        ignoreInvalidRecoverySpecs: Boolean,
        "Flag to represent if list recovery spec should be validated with resource spec"
        shouldValidateRecoverySpec: Boolean
    ): [AppBlueprintRecoverySpecMap!]!
    "list the recovery specs associated with the given blueprint"
    blueprintRecoverySpecsMap(
        "Flag to represent if pending recovery specs should be returned or not"
        IncludePendingRecoverySpec: Boolean,
        "the fid of the app blueprint"
        appBlueprintId: UUID!,
        "the fid of the app blueprint snapshot"
        appBlueprintSnapshotId: UUID,
        "Flag to represent if the invalid recovery specs should be ignored"
        ignoreInvalidRecoverySpecs: Boolean,
        "Flag to represent if list recovery spec should be validated with resource spec"
        shouldValidateRecoverySpec: Boolean
    ): BlueprintRecoverySpecReply!
    "describes the Blueprint resource specs"
    blueprintResourceSpec(
        "the fid of the app blueprint"
        appBlueprintId: UUID!,
        "the fid of the app blueprint snapshot"
        appBlueprintSnapshotId: UUID
    ): [ResourceSpec!]!
    browseCalendar(after: String, first: Int, folderId: String!, orgId: UUID!, snappableFid: UUID!, snapshotFid: UUID!): O365ExchangeObjectConnection!
    "List all files and directories in a given pathwith the given prefix in name"
    browseCloudNativeSnapshotConnection(
        after: String,
        first: Int,
        "The path under which you want your search to run"
        path: String!,
        "Name prefix for searching for files within a snapshot"
        searchPrefix: String,
        "Id of the snapshot to be searched/browsed"
        snapshotFid: UUID!
    ): SnapshotFileConnection!
    "Browse diff fmd under given path"
    browseDiffFmd(
        "root path to browse changes of fmd"
        browseDiffPath: String!,
        "The id of the cluster"
        clusterUuid: UUID!,
        "Snappable managed ID"
        managedId: String!,
        "Corresponds to snapshot ID in CDM tables"
        snapshotId: String!
    ): DiffFMDReply!
    browseEmailFolder(after: String, first: Int, folderId: String!, orgId: UUID!, snappableFid: UUID!, snapshotFid: UUID!): O365ExchangeObjectConnection!
    browseFilesetSnapshot(
        "ID of snapshot"
        id: String!,
        "Maximum number of entries in the response."
        limit: Int,
        "Starting position in the list of path entries contained in the query results, sorted by lexicographical order. The response includes the specified numbered entry and all higher numbered entries."
        offset: Int,
        "The absolute path of the starting point for the directory listing."
        path: String!
    ): BrowseResponseListResponse!
    browseFolder(after: String, first: Int, folderId: String!, orgId: UUID!, snappableFid: UUID!, snapshotFid: UUID!): O365ExchangeObjectConnection!
    browseOnedrive(after: String, first: Int, folderId: String, onedriveSearchFilter: OnedriveSearchFilter, orgId: UUID!, snappableFid: UUID!, snapshotFid: UUID!): O365OnedriveObjectConnection!
    "Returns a list files whose name is prefixed by the query in the given snapshot"
    browseSnapshotFileConnection(
        after: String,
        first: Int,
        "The path under which you want your search to run"
        path: String!,
        "Prefix arg for searching for files within a snapshot"
        searchPrefix: String,
        "Corresponds to snapshot forever UUID in Polaris tables"
        snapshotFid: UUID!
    ): SnapshotFileConnection!
    cdmHierarchySnappableNew(snappableFid: UUID!): CdmHierarchySnappableNew!
    cdmHierarchySnappablesNew(fids: [UUID!]!): [CdmHierarchySnappableNew!]!
    cdmInventorySubHierarchyRoot(rootEnum: InventorySubHierarchyRootEnum!): CdmInventorySubHierarchyRoot!
    "Check if label rule name is unique or not"
    checkCloudNativeLabelRuleNameUniqueness(
        "Type of managed object on which label rule will be applied"
        objectType: CloudNativeLabelObjectType!,
        "Name for the rule"
        ruleName: String!
    ): IsCloudNativeTagRuleNameUniqueReply!
    "Check if tag rule name is unique or not"
    checkCloudNativeTagRuleNameUniqueness(
        "Type of managed object on which tag rule will be applied"
        objectType: CloudNativeTagObjectType!,
        "Name for the rule"
        ruleName: String!
    ): IsCloudNativeTagRuleNameUniqueReply!
    "check the child vm guestOS for given app blueprint"
    checkGuestOsForAppBlueprint(
        "the fid of the app blueprint"
        appBlueprintId: UUID!
    ): CheckGuestOsReply!
    "Checks whether a s3 bucket name is available or not"
    checkS3BucketNameAvailable(awsNativeAccountId: UUID!, bucketName: String!): Boolean!
    cloudAccount(
        "Corresponds to Cloud Account Id in Polaris tables"
        cloudAccountId: UUID!
    ): CloudAccount!
    cloudAccountList(
        "Filters and shows cloud accounts for a specific use-case or feature. Default value: ARCHIVAL"
        feature: CloudAccountFeatureEnum,
        filter: [CloudAccountFilterInput!],
        sortBy: CloudAccountSortByFieldEnum,
        "sort order"
        sortOrder: SortOrderEnum
    ): [CloudAccount!]!
    "Queries whether Polaris has the required permissions for a particular feature."
    cloudNativeCheckRequiredPermissionsForFeature(
        "Cloud native account ID"
        cloudNativeAccountId: String!,
        "Feature for which required permissions have to be checked."
        featurePermissionCheck: CloudNativeFeatureForPermissionsCheck!
    ): Boolean!
    "Returns a list of cloud native label keys matched by substring"
    cloudNativeLabelKeys(
        "key substring for which you want to search keys"
        keySubStr: String!,
        "number of results to return"
        limit: Int!,
        "Type of managed object on which label rule will be applied"
        objectType: CloudNativeLabelObjectType!
    ): [String!]!
    "Returns a list of cloud native label values matched by substring"
    cloudNativeLabelValues(
        "key value used only when searching for values"
        key: String!,
        "number of results to return"
        limit: Int!,
        "Type of managed object on which label rule will be applied"
        objectType: CloudNativeLabelObjectType!,
        "value substring for which you want to search values"
        valueSubStr: String!
    ): [String!]!
    "Returns a list of cloud native tag keys matched by substring"
    cloudNativeTagKeys(
        "key substring for which you want to search keys"
        keySubStr: String!,
        "number of results to return"
        limit: Int!,
        "Type of managed object on which tag rule will be applied"
        objectType: CloudNativeTagObjectType!
    ): [String!]!
    "Returns a list of cloud native tag values matched by substring"
    cloudNativeTagValues(
        "key value used only when searching for values"
        key: String!,
        "number of results to return"
        limit: Int!,
        "Type of managed object on which tag rule will be applied"
        objectType: CloudNativeTagObjectType!,
        "value substring for which you want to search values"
        valueSubStr: String!
    ): [String!]!
    clusterConnection(
        after: String,
        before: String,
        filter: ClusterFilterInput,
        first: Int,
        last: Int,
        "sort clusters by field"
        sortBy: ClusterSortByEnum = ClusterType,
        "cluster sort order"
        sortOrder: SortOrderEnum = Desc
    ): ClusterConnection!
    clusterGroupByConnection(
        after: String,
        before: String,
        filter: ClusterFilterInput,
        first: Int,
        "group by field"
        groupBy: ClusterGroupByEnum!,
        last: Int,
        timezoneOffset: Float = 0.0
    ): ClusterGroupByConnection!
    clusterGroupByUpgradeInfo(
        after: String,
        before: String,
        first: Int,
        "group by field"
        groupBy: UpgradeInfoGroupByEnum!,
        last: Int,
        timezoneOffset: Float = 0.0,
        upgradeFilter: CdmUpgradeInfoFilterInput
    ): UpgradeInfoGroupByConnection!
    clusterSlaDomainConnection(after: String, before: String, first: Int, last: Int): ClusterSlaDomainConnection!
    clusterSlaDomainFilterConnection(after: String, before: String, first: Int, last: Int): ClusterSlaDomainForFilterConnection!
    clusterTypeList: [GroupCount!]!
    clusterWithUpgradesInfo(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "sort upgradeInfo by field"
        sortBy: UpgradeInfoSortByEnum = ClusterType,
        "cluster sort order"
        sortOrder: SortOrderEnum = Desc,
        upgradeFilter: CdmUpgradeInfoFilterInput
    ): ClusterConnection!
    connectedClusterList(
        "Specification to filter cluster based on type"
        clusterFilterArg: ClusterTypeEnum
    ): [DataLocationSupportedCluster!]!
    countOfObjectsProtectedBySlas(
        filter: [Filter!],
        "Corresponds to optional object root forever UUID, none value is assumed to be the global hierarchy root"
        rootOptionalFid: UUID,
        "Provide list of Global SLA ids"
        slaIds: [UUID!]!,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): CountOfObjectsProtectedBySLAsResult!
    "Return details for one crawl"
    crawl(crawlId: String!): Crawl!
    "Return crawls for an account"
    crawlConnection: CrawlConnection!
    currentIpAddress: String!
    currentUser: User!
    customAnalyzer(analyzerId: String!): Analyzer!
    "Return hits grouped by analyzer and policy"
    dashboardSummary(getWhitelistedResults: Boolean!): GetDashboardSummaryReply!
    "Return datagov audit config records"
    datagovAuditCfgConnection(after: String, datagovAuditCfgId: String!, first: Int): DatagovAuditCfgConnection!
    "Return file activity records for user"
    datagovFileActivityForUser(
        after: String,
        before: String,
        datagovAuditCfgId: String!,
        "End time of the range (in milliseconds since epoch)"
        endTimeMs: Long!,
        first: Int,
        last: Int,
        "File or dir object to query activity for"
        objectName: String!,
        "Security identifier for user, group in Windows"
        sid: String!,
        "Begin time of the range (in milliseconds since epoch)"
        startTimeMs: Long!
    ): DatagovFileActivityConnection!
    "Return file activity records"
    datagovFileAuditConnection(
        after: String,
        before: String,
        datagovAuditCfgId: String!,
        "End time of the range (in milliseconds since epoch)"
        endTimeMs: Long!,
        first: Int,
        last: Int,
        "File or dir object to query activity for"
        objectName: String!,
        "Begin time of the range (in milliseconds since epoch)"
        startTimeMs: Long!
    ): DatagovFileActivityConnection!
    "Return file audit summary by user"
    datagovFileAuditSummaryByUser(
        after: String,
        before: String,
        datagovAuditCfgId: String!,
        "End time of the range (in milliseconds since epoch)"
        endTimeMs: Long!,
        first: Int,
        last: Int,
        "File or dir object to query activity for"
        objectName: String!,
        "Begin time of the range (in milliseconds since epoch)"
        startTimeMs: Long!
    ): ActivitySummaryByUserConnection!
    "Return permissions associated with a path"
    datagovSecDesc(
        "Skip converting SIDs in response to friendly names"
        skipResolveSids: Boolean,
        snappableFid: String!,
        snapshotFid: String!,
        stdPath: String!
    ): QuerySDDLReply!
    "Return user activity records"
    datagovUserAuditConnection(
        after: String,
        before: String,
        datagovAuditCfgId: String!,
        "End time of the range (in milliseconds since epoch)"
        endTimeMs: Long!,
        first: Int,
        last: Int,
        "Security identifier for user, group in Windows"
        sid: String!,
        "Begin time of the range (in milliseconds since epoch)"
        startTimeMs: Long!
    ): DatagovUserActivityConnection!
    "Return timeline data for all policies of an account"
    discoveryTimeline(endDay: String!, getWhitelistedResults: Boolean!, startDay: String!, timezone: String!): GetPoliciesTimelineReply!
    "Download cdm upgrades table pdf"
    downloadCdmUpgradesPdf(
        "Filters for cdm upgrades page for pdf generation"
        downloadFilter: DownloadCdmUpgradesPdfFiltersInput
    ): DownloadCdmUpgradesPdfReply!
    "Get Status of download package job"
    downloadPackageStatus(
        "Cluster uuid"
        clusterUuid: UUID!
    ): DownloadPackageStatusReply!
    downloadReportCSVAsync(config: CustomReportCreate, id: Int!): AsyncDownloadReply!
    downloadReportLink(config: CustomReportCreate, id: Int!): DownloadLink!
    downloadReportPDFAsync(config: CustomReportCreate, id: Int!): AsyncDownloadReply!
    downloadReportPDFLink(config: CustomReportCreate, id: Int!): DownloadLink!
    downloadedVersionList: [GroupCount!]!
    dummyFieldWithAdminOnlyTag: Boolean!
    ec2Blueprint(fid: UUID!): Ec2Blueprint!
    eventDigest(recipientUserIDs: [String!]!): [EventDigest!]!
    "failover"
    failover(
        "failover ID"
        failoverId: String!
    ): Failover
    failoverAllSourceConnection(after: String, before: String, first: Int, last: Int): FailoverSourceConnection!
    failoverAllTargetSiteConnection(after: String, before: String, first: Int, last: Int): FailoverTargetSiteConnection!
    failoverConnection(
        after: String,
        before: String,
        "filter appflows failover jobs by input"
        filter: FailoverFilterInput,
        first: Int,
        last: Int,
        "sort appflows failover jobs by field"
        sortBy: FailoverSortByEnum = AppBlueprintName,
        "failover jobs sort order"
        sortOrder: SortOrderEnum = Desc,
        timezoneOffset: Float = 0.0
    ): FailoverConnection!
    failoverGroupByConnection(
        after: String,
        before: String,
        "filter appflows failover jobs by input"
        filter: FailoverFilterInput,
        first: Int,
        "group appflows failover jobs by a field"
        groupBy: FailoverGroupByEnum!,
        last: Int,
        timezoneOffset: Float = 0.0
    ): FailoverGroupByConnection!
    "Evaluate a single feature flag and get the result"
    featureFlag(
        "List of flag names to evaluate"
        entityContext: [FeatureFlagContextField!],
        "The type of entity context to evaluate against. The value of this arg determines how the entity ID is inferred."
        entityType: FeatureFlagEntityTypeEnum!,
        "Name of flag to evaluate"
        flagName: FeatureFlagNameEnum!
    ): FeatureFlag!
    "Evaluate all known feature flags."
    featureFlagAll(
        "List of flag names to evaluate"
        entityContext: [FeatureFlagContextField!],
        "The type of entity context to evaluate against. The value of this arg determines how the entity ID is inferred."
        entityType: FeatureFlagEntityTypeEnum!
    ): FeatureFlagAll!
    "Get names of feature flags that surfaced in APIs"
    featureFlagNames: [String!]!
    filesetSnapshot(
        "ID of snapshot"
        id: String!,
        "Whether or not to fetch verbose fileset snapshot information. The performance of this endpoint will decrease if set to true."
        verbose: Boolean
    ): FilesetSnapshotDetail!
    filesetTemplate(fid: UUID!): FilesetTemplate!
    filesetTemplateConnection(
        after: String,
        filter: [Filter!],
        first: Int,
        "host root type"
        hostRoot: HostRoot!,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): FilesetTemplateConnection!
    "Check Gcp Projects permissions for addition."
    gcpCloudAccountCheckProjectPermissionsForAddition(
        "List of Gcp project native Ids."
        projectIds: [String!]!,
        "Session ID of the current OAuth session."
        sessionId: String!
    ): [GcpCloudAccountMissingPermissionsForAddition!]!
    "Get the details of the Gcp project configured for a feature"
    gcpCloudAccountListProjects(
        "Cloud Account Feature."
        feature: CloudAccountFeatureEnum!,
        "Search text for project name, native id and number."
        projectSearchText: String!,
        "List of project status filters to apply."
        projectStatusFilters: [CloudAccountStatusEnum!]!
    ): [GcpCloudAccountProjectDetail!]!
    "List Gcp Projects to add after successful authorization."
    gcpCloudAccountListProjectsForOAuth(
        "Whether to check permission of projects required for addition"
        checkPermissions: Boolean!,
        "Cloud Account Features."
        features: [CloudAccountFeatureEnum!]!,
        "Session ID of the current OAuth session."
        sessionId: String!
    ): [GcpListProjectsForOAuthResponse!]!
    "Lists compatible machine types for instance."
    gcpNativeCompatibleMachineTypesList(
        "UUID of snapshot"
        snapshotId: UUID!,
        "The zone of the to-be-created instance."
        targetZone: String!
    ): [String!]!
    "Get details of a GCP Disk"
    gcpNativeDisk(fid: UUID!): GcpNativeDisk!
    "Get list of GCP disks"
    gcpNativeDiskConnection(
        after: String,
        before: String,
        diskFilters: GcpNativeDiskFilters,
        first: Int,
        last: Int,
        "Sort fields for list of GCP disks."
        sortBy: GcpNativeDiskSortFieldsEnum,
        sortOrder: HierarchySortOrder
    ): GcpNativeDiskConnection!
    "Get details of a GCE Instance"
    gcpNativeGceInstance(fid: UUID!): GcpNativeGCEInstance!
    "Get list of GCE instances"
    gcpNativeGceInstanceConnection(
        after: String,
        before: String,
        first: Int,
        gceInstanceFilters: GcpNativeGceInstanceFilters,
        last: Int,
        "Sort fields for list of GCP GCE instances."
        sortBy: GcpNativeGCEInstanceSortFieldsEnum,
        sortOrder: HierarchySortOrder
    ): GcpNativeGCEInstanceConnection!
    "lists GCP KMS Crypto keys accessible in the provided region"
    gcpNativeListAvailableKMSCryptoKeys(
        "UUID of the Project"
        projectId: UUID!,
        "native name of GCP region"
        regionName: String!
    ): [KMSCryptoKey!]!
    "Lists networks available in a GCP project along with subnetworks and firewall rules."
    gcpNativeNetworksList(
        "UUID of the Project"
        projectId: UUID!
    ): [GcpNativeNetwork!]!
    "Get details of a GCP Project"
    gcpNativeProject(fid: UUID!): GcpNativeProject!
    "Get list of GCP projects"
    gcpNativeProjectConnection(
        after: String,
        authorizedOperationFilter: OperationEnum,
        before: String,
        first: Int,
        last: Int,
        projectFilters: GcpNativeProjectFilters,
        "provide optional snappable hierarchy for RBAC and SLA, none value is assumed to be All snappable hierarchy"
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        "Sort fields for list of GCP projects."
        sortBy: GcpNativeProjectSortFieldsEnum,
        sortOrder: HierarchySortOrder
    ): GcpNativeProjectConnection!
    "lists all the GCP projects with accessible networks in this service project"
    gcpNativeProjectsWithAccessibleNetworks(
        "UUID of the Project"
        projectId: UUID!
    ): [NetworkHostProject!]!
    "Lists regions available to a GCP project along with zones"
    gcpNativeRegionsList(
        "UUID of the Project"
        projectId: UUID!
    ): [GcpNativeRegion!]!
    "lists distinct regions and zones of the GCP disks stored with Polaris"
    gcpNativeStoredDiskLocations(
        "UUID of the Project (Optional)"
        projectId: UUID
    ): ListStoredDiskLocationsReply!
    "lists all the distinct machine types of the GCP instances stored with Polaris"
    gcpNativeStoredMachineTypes: [String!]!
    "lists all the distinct machine types of the GCP instances stored with Polaris"
    gcpNativeStoredMachineTypesInProject(
        "UUID of the Project"
        projectId: UUID!
    ): [String!]!
    "lists all the distinct network names of the GCP instances stored with Polaris"
    gcpNativeStoredNetworkNames: [String!]!
    "lists all the distinct network names of the GCP instances stored with Polaris"
    gcpNativeStoredNetworkNamesInProject(
        "UUID of the Project"
        projectId: UUID!
    ): [String!]!
    "lists all the distinct regions of the GCP instances stored with Polaris"
    gcpNativeStoredRegions: [String!]!
    "lists all the distinct regions of the GCP instances stored with Polaris"
    gcpNativeStoredRegionsInProject(
        "UUID of the Project"
        projectId: UUID!
    ): [String!]!
    geoLocationList: [GroupCount!]!
    "Obtain account settings value."
    getAccountSettingValue(
        "Name of component that uses ASP in account setting table"
        aspComponent: ComponentEnum!,
        "Name of parameter (ASP) in account setting table"
        aspName: String!
    ): ASPValue!
    getAllRolesInOrgConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        nameFilter: String,
        sortBy: RoleFieldEnum = Name,
        "sort order"
        sortOrder: SortOrderEnum
    ): RoleConnection!
    getAllTemplatesInOrgConnection(after: String, before: String, first: Int, last: Int, nameFilter: String): RoleTemplateConnection!
    getAllUsersOnAccount(after: String, before: String, first: Int, last: Int): [User!]!
    getAuthorizationsForGlobalResource: [OperationEnum!]!
    getAuthorizationsForObject(fid: UUID!): [OperationEnum!]!
    "Get CDM release details from support portal for a given list of clusters."
    getCdmReleaseDetailsForClusterFromSupportPortal(
        "Should fetch version details"
        fetchLinks: Boolean! = false,
        "Filter to include only those releases released after source version"
        filterAfterSource: Boolean! = false,
        "Should filter upgradeable versions"
        filterUpgradeable: Boolean! = true,
        "Prefix filter for available versions"
        filterVersion: String! = "",
        "List of cluster uuids"
        listClusterUuid: [UUID!]!,
        "Should show all versions"
        shouldShowAll: Boolean! = true,
        "sort order"
        sortOrder: SortOrderEnum
    ): CdmUpgradeReleaseDetailsFromSupportPortalReply!
    "Get CDM release details from support portal for a given list of clusters specific to a target version."
    getCdmReleaseDetailsForVersionFromSupportPortal(
        "Should fetch version details"
        fetchLinks: Boolean! = false,
        "Filter to include only those releases released after source version"
        filterAfterSource: Boolean! = false,
        "Should filter upgradeable versions"
        filterUpgradeable: Boolean! = true,
        "Prefix filter for available versions"
        filterVersion: String! = "",
        "List of cluster uuids"
        listClusterUuid: [UUID!]!,
        "Should show all versions"
        shouldShowAll: Boolean! = true,
        "sort order"
        sortOrder: SortOrderEnum
    ): CdmUpgradeReleaseDetailsFromSupportPortalReply!
    "Get available versions on support portal for a cluster"
    getCdmReleaseDetailsFromSupportPortal(
        "Should fetch version details"
        fetchLinks: Boolean! = false,
        "Filter to include only those releases released after source version"
        filterAfterSource: Boolean! = false,
        "Should filter upgradeable versions"
        filterUpgradeable: Boolean! = true,
        "Prefix filter for available versions"
        filterVersion: String! = "",
        "Number of nodes in the cluster"
        nodeCount: Long! = 4,
        "Platform type of the cluster"
        platform: String! = "",
        "Should show all versions"
        shouldShowAll: Boolean! = true,
        "sort order"
        sortOrder: SortOrderEnum,
        "Source version of the cluster"
        sourceVersion: String! = ""
    ): CdmUpgradeReleaseDetailsFromSupportPortalReply!
    "List of snapshots for which file recovery is available"
    getCloudNativeFileRecoveryEligibleSnapshots(
        "Snappable ID"
        snappableId: UUID!
    ): [String!]!
    "Get cloud native label rules"
    getCloudNativeLabelRules(
        "Fields and values according to which rules will be filtered"
        filters: [CloudNativeFilter!],
        "Type of managed object on which label rule will be applied"
        objectType: CloudNativeLabelObjectType!,
        sortBy: CloudNativeTagRuleSortByFieldsEnum,
        sortOrder: HierarchySortOrder
    ): GetCloudNativeLabelRulesReply!
    "Get cloud native tag rules"
    getCloudNativeTagRules(
        "Fields and values according to which rules will be filtered"
        filters: [CloudNativeFilter!],
        "Type of managed object on which tag rule will be applied"
        objectType: CloudNativeTagObjectType!,
        sortBy: CloudNativeTagRuleSortByFieldsEnum,
        sortOrder: HierarchySortOrder
    ): GetCloudNativeTagRulesReply!
    getClusterNodes(
        "The id of the cluster"
        clusterUuid: UUID!
    ): NodeStatusListResp!
    "Returns a list of encryption keys in the specified region on the specified AWS account"
    getEncryptionKeysForRegionFromAWS(awsNativeAccountId: UUID!, region: AwsNativeRegionEnum!): [KMSEncryptionKeyType!]!
    getGlobalManagerConnectivity(
        "The id of the cluster"
        clusterUuid: UUID!
    ): String!
    getGroupCountByCdmClusterStatus: GroupCountListWithTotal!
    getGroupCountByPrechecksStatus: [GroupCount!]!
    getGroupCountByUpgradeJobStatus: [GroupCount!]!
    getGroupCountByVersionStatus: [GroupCount!]!
    getHostDiagnosis(
        "ID assigned to the host object"
        id: String!
    ): HostDiagnosisSummary!
    getKorgTaskchainStatus(taskchainId: String!): GetTaskchainStatusReply!
    "Returns the PIT restore window of the RDS DB instance in the aws account"
    getPITRestoreWindow(
        awsNativeAccountId: UUID!,
        "Name of the RDS DB Instance"
        rdsInstanceName: String!,
        region: AwsNativeRegionEnum!
    ): GetPITRestoreWindowReply!
    getPermissions(roleId: String!): [Permission!]!
    "Returns the default values for the export operation of the RDS DB instance in the AWS account"
    getRDSExportDefaultsFromAWS(
        "Whether the export of the instance is manual or point-in-time."
        isPointInTime: Boolean!,
        "ID of the RDS instance to be exported."
        rdsInstanceId: UUID!,
        "UUID of the snapshot if the export is manual."
        snapshotId: String
    ): RdsInstanceExportDefaults!
    "Returns the details of the RDS DB instance in the AWS account"
    getRDSInstanceDetailsFromAWS(
        awsNativeAccountId: UUID!,
        "Name of the RDS DB Instance"
        rdsInstanceName: String!,
        region: AwsNativeRegionEnum!
    ): GetRdsInstanceDetailsFromAWSReply!
    getRolesByIds(roleIds: [String!]!): [Role!]!
    getSupportTunnelStatus(
        "The id of the cluster"
        clusterUuid: UUID!,
        nodeId: String!
    ): SupportTunnelInfoResp!
    getUserDownloads(after: String, before: String, first: Int, last: Int): [UserDownload!]!
    globalSearchConnection(after: String, before: String, filter: [Filter!], first: Int, last: Int, sortBy: HierarchySortByField, sortOrder: HierarchySortOrder): HierarchyObjectConnection!
    globalSla(
        "Corresponds to global SLA forever UUID in Polaris tables"
        globalSlaFid: UUID!,
        "Whether or not to show the Global SLA sync status on CDM"
        showSyncStatus: Boolean
    ): SlaDomain!
    globalSlaConnection(
        after: String,
        before: String,
        "Specification on what context filter to use"
        contextFilter: ContextFilterTypeEnum,
        "Specification on what context filter input to use"
        contextFilterInput: [ContextFilterInputField!],
        filter: [GlobalSlaFilterInput!],
        first: Int,
        last: Int,
        "Whether or not to show protected object count for an sla"
        showProtectedObjectCount: Boolean,
        "Whether or not to show the Global SLA sync status on CDM"
        showSyncStatus: Boolean,
        sortBy: SLAQuerySortByFieldEnum,
        sortOrder: SLAQuerySortByOrderEnum
    ): SlaDomainConnection!
    globalSlaFilterConnection(
        after: String,
        before: String,
        "Specification on what context filter to use"
        contextFilter: ContextFilterTypeEnum,
        "Specification on what context filter input to use"
        contextFilterInput: [ContextFilterInputField!],
        filter: [GlobalSlaFilterInput!],
        first: Int,
        last: Int,
        "Whether or not to show protected object count for an sla"
        showProtectedObjectCount: Boolean,
        "Whether or not to show the Global SLA sync status on CDM"
        showSyncStatus: Boolean,
        sortBy: SLAQuerySortByFieldEnum,
        sortOrder: SLAQuerySortByOrderEnum
    ): GlobalSlaForFilterConnection!
    growthForecast(growthRequest: GrowthRequest!): GrowthResponse!
    hierarchyObject(fid: UUID!): HierarchyObject!
    hierarchyObjects(fids: [UUID!]!, filter: [Filter!]): [HierarchyObject!]!
    hierarchySnappableConnection(after: String, filter: [Filter!], first: Int, sortBy: HierarchySortByField, sortOrder: HierarchySortOrder): HierarchySnappableConnection!
    hostShare(fid: UUID!): HostShare!
    hostShareConnection(after: String, filter: [Filter!], first: Int, sortBy: HierarchySortByField, sortOrder: HierarchySortOrder): HostShareConnection!
    identityProviders: [IdentityProvider!]!
    installedVersionList: [GroupCount!]!
    "list the available Instance Types"
    instanceTypeConnection(
        after: String,
        "the fid of the app blueprint"
        appBlueprintId: UUID!,
        filter: [Filter!],
        first: Int,
        "NamePrefix is prefix for filtering down suggestions"
        namePrefix: String,
        "the fid of the snappable"
        snappableId: UUID,
        "the fid of the snapshot"
        snapshotId: UUID,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): SnappableInstanceTypeConnection!
    inventoryRoot: InventoryRoot!
    inventorySubHierarchyRoot(rootEnum: InventorySubHierarchyRootEnum!): InventorySubHierarchyRoot!
    ipWhitelist: GetWhitelistReply!
    "Queries whether the given volume snapshot is restorable which is used to enable \"Replace volume where attached\" flag on Export Volume Snapshot UI"
    isAwsNativeEbsVolumeSnapshotRestorable(
        "UUID of the snapshot"
        snapshotId: String!
    ): IsVolumeSnapshotRestorableReply!
    "Queries whether the given disk snapshot is restorable which is used to enable \"Replace disk where attached\" flag on Export Disk Snapshot UI"
    isAzureNativeManagedDiskSnapshotRestorable(
        "Snapshot ID"
        diskSnapshotId: UUID!,
        "Subscription ID"
        subscriptionId: UUID!
    ): Boolean!
    "Is Logged into Rubrik support portal"
    isLoggedIntoRubrikSupportPortal: SupportPortalStatusReply!
    "Is Rubrik Suppport Portal reachable from this deployment"
    isSFDCReachable(
        "Support portal hostname"
        hostname: String! = "rubrik.force.com",
        "Support portal organization ID"
        organizationId: String! = "00D40000000N3x2"
    ): Boolean!
    "Is upgrade available for a particular cluster"
    isUpgradeAvailable(
        "Cluster uuid"
        clusterUuid: UUID!
    ): CdmUpgradeAvailabilityReply!
    "Is upgrade recommended for a particular cluster"
    isUpgradeRecommended(
        "Cluster uuid"
        clusterUuid: UUID!
    ): CdmUpgradeRecommendationReply!
    isVMwareManagementEnabled: Boolean!
    "Return details of one issue"
    issue(issueId: String!): Issue!
    "Return all issues filtered by status"
    issueConnection(after: String, before: String, first: Int, last: Int, status: IssueStatusEnum!): IssueConnection!
    lambdaSettings: LambdaSettings!
    "Browse LDAP authorized principals"
    ldapAuthorizedPrincipalConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "Assigned role IDs for LDAP principal"
        roleIds: [UUID!],
        "Search Text for LDAP principal"
        searchText: String!,
        sortBy: LdapAuthorizedPrincipalFieldEnum = Name,
        "sort order"
        sortOrder: SortOrderEnum
    ): AuthorizedPrincipalConnection!
    "Browse LDAP Integrations"
    ldapIntegrationConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        sortBy: LdapIntegrationFieldEnum = Name,
        "sort order"
        sortOrder: SortOrderEnum
    ): LdapIntegrationConnection!
    "Search LDAP Principals"
    ldapPrincipalConnection(
        after: String,
        before: String,
        first: Int,
        "ID for your LDAP integration"
        id: UUID!,
        last: Int,
        "Search Text for LDAP principal"
        searchText: String!,
        sortBy: LdapPrincipalFieldEnum = Name,
        "sort order"
        sortOrder: SortOrderEnum
    ): PrincipalConnection!
    linuxFileset(fid: UUID!): LinuxFileset!
    "fetch all db parameter groups in given region"
    listDbParameterGroups(awsNativeAccountId: UUID!, dbEngine: AwsNativeRdsDbEngineEnum!, dbEngineVersion: String!, region: AwsNativeRegionEnum!): [DbParameterGroup!]!
    "fetch all db subnet groups in given region"
    listDbSubnetGroups(awsNativeAccountId: UUID!, region: AwsNativeRegionEnum!): [SubnetGroup!]!
    "fetch all key pairs for given region"
    listEc2KeyPairs(awsNativeAccountId: UUID!, region: AwsNativeRegionEnum!): [String!]!
    "List ids of running issues jobs"
    listIssuesJobStatus(queryIds: [String!]!): [String!]!
    listO365Apps(after: String, first: Int, o365AppFilters: [AppFilter!]!, o365AppSortByParam: AppSortByParam): O365AppConnection!
    "fetch all option groups in given region"
    listOptionGroups(awsNativeAccountId: UUID!, dbEngine: AwsNativeRdsDbEngineEnum!, dbEngineVersion: String!, majorEngineVersion: String!, region: AwsNativeRegionEnum!): [OptionGroup!]!
    "Returns a list of all s3 buckets across regions for the aws account"
    listS3Buckets(awsNativeAccountId: UUID!): [String!]!
    o365Calendar(snappableFid: UUID!): O365Calendar!
    o365Mailbox(snappableFid: UUID!): O365Mailbox!
    "List of Mailboxes of O365Org"
    o365Mailboxes(after: String, filter: [Filter!], first: Int, o365OrgId: UUID!, sortBy: HierarchySortByField, sortOrder: HierarchySortOrder): O365MailboxConnection!
    o365Onedrive(snappableFid: UUID!): O365Onedrive!
    "List of Onedrives of O365Org"
    o365Onedrives(after: String, filter: [Filter!], first: Int, o365OrgId: UUID!, sortBy: HierarchySortByField, sortOrder: HierarchySortOrder): O365OnedriveConnection!
    o365Org(fid: UUID!): O365Org!
    o365Orgs(after: String, filter: [Filter!], first: Int, sortBy: HierarchySortByField, sortOrder: HierarchySortOrder): O365OrgConnection!
    o365ServiceAccount(orgId: UUID!): O365ServiceAccountStatusResp!
    o365SharepointDrive(snappableFid: UUID!): O365SharepointDrive!
    "List of sharepoint drives (document libraries) in the O365Org"
    o365SharepointDrives(after: String, filter: [Filter!], first: Int, o365OrgId: UUID!, sortBy: HierarchySortByField, sortOrder: HierarchySortOrder): O365SharepointDriveConnection!
    o365SharepointObjects(after: String, fid: UUID!, filter: [Filter!], first: Int, sortBy: HierarchySortByField, sortOrder: HierarchySortOrder): O365SharepointObjectConnection!
    o365Site(snappableFid: UUID!): O365Site!
    "List of sites of O365Org"
    o365Sites(after: String, filter: [Filter!], first: Int, o365OrgId: UUID!, sortBy: HierarchySortByField, sortOrder: HierarchySortOrder): O365SiteConnection!
    o365User(fid: UUID!): O365User!
    pendingAction(pendingActionId: String!): pendingAction!
    pendingActions(clusterFilter: UUID, historyOnly: Boolean, limit: Long, objectIds: [String!], pendingActionGroupTypeFilter: [PendingActionGroupTypeEnum!], pendingActionSubGroupTypeFilter: [PendingActionSubGroupTypeEnum!], sortedOrder: ChronologicalOrderEnum, statusFilter: [PendingActionStatusEnum!]): [pendingAction!]!
    physicalHost(fid: UUID!): PhysicalHost!
    physicalHostConnection(
        after: String,
        filter: [Filter!],
        first: Int,
        "host root type"
        hostRoot: HostRoot!,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): PhysicalHostConnection!
    polarisInventorySubHierarchyRoot(rootEnum: InventorySubHierarchyRootEnum!): PolarisInventorySubHierarchyRoot!
    "Returns the Polaris snapshot by id"
    polarisSnapshot(
        "Corresponds to snapshot forever UUID in Polaris tables"
        snapshotFid: UUID!
    ): PolarisSnapshot!
    "Return detailed policy information"
    policy(policyId: String!): ClassificationPolicyDetail!
    "Return active policies for an account"
    policyConnection(policyObjectFilter: PolicyObjectFilterEnum): ClassificationPolicyDetailConnection!
    "Return details for one policy obj"
    policyObj(snappableFid: String!, snapshotFid: String!): PolicyObj!
    "Return status for all objects at a specified timestamp"
    policyObjConnection(day: String!, timezone: String!): PolicyObjConnection!
    "Returns which policies are applied to each object"
    policyObjectUsageConnection(objectIds: [String!]!): PolicyObjectUsageConnection!
    "Gets status of last prechecks job"
    prechecksStatus(
        "Cluster uuid"
        clusterUuid: UUID!
    ): PrechecksStatusReply!
    "Get status of last completed prechecks Job along with details of currently running/scheduled next prechecks Job"
    prechecksStatusWithNextJobInfo(
        "Cluster uuid"
        clusterUuid: UUID!
    ): PrechecksStatusReply!
    "List of all objects protected by the sla"
    protectedObjectsConnection(
        after: String,
        before: String,
        filter: [Filter!],
        first: Int,
        last: Int,
        objectTypeFilter: [String!],
        "Corresponds to optional object root forever UUID, none value is assumed to be the global hierarchy root"
        rootOptionalFid: UUID,
        "Provide list of Global SLA ids"
        slaIds: [UUID!]!,
        sortBy: HierarchySortByField,
        "sort order"
        sortOrder: SortOrderEnum
    ): ProtectedObjectsConnection!
    radarClusterConnection(
        after: String,
        before: String,
        filter: ClusterFilterInput,
        first: Int,
        last: Int,
        "sort clusters by field"
        sortBy: ClusterSortByEnum = ClusterType,
        "cluster sort order"
        sortOrder: SortOrderEnum = Desc
    ): ClusterConnection!
    ransomwareResult(
        "The id of the cluster"
        clusterUuid: UUID!,
        "Snappable managed ID"
        managedId: String!,
        "Corresponds to snapshot ID in CDM tables"
        snapshotId: String!
    ): RansomwareResult!
    ransomwareResultConnection(
        after: String,
        before: String,
        "filter ransomware results by input"
        filter: RansomwareResultFilterInput,
        first: Int,
        last: Int,
        "sort ransomware results by field"
        sortBy: RansomwareResultSortByEnum,
        timezoneOffset: Float = 0.0
    ): RansomwareResultConnection!
    ransomwareResultGroupByConnection(
        after: String,
        before: String,
        "filter ransomware results by input"
        filter: RansomwareResultFilterInput,
        first: Int,
        "group ransomware results by field"
        groupBy: RansomwareResultGroupByEnum!,
        last: Int,
        timezoneOffset: Float = 0.0
    ): RansomwareResultGroupByConnection!
    ransomwareResultOpt(
        "The id of the cluster"
        clusterUuid: UUID!,
        "Snappable managed ID"
        managedId: String!,
        "Corresponds to snapshot ID in CDM tables"
        snapshotId: String!
    ): RansomwareResult
    report(id: Int!): CustomReport!
    reportConfig(reportID: Int!): ReportConfig!
    reportConnection(
        after: String,
        before: String,
        "filter custom reports by input"
        filter: CustomReportFilterInput,
        first: Int,
        last: Int,
        "sort by field"
        sortBy: CustomReportSortByEnum = UpdateTime,
        "sort order"
        sortOrder: SortOrderEnum
    ): CustomReportConnection!
    reportData(
        after: String,
        """

        A list of aggregations to apply to the grouped rows, it must be used
        in conjunction with groupBy arg (except for count(*)). Supported
        aggregations are:
        hour, day, week, month, year for datetime columns
        sum, avg for integer columns
        count(*)
        """
        aggregations: [String!],
        before: String,
        """

        A list of columns to include in the result. It can be omitted when
        requesting aggregations, and server will derive columns by
        concatenating groupBy and aggregation arguments.
        """
        columns: [String!]!,
        dataView: DataViewTypeEnum!,
        "A list of filters to filter result with"
        filters: [ReportFilterInput!],
        first: Int,
        """

        A list of the names of the columns to group result by, it must be
        used in conjunction of aggregations.
        """
        groupBy: [String!],
        last: Int,
        "Name of the column to sort result by"
        sortBy: String,
        "sort order"
        sortOrder: SortOrderEnum,
        "The timezone to return results in"
        timezone: String
    ): RowConnection!
    reportFromConfig(config: CustomReportCreate!): CustomReport!
    reportGroupByConnection(
        after: String,
        before: String,
        "filter custom reports by input"
        filter: CustomReportFilterInput,
        first: Int,
        "group by field"
        groupBy: CustomReportGroupByEnum!,
        last: Int
    ): CustomReportGroupByConnection!
    reportSchema(
        dataView: DataViewTypeEnum!,
        "The timezone to return results in"
        timezone: String
    ): ReportSchema!
    sapHanaDatabase(fid: UUID!): SapHanaDatabase!
    sapHanaDatabaseConnection(after: String, filter: [Filter!], first: Int, sortBy: HierarchySortByField, sortOrder: HierarchySortOrder): SapHanaDatabaseConnection!
    sapHanaLogSnapshot(fid: UUID!): SapHanaLogSnapshot!
    sapHanaLogSnapshotConnection(
        after: String,
        before: String,
        "filter sap hana log snapshots by input"
        filter: SapHanaLogSnapshotFilterInput,
        first: Int,
        last: Int,
        "sort sap hana log snapshots by field"
        sortBy: SapHanaLogSnapshotSortByEnum,
        "sort order"
        sortOrder: SortOrderEnum
    ): SapHanaLogSnapshotConnection!
    sapHanaRecoverableRange(fid: UUID!): SapHanaRecoverableRange!
    sapHanaRecoverableRangeConnection(
        after: String,
        before: String,
        "filter sap hana recoverable ranges by input"
        filter: SapHanaRecoverableRangeFilterInput,
        first: Int,
        last: Int,
        "sort sap hana recoverable ranges by field"
        sortBy: SapHanaRecoverableRangeSortByEnum,
        "sort order"
        sortOrder: SortOrderEnum
    ): SapHanaRecoverableRangeConnection!
    sapHanaSystem(fid: UUID!): SapHanaSystem!
    sapHanaSystemConnection(after: String, filter: [Filter!], first: Int, sortBy: HierarchySortByField, sortOrder: HierarchySortOrder): SapHanaSystemConnection!
    scheduledReport(id: Int!): ScheduledReport
    scheduledReportConnection(after: String, before: String, filter: ScheduledReportFilterInput, first: Int, last: Int): ScheduledReportConnection!
    screenshotReport(
        "The ID of the report to be screenshotted"
        reportId: String!
    ): TakeScreenshotReply!
    searchCloudNativeSnappableVersionedFileConnection(
        after: String,
        first: Int,
        "Name or Path prefix arg for searching for files within a snappable"
        searchQuery: String!,
        "Snappable ID"
        snappableId: UUID!
    ): CloudNativeVersionedFileConnection!
    "Search file under given folder and with given prefix"
    searchFileByPrefix(
        "The id of the cluster"
        clusterUuid: UUID!,
        "filename prefix that should match"
        filenamePrefix: String!,
        "Snappable managed ID"
        managedId: String!,
        "root path to search file inside fmd"
        searchFolderPath: String!,
        "Corresponds to snapshot ID in CDM tables"
        snapshotId: String!
    ): DiffFMDReply!
    searchHost(
        "ID of the host to search"
        id: String!,
        "The path query. Either path prefix or filename prefix."
        path: String!
    ): SearchResponseListResponse!
    searchSnappableConnection(
        after: String,
        before: String,
        "filter snappables by input (with search by name)"
        filter: SnappableFilterInputWithSearch,
        first: Int,
        last: Int,
        "sort snappables by field"
        sortBy: SnappableSortByEnum = Name,
        "sort order"
        sortOrder: SortOrderEnum
    ): SnappableConnection!
    searchSnappableVersionedFileConnection(after: String, first: Int, searchQuery: String!, snappableFid: UUID!): VersionedFileConnection!
    "list the available Security Groups"
    securityGroupConnection(
        after: String,
        "the fid of the app blueprint"
        appBlueprintId: UUID!,
        filter: [Filter!],
        first: Int,
        "NamePrefix is prefix for filtering down suggestions"
        namePrefix: String,
        "the fid of the snappable"
        snappableId: UUID,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        "the fid of the vpc"
        vpcId: UUID!
    ): SnappableSecurityGroupConnection!
    serviceProviderMetadataFields: GetSPExplicitReply!
    shareFileset(fid: UUID!): ShareFileset!
    slaConflictObjects(fids: [UUID!]!): [HierarchyObject!]!
    slaDomainWithWarnings(
        "Corresponds to global SLA forever UUID in Polaris tables"
        globalSlaFid: UUID!,
        "Provide list of object forever IDS you want to assign Global SLA"
        objectIds: [UUID!]!
    ): SlaDomainWithWarnings!
    "Query sla list with warnings"
    slaDomainWithWarningsList(
        after: String,
        before: String,
        "Specification on what context filter to use"
        contextFilter: ContextFilterTypeEnum,
        filter: [GlobalSlaFilterInput!],
        first: Int,
        last: Int,
        "Provide list of object forever IDS you want to assign Global SLA"
        objectIds: [UUID!]!,
        sortBy: SLAQuerySortByFieldEnum,
        sortOrder: SLAQuerySortByOrderEnum
    ): [SlaDomainWithWarnings!]!
    smtpConfiguration: GetSMTPConfigurationReply!
    snappableConnection(
        after: String,
        before: String,
        "filter snappables by input"
        filter: SnappableFilterInput,
        first: Int,
        last: Int,
        "sort snappables by field"
        sortBy: SnappableSortByEnum = Name,
        "sort order"
        sortOrder: SortOrderEnum
    ): SnappableConnection!
    snappableEmailSearch(
        after: String,
        first: Int,
        orgId: UUID!,
        "search filters"
        searchFilter: SearchFilter,
        snappableFid: UUID!
    ): O365ExchangeObjectConnection!
    snappableEmailSearchV2(
        after: String,
        first: Int,
        orgId: UUID!,
        "search filters"
        searchFilter: SearchFilter,
        snappableFid: UUID!
    ): O365ExchangeObjectConnection!
    snappableEventSearch(
        after: String,
        "calendar search filters"
        calendarSearchFilter: CalendarSearchFilter,
        first: Int,
        orgId: UUID!,
        snappableFid: UUID!
    ): O365ExchangeObjectConnection!
    snappableGroupByConnection(
        after: String,
        before: String,
        "filter snappables by input for group by"
        filter: SnappableGroupByFilterInput,
        first: Int,
        "group snappables by field"
        groupBy: SnappableGroupByEnum!,
        last: Int,
        "List of Snappable aggregations you want to fetch. Explicitly specifying the subset of aggregations you need will greatly speed up the query."
        requestedAggregations: [SnappableAggregationsEnum!],
        timezoneOffset: Float = 0.0
    ): SnappableGroupByConnection!
    snappableOnedriveSearch(after: String, first: Int, onedriveSearchFilter: OnedriveSearchFilter, orgId: UUID!, snappableFid: UUID!): O365OnedriveObjectConnection!
    "Returns a single snapshot by id"
    snapshot(
        "Corresponds to snapshot forever UUID in Polaris tables"
        snapshotFid: UUID!
    ): CdmSnapshot!
    snapshotEmailSearch(
        after: String,
        first: Int,
        orgId: UUID!,
        "search filters"
        searchFilter: SearchFilter,
        snappableFid: UUID!,
        snapshotFid: UUID!
    ): O365ExchangeObjectConnection!
    snapshotEmailSearchV2(
        after: String,
        first: Int,
        orgId: UUID!,
        "search filters"
        searchFilter: SearchFilter,
        snappableFid: UUID!,
        snapshotFid: UUID!
    ): O365ExchangeObjectConnection!
    snapshotEventSearch(
        after: String,
        "calendar search filters"
        calendarSearchFilter: CalendarSearchFilter,
        first: Int,
        orgId: UUID!,
        snappableFid: UUID!,
        snapshotFid: UUID!
    ): O365ExchangeObjectConnection!
    "Browse or search the given path for files and directories along with their deltas in a given snapshot"
    snapshotFileDeltaConnection(
        after: String,
        "filter snapshot delta based on delta types"
        filter: SnapshotDeltaFilterInput,
        first: Int,
        "The path under which you want your search to run"
        path: String!,
        "Prefix arg for searching for files within a snapshot"
        searchPrefix: String,
        "Corresponds to snapshot forever UUID in Polaris tables"
        snapshotFid: UUID!
    ): SnapshotFileDeltaConnection!
    "Returns list of snapshots for a snappable"
    snapshotOfASnappableConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        snappableId: String!,
        "filter for snapshot connection"
        snapshotFilter: [SnapshotQueryFilterInput!],
        sortBy: SnapshotQuerySortByField,
        "sort order"
        sortOrder: SortOrderEnum,
        timeRange: TimeRangeInput
    ): GenericSnapshotConnection!
    "Returns list of snapshots for a list of snappables"
    snapshotOfSnappablesConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        snappableIds: [String!]!,
        "filter for snapshot connection"
        snapshotFilter: [SnapshotQueryFilterInput!],
        sortBy: SnapshotQuerySortByField,
        "sort order"
        sortOrder: SortOrderEnum,
        timeRange: TimeRangeInput
    ): GenericSnapshotConnection!
    snapshotOnedriveSearch(after: String, first: Int, onedriveSearchFilter: OnedriveSearchFilter, orgId: UUID!, snappableFid: UUID!, snapshotFid: UUID!): O365OnedriveObjectConnection!
    "Return snapshot results for a snappable"
    snapshotResultConnection(
        "End time of the range (in milliseconds since epoch)"
        endTimeMs: Long!,
        snappableFid: String!,
        "Begin time of the range (in milliseconds since epoch)"
        startTimeMs: Long!
    ): SnapshotResultConnection!
    "Return groupBy results for SonarContentReport"
    sonarContentReportGroupByConnection(
        after: String,
        before: String,
        day: String!,
        filters: SonarContentReportFilter,
        first: Int,
        groupBy: SonarContentReportGroupByEnum!,
        last: Int,
        sortBy: SonarContentReportSortByEnum,
        "sort order"
        sortOrder: SortOrderEnum,
        timezone: String!
    ): SonarContentReportTableRowConnection!
    "Return file activity records for user"
    sonarFileActivityForUser(
        after: String,
        before: String,
        "End time of the range (in milliseconds since epoch)"
        endTimeMs: Long!,
        first: Int,
        last: Int,
        "Security identifier for user, group in Windows"
        sid: String!,
        snappableFid: String!,
        "Begin time of the range (in milliseconds since epoch)"
        startTimeMs: Long!,
        stdPath: String!
    ): DatagovFileActivityConnection!
    "Return file audit summary by user"
    sonarFileAuditSummaryByUser(
        after: String,
        before: String,
        "End time of the range (in milliseconds since epoch)"
        endTimeMs: Long!,
        first: Int,
        last: Int,
        snappableFid: String!,
        "Begin time of the range (in milliseconds since epoch)"
        startTimeMs: Long!,
        stdPath: String!
    ): ActivitySummaryByUserConnection!
    "Return groupBy for SonarReport"
    sonarReportGroupByConnection(filter: [String!], sonarReportGroupBy: SonarReportGroupByEnum!, timeFilter: TimeFilterInput): SonarReportGroupByResultConnection!
    "Return rows for SonarReport table"
    sonarReportTableConnection(
        after: String,
        before: String,
        endTime: String,
        filter: [String!],
        first: Int,
        last: Int,
        sortBy: SonarReportSortByEnum,
        "sort order"
        sortOrder: SortOrderEnum
    ): SonarReportTableRowConnection!
    "Return sonar user activity records"
    sonarUserActivity(
        after: String,
        auditEventFilter: AuditEventFiltersInput,
        before: String,
        "End time of the range (in milliseconds since epoch)"
        endTimeMs: Long!,
        first: Int,
        last: Int,
        "Security identifier for user, group in Windows"
        sid: String!,
        "Begin time of the range (in milliseconds since epoch)"
        startTimeMs: Long!
    ): SonarUserActivityConnection!
    sourceBlueprintInfo(fid: UUID!): SourceBlueprintInfo!
    "list the available Subnets"
    subnetConnection(
        after: String,
        "the fid of the app blueprint"
        appBlueprintId: UUID!,
        "the type for id of availability-zone (eg. us-east-1a)"
        availabilityZone: String,
        filter: [Filter!],
        first: Int,
        "NamePrefix is prefix for filtering down suggestions"
        namePrefix: String,
        "the fid of the snappable"
        snappableId: UUID,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        "the fid of the vpc"
        vpcId: UUID!
    ): SnappableSubnetConnection!
    tableFilters: TableFilters!
    target(
        "Corresponds to ID of target in Polaris"
        targetId: UUID!
    ): Target!
    targetList(
        "Specification on what context filter to use"
        contextFilter: ContextFilterTypeEnum,
        "Specification on how to filter a list of targets"
        filter: [TargetFilterInput!],
        "Specification on how to sort a list of targets"
        sortBy: TargetSortByFieldEnum,
        "sort order"
        sortOrder: SortOrderEnum
    ): [Target!]!
    targetMapping(
        "Corresponds to ID of target mapping in Polaris"
        targetMappingId: UUID!
    ): TargetMapping!
    targetMappingList(
        "Specification on what context filter to use"
        contextFilter: ContextFilterTypeEnum,
        "Specification on how to filter a list of target mappings"
        filter: [TargetMappingFilterInput!],
        "Specification on how to sort a list of target mappings"
        sortBy: TargetMappingSortByFieldEnum,
        "sort order"
        sortOrder: SortOrderEnum
    ): [TargetMapping!]!
    taskDetailConnection(
        after: String,
        before: String,
        "filter task summary by input"
        filter: TaskDetailFilterInput,
        first: Int,
        last: Int,
        "sort task detail by field"
        sortBy: TaskDetailSortByEnum = EndTime,
        "task detail sort order"
        sortOrder: SortOrderEnum = Desc,
        timezoneOffset: Float = 0.0
    ): TaskDetailConnection!
    taskDetailGroupByConnection(
        after: String,
        before: String,
        "filter task summary by input"
        filter: TaskDetailFilterInput,
        first: Int,
        "group task detail by a field"
        groupBy: TaskDetailGroupByEnum!,
        last: Int,
        timezoneOffset: Float = 0.0
    ): TaskDetailGroupByConnection!
    taskSummaryConnection(
        after: String,
        before: String,
        "filter task summary by input"
        filter: TaskSummaryFilterInput,
        first: Int,
        last: Int,
        "sort task summary by field"
        sortBy: TaskSummarySortByEnum = ObjectName,
        "sort order"
        sortOrder: SortOrderEnum,
        timezoneOffset: Float = 0.0
    ): TaskSummaryConnection!
    taskSummaryGroupByConnection(
        after: String,
        before: String,
        "filter task summary by input"
        filter: TaskSummaryFilterInput,
        first: Int,
        "group task summary by a field"
        groupBy: TaskSummaryGroupByEnum!,
        last: Int,
        timezoneOffset: Float = 0.0
    ): TaskSummaryGroupByConnection!
    toggleableFeaturesEnabled: [FeatureNameEnum!]!
    uniqueVSphereVCenterCount(filter: [Filter!]): Int!
    "Gets the status for completed/running upgrade process"
    upgradeStatus(
        "Cluster uuid"
        clusterUuid: UUID!
    ): UpgradeStatusReply!
    userAuditConnection(
        after: String,
        before: String,
        filters: UserAuditFilterInput,
        first: Int,
        last: Int,
        "sort user audit by field"
        sortBy: UserAuditSortByEnum = Time,
        "user audit sort order"
        sortOrder: SortOrderEnum = Desc
    ): UserAuditConnection!
    userAuditGroupByConnection(
        after: String,
        before: String,
        filters: UserAuditFilterInput,
        first: Int,
        "group audits by a field"
        groupBy: UserAuditGroupByEnum!,
        last: Int,
        "sort user audit by field"
        sortBy: UserAuditSortByEnum = Time,
        "user audit sort order"
        sortOrder: SortOrderEnum = Desc,
        timezoneOffset: Float = 0.0
    ): UserAuditGroupByConnection!
    userGroups(after: String, before: String, first: Int, last: Int, roleIdsFilter: [UUID!]): [Group!]!
    vSphereBlueprint(fid: UUID!): VSphereBlueprint!
    vSphereComputeCluster(fid: UUID!): VSphereComputeCluster!
    vSphereDatacenter(fid: UUID!): VSphereDatacenter!
    vSphereDatastoreConnection(after: String, filter: [Filter!], first: Int, sortBy: HierarchySortByField, sortOrder: HierarchySortOrder): VSphereDatastoreConnection!
    vSphereFolder(fid: UUID!): VSphereFolder!
    vSphereHost(fid: UUID!): VSphereHost!
    vSphereHostConnection(after: String, filter: [Filter!], first: Int, sortBy: HierarchySortByField, sortOrder: HierarchySortOrder): VSphereHostConnection!
    "Get a vSphere Live Mount by id"
    vSphereMount(fid: UUID!): VSphereMount!
    "vSphere Live Mount Connection"
    vSphereMountConnection(
        after: String,
        "filter for VM live mounts"
        filter: VSphereMountFilter,
        first: Int,
        sortBy: VSphereMountSortByEnum,
        "sort order"
        sortOrder: SortOrderEnum
    ): VSphereMountConnection!
    vSphereTag(fid: UUID!): VSphereTag!
    vSphereTagCategory(fid: UUID!): VSphereTagCategory!
    vSphereTopLevelDescendantsConnection(after: String, filter: [Filter!], first: Int, sortBy: HierarchySortByField, sortOrder: HierarchySortOrder, typeFilter: [HierarchyObjectTypeEnum!]): CdmHierarchyObjectConnection!
    vSphereVCenter(fid: UUID!): VSphereVCenter!
    vSphereVCenterConnection(after: String, filter: [Filter!], first: Int, sortBy: HierarchySortByField, sortOrder: HierarchySortOrder): VSphereVCenterConnection!
    vSphereVMAsyncRequestStatus(
        clusterUuid: UUID!,
        "ID of an asynchronous request."
        id: String!
    ): AsyncRequestStatus!
    vSphereVmNew(fid: UUID!): VSphereVmNew!
    vSphereVmNewConnection(after: String, filter: [Filter!], first: Int, sortBy: HierarchySortByField, sortOrder: HierarchySortOrder): VSphereVmNewConnection!
    "validates that the given DbInstance class, storage type, multi-az capability, encryption capability, iops value are supported for the given dbEngine, dbEngineVersion in the given availability zone."
    validateOrderableDbInstance(
        awsNativeAccountId: UUID!,
        "DB class of the exported RDS DB instance."
        dbClass: AwsNativeRdsDbInstanceClassEnum!,
        dbEngine: AwsNativeRdsDbEngineEnum!,
        dbEngineVersion: String!,
        "IOPs of the exported RDS DB instance."
        iops: Int,
        "Whether the exported RDS DB instance is multi-AZ or not."
        isMultiAz: Boolean!,
        "KMS Key ID of the exported RDS DB instance."
        kmsKeyId: String,
        "AZ in which the exported RDS DB instance must be launched."
        primaryAz: String,
        region: AwsNativeRegionEnum!,
        "Storage type of the exported RDS DB instance."
        storageType: AwsNativeRdsStorageTypeEnum
    ): Boolean!
    "If error is returned, the name is invalid. Otherwise the name is valid"
    validateRdsInstanceNameForExport(
        awsNativeAccountId: UUID!,
        "Name of the RDS DB Instance"
        rdsInstanceName: String!,
        region: AwsNativeRegionEnum!
    ): Boolean!
    vcdOrg(snappableFid: UUID!): VcdOrg!
    "list the available Volume Types"
    volumeTypeConnection(
        after: String,
        "the fid of the app blueprint"
        appBlueprintId: UUID!,
        filter: [Filter!],
        first: Int,
        " the device key"
        key: Int!,
        "NamePrefix is prefix for filtering down suggestions"
        namePrefix: String,
        "the fid of the snappable"
        snappableId: UUID,
        "the fid of the snapshot"
        snapshotId: UUID,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): SnappableStorageVolumeTypeConnection!
    "list the available VPCs"
    vpcConnection(
        after: String,
        "the fid of the app blueprint"
        appBlueprintId: UUID!,
        filter: [Filter!],
        first: Int,
        "MaxSuggestionCount is the number of suggestions expected"
        maxSuggestionCount: Int,
        "NamePrefix is prefix for filtering down suggestions"
        namePrefix: String,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): VpcConnection!
    vsphereVMMissedRecoverableRange(afterTime: DateTime, beforeTime: DateTime, snappableFid: UUID!): RecoverableRangeResponse!
    vsphereVMRecoverableRange(afterTime: DateTime, beforeTime: DateTime, snappableFid: UUID!): RecoverableRangeResponse!
    vsphereVMRecoverableRangeInBatch(
        "The batch request, which includes the ID of each CDP-enabled virtual machine for which recoverable ranges are being retrieved, and optionally the date ranges as a filter."
        requestInfo: BatchVmwareVmRecoverableRangesRequestInput!
    ): BatchVmwareVmRecoverableRanges!
    vsphereVmwareCdpLiveInfo(
        "The ID of each CDP-enabled virtual machine for which live info is being retrieved."
        ids: [String!]!
    ): BatchVmwareCdpLiveInfo!
    windowsFileset(fid: UUID!): WindowsFileset!
}

type QuerySDDLReply {
    secInfo: [PathSecInfo!]!
}

"Ransomware analysis report from lambda service"
type RansomwareResult {
    clusterUuid: UUID!
    encryptionProbability: Float!
    id: String!
    isEncrypted: Boolean!
    managedId: String!
    snappableId: String!
    snapshotData: DateTime!
    snapshotId: String!
}

type RansomwareResultConnection {
    count: Int!
    edges: [RansomwareResultEdge!]!
    nodes: [RansomwareResult!]!
    pageInfo: PageInfo!
}

type RansomwareResultEdge {
    cursor: String!
    node: RansomwareResult!
}

"Ransomware analysis data with groupby info applied to it"
type RansomwareResultGroupBy {
    "Groupby info."
    groupByInfo: RansomwareResultGroupByInfo!
    "Paginated ransomware result data"
    ransomwareResultConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "sort ransomware results by field"
        sortBy: RansomwareResultSortByEnum
    ): RansomwareResultConnection!
    "Further provide groupings for the data."
    ransomwareResultGroupBy(
        "group ransomware results by field"
        groupBy: RansomwareResultGroupByEnum!
    ): [RansomwareResultGroupBy!]!
}

type RansomwareResultGroupByConnection {
    count: Int!
    edges: [RansomwareResultGroupByEdge!]!
    nodes: [RansomwareResultGroupBy!]!
    pageInfo: PageInfo!
}

type RansomwareResultGroupByEdge {
    cursor: String!
    node: RansomwareResultGroupBy!
}

"RDS Export defaults from AWS."
type RdsInstanceExportDefaults {
    allocatedStorageInGb: Long!
    dbEngine: AwsNativeRdsDbEngineEnum!
    dbEngineVersion: String!
    dbInstanceClass: AwsNativeRdsDbInstanceClassEnum!
    dbParameterGroupName: String!
    dbSubnetGroupName: String!
    iops: Int!
    isMultiAz: Boolean!
    kmsKeyId: String!
    optionGroupName: String!
    port: Long!
    primaryAz: String!
    storageType: AwsNativeRdsStorageTypeEnum!
    vpcId: String!
}

"Range to recover a snapshot from for a given VM"
type RecoverableRange {
    beginTime: String
    endTime: String
}

"Recoverable ranges for a given VM"
type RecoverableRangeResponse {
    data: [RecoverableRange!]!
    hasMore: Boolean
    total: Long
}

type RecoverySpecId {
    fid: String!
}

type RecoverySpecValidityCheckReply {
    errorMessage: String!
    rmStatus: String!
    success: Boolean!
}

type RecoveryTaskDetailsTableFilter {
    cluster_location: [FilterOption!]!
    cluster_type: [FilterOption!]!
    object_type: [FilterOption!]!
    replication_source: [FilterOption!]!
    status: [FilterOption!]!
    task_category: [FilterOption!]!
    task_type: [FilterOption!]!
}

type RefreshAwsAccountsReply {
    errors: [RefreshAwsNativeAccountError!]!
    taskchainUuids: [RefreshAwsNativeAccountTaskchainUuid!]!
}

type RefreshAwsNativeAccountError {
    accountId: String!
    error: String!
}

type RefreshAwsNativeAccountTaskchainUuid {
    accountId: String!
    taskchainUuid: String!
}

"Taskchain information for refresh aws source job"
type RefreshAwsSourcesReply {
    taskchainUuids: [String!]!
}

"Subscription ID and the error encountered while scheduling refresh subscription job for the subscription"
type RefreshAzureNativeSubscriptionError {
    error: String!
    subscriptionId: String!
}

"Subscription ID and the Taskchain ID of the refresh subscription job scheduled for the subscription"
type RefreshAzureNativeSubscriptionTaskchainUuid {
    subscriptionId: String!
    taskchainUuid: String!
}

"The status of Refresh Azure Native Subscription request. For each subscription ID in the request: an entry in errors if failed,or in taskchainUuids if succeeded."
type RefreshAzureNativeSubscriptionsReply {
    errors: [RefreshAzureNativeSubscriptionError!]!
    taskchainUuids: [RefreshAzureNativeSubscriptionTaskchainUuid!]!
}

"Project ID and the error encountered while scheduling refresh project job for the project"
type RefreshGCPNativeProjectError {
    error: String!
    projectId: String!
}

"Project ID and the Taskchain ID of the refresh project job scheduled for the project"
type RefreshGCPNativeProjectTaskchainUuid {
    projectId: String!
    taskchainUuid: String!
}

"The status of Refresh GCP Native project request. For each project ID in the request: an entry in errors if failed,or in taskchainUuids if succeeded."
type RefreshGCPNativeProjectsReply {
    errors: [RefreshGCPNativeProjectError!]!
    taskchainUuids: [RefreshGCPNativeProjectTaskchainUuid!]!
}

"vCenter connection status"
type RefreshableObjectConnectionStatus {
    message: String
    status: VCenterConnectionStatusEnum!
}

type Region {
    displayName: String!
    id: String!
    name: String!
}

type RegionConnection {
    count: Int!
    edges: [RegionEdge!]!
    nodes: [Region!]!
    pageInfo: PageInfo!
}

type RegionEdge {
    cursor: String!
    node: Region!
}

"A relative range of time."
type RelativeTimeRange {
    "Number of units in the time range."
    magnitude: Int!
    "Unit of the time range"
    unit: TimeUnitEnum!
}

type ReplicationSource {
    id: String!
    sourceClusterAddress: String
    sourceClusterName: String!
    sourceClusterUuid: UUID!
    totalStorage: Long
}

type ReplicationSpec {
    replicationType: ReplicationTypeEnum!
    specificReplicationSpec: SpecificReplicationSpec
}

type ReplicationSpecV2 {
    awsRegion: String!
    "AWS location used as the replication target"
    awsTarget: AwsReplicationTarget!
    azureRegion: String!
    "Azure location used as the replication target"
    azureTarget: AzureReplicationTarget!
    "Cluster used as replication target"
    cluster: Cluster
    retentionDuration: SlaDuration
    targetMapping: TargetMapping
}

type ReplicationTarget {
    id: String!
    targetClusterAddress: String
    targetClusterName: String!
    targetClusterUuid: UUID!
    totalStorage: Long
}

type ReplicationToCloudLocationSpec {
    retentionDuration: SlaDuration
    targetMapping: TargetMapping
}

type ReplicationToCloudRegionSpec {
    cloudProvider: CloudProviderEnum!
    replicationTargetRegion: String!
    retention: Int!
    retentionUnit: RetentionUnitEnum!
}

type ReportConfig {
    aggregations: [String!]!
    chartConfigs: [ChartConfig!]!
    columns: [String!]!
    dataViewType: DataViewTypeEnum!
    filters: [ReportFilter!]!
    groupBy: [String!]!
    name: String!
    sortBy: String!
    sortOrder: SortOrderEnum
}

type ReportFilter {
    name: String!
    values: [String!]!
}

type ReportFilterDetail {
    dataType: DataTypeEnum!
    defaultValues: [DisplayableValue!]!
    displayName: String!
    name: String!
    type: FilterTypeEnum!
    values: [DisplayableValue!]!
}

type ReportFocus {
    enumValue: ReportFocusEnum!
}

type ReportSchema {
    aggregateColumns: [Column!]!
    allColumns: [Column!]!
    filters: [ReportFilterDetail!]!
    sortBy: Column!
    sortOrder: SortOrderEnum!
    tableColumns: [Column!]!
}

"""

Supported in v5.0+
"""
type RequestErrorInfo {
    """

    Required. Supported in v5.0+
    v5.0: The error message for failed ids.
    v5.1+: The error message for failed IDs.
    """
    message: String!
}

type RequestStatus {
    success: Boolean!
}

type RequestSuccess {
    success: Boolean!
}

type ResourceGroup {
    id: String!
    name: String!
}

type ResourceGroupConnection {
    count: Int!
    edges: [ResourceGroupEdge!]!
    nodes: [ResourceGroup!]!
    pageInfo: PageInfo!
}

type ResourceGroupEdge {
    cursor: String!
    node: ResourceGroup!
}

"Empty response type"
type ResponseSuccess {
    "Whether request returned successfully"
    success: Boolean!
}

type RestoreEc2InstanceSnapshotReply {
    taskchainUuid: String!
}

"Taskchain ID of the taskchain to restore the specified snapshot"
type RestoreGCEInstanceReply {
    taskchainUuid: String!
}

"Taskchain information for restore azure native virtual machine job"
type RestoreVMReply {
    taskchainUuid: String!
}

type Result {
    appFid: String!
    id: String!
    success: Boolean!
}

type Role {
    description: String!
    id: String!
    isReadOnly: Boolean!
    name: String!
    permissions: [Permission!]!
    protectableClusters: [String!]!
}

type RoleConnection {
    count: Int!
    edges: [RoleEdge!]!
    nodes: [Role!]!
    pageInfo: PageInfo!
}

type RoleEdge {
    cursor: String!
    node: Role!
}

type RoleStatus {
    hasRole: Boolean!
}

type RoleTemplate {
    description: String!
    id: String!
    name: String!
    permissions: [Permission!]!
}

type RoleTemplateConnection {
    count: Int!
    edges: [RoleTemplateEdge!]!
    nodes: [RoleTemplate!]!
    pageInfo: PageInfo!
}

type RoleTemplateEdge {
    cursor: String!
    node: RoleTemplate!
}

type Row {
    metadata: [Metadata!]!
    values: [DisplayableValue!]!
}

type RowConnection {
    columns: [Column!]!
    count: Int!
    edges: [RowEdge!]!
    nodes: [Row!]!
    pageInfo: PageInfo!
}

type RowEdge {
    cursor: String!
    node: Row!
}

type RunCustomAnalyzerReply {
    matches: [CustomAnalyzerMatch!]!
}

type SDDLPermission {
    access: String!
    accessType: AceQualifierEnum!
    cn: String!
    dn: String!
    flags: [AceFlagsEnum!]!
}

"Summary for the no. of objects protected by sla."
type SLAIdToObjectCount {
    objectCount: Int!
    slaId: String!
}

type SapHanaAddSystemResponse {
    "Status of the job scheduled to refresh the system."
    asyncRequestStatus: AsyncRequestStatus
    "Required. The ID of the added SAP HANA system."
    id: String!
}

type SapHanaAppMetadata {
    backupId: Long
    backupPrefix: String
    baseBackupId: Long
    baseFullSnapshotId: String
    files: [SapHanaDataBackupFile!]
    isExternalBackup: Boolean
    isRubrikTriggeredOnDemandBackup: Boolean
    rubrikSnapshotEndTime: DateTime
    rubrikSnapshotStartTime: DateTime
    sapHanaEndTime: DateTime
    sapHanaStartTime: DateTime
    snapshotType: String
}

type SapHanaConfig {
    incrementalFrequency: SlaDuration
    logRetention: SlaDuration
}

type SapHanaDataBackupFile {
    backupFileSizeInBytes: Long!
    destinationPath: String!
    externalBackupId: String!
    redoLogPositionOpt: Long
    serviceType: String!
    sourceId: Long!
    sourceType: String!
}

"Additional information about backup data path"
type SapHanaDataPathSpecObject {
    name: String!
}

type SapHanaDatabase implements CdmHierarchyObject & CdmHierarchySnappableNew & HierarchyObject & SapHanaSystemDescendantType & SapHanaSystemPhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    cdmId: String!
    "A link to view the snappable on the CDM cluster. For dev use only."
    cdmLink: String!
    "The cluster from which this object originated."
    cluster: Cluster!
    clusterUuid: UUID!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    dataPathSpec: SapHanaDataPathSpecObject
    dataPathType: String!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    forceFull: Boolean!
    "The fid of the hierarchy object."
    id: UUID!
    info: SapHanaDatabaseInfoObject
    isRelic: Boolean!
    logSnapshotConnection(
        after: String,
        before: String,
        "filter sap hana log snapshots by input"
        filter: SapHanaLogSnapshotFilterInput,
        first: Int,
        last: Int,
        "sort sap hana log snapshots by field"
        sortBy: SapHanaLogSnapshotSortByEnum,
        "sort order"
        sortOrder: SortOrderEnum
    ): SapHanaLogSnapshotConnection!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The list of missed snapshots for this VM"
    missedSnapshotConnection(
        after: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        first: Int
    ): MissedSnapshotCommonConnection
    "The list of missed snapshots for this VM"
    missedSnapshotGroupByConnection(
        after: String,
        before: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        first: Int,
        "group snapshots by field"
        groupBy: MissedSnapshotGroupByEnum!,
        last: Int,
        timezoneOffset: Float = 0.0
    ): MissedSnapshotGroupByConnection
    "The name of the hierarchy object."
    name: String!
    "the newest snapshot archived to AWS."
    newestArchivedSnapshot: CdmSnapshot
    "the newest snapshot replicated to a cluster."
    newestReplicatedSnapshot: CdmSnapshot
    "the most recent snapshot of this snappable"
    newestSnapshot: CdmSnapshot
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "the oldest snapshot of this snappable"
    oldestSnapshot: CdmSnapshot
    "the number of on-demand snapshots"
    onDemandSnapshotCount: Int!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    primaryClusterUuid: UUID!
    recoverableRangeConnection(
        after: String,
        before: String,
        "filter sap hana recoverable ranges by input"
        filter: SapHanaRecoverableRangeFilterInput,
        first: Int,
        last: Int,
        "sort sap hana recoverable ranges by field"
        sortBy: SapHanaRecoverableRangeSortByEnum,
        "sort order"
        sortOrder: SortOrderEnum
    ): SapHanaRecoverableRangeConnection!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    sapHanaSystem: SapHanaSystem!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The list of snapshots taken for this VM"
    snapshotConnection(
        after: String,
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        first: Int,
        last: Int,
        "sort snapshots by field"
        sortBy: CdmSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): CdmSnapshotConnection
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this VM's snapshots."
    snapshotGroupByConnection(
        after: String,
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        first: Int,
        "group snapshots by field"
        groupBy: CdmSnapshotGroupByEnum!,
        last: Int,
        timezoneOffset: Float = 0.0
    ): cdmSnapshotGroupByConnection
    systemId: String!
}

type SapHanaDatabaseConnection {
    count: Int!
    edges: [SapHanaDatabaseEdge!]!
    nodes: [SapHanaDatabase!]!
    pageInfo: PageInfo!
}

type SapHanaDatabaseEdge {
    cursor: String!
    node: SapHanaDatabase!
}

"Additional information about backint and database configuration"
type SapHanaDatabaseInfoObject {
    approxDbSizeInMb: Long!
    backintPath: String!
    databaseType: String!
    logBackupIntervalSecs: Int!
    numChannels: Int!
    paramFilePath: String!
    status: String!
}

type SapHanaHost {
    "The IP address or fully qualified domain name of the SAP HANA host."
    hostName: String!
    "The type of the SAP HANA system host. Possible values are MASTER, SLAVE, SECONDARY_MASTER or SECONDARY_SLAVE ."
    hostType: SapHanaHostHostTypeEnum!
    "The ID of the SAP HANA system host."
    hostUuid: String!
    "The local name of the SAP HANA host."
    sapHanaHostName: String
    "Required. The status of the SAP HANA system host."
    status: String!
}

"Information about sap hana hosts of the system"
type SapHanaHostObject {
    clusterUuid: UUID!
    host: PhysicalHost!
    hostName: String!
    hostType: String!
    hostUuid: String!
    status: String!
}

type SapHanaLogBackup {
    backupId: Long
    bytesTransferred: Long
    doesContainCatalogFile: Boolean
    endTime: DateTime
    files: [SapHanaLogBackupFiles!]
    startTime: DateTime
}

type SapHanaLogBackupFiles {
    backupId: Long
    backupSizeInBytes: Long
    destinationPath: String
    destinationType: String
    externalBackupId: String
    hostName: String
    logPositionInterval: SapHanaLogPositionInterval
    serviceTypeName: String
    sourceId: Long
    sourceTypeName: String
}

type SapHanaLogPositionInterval {
    newestLogPosition: Long
    oldestLogPosition: Long
}

type SapHanaLogSnapshot {
    "app metadata of log snapshots in SAP HANA"
    appMetadata: SapHanaLogSnapshotAppMetadata
    cdmId: String!
    clusterUuid: UUID!
    date: DateTime
    fid: String!
    internalTimestamp: Long!
    isArchived: Boolean!
    locationMap: String
    snappableId: String!
    snappableType: String!
}

type SapHanaLogSnapshotAppMetadata {
    backups: [SapHanaLogBackup!]
}

type SapHanaLogSnapshotConnection {
    count: Int!
    edges: [SapHanaLogSnapshotEdge!]!
    nodes: [SapHanaLogSnapshot!]!
    pageInfo: PageInfo!
}

type SapHanaLogSnapshotEdge {
    cursor: String!
    node: SapHanaLogSnapshot!
}

type SapHanaPatchSystemResponse {
    "Status of the job scheduled to refresh the SAP HANA system."
    asyncRequestStatus: AsyncRequestStatus
    "Summary of the updated SAP HANA system object."
    systemSummary: SapHanaSystemSummary
}

type SapHanaRecoverableRange {
    baseFullSnapshotId: String
    cdmId: String!
    clusterUuid: UUID!
    dbId: String!
    endTime: DateTime
    fid: String!
    isArchived: Boolean!
    startTime: DateTime
}

type SapHanaRecoverableRangeConnection {
    count: Int!
    edges: [SapHanaRecoverableRangeEdge!]!
    nodes: [SapHanaRecoverableRange!]!
    pageInfo: PageInfo!
}

type SapHanaRecoverableRangeEdge {
    cursor: String!
    node: SapHanaRecoverableRange!
}

type SapHanaSslInfo {
    "The encryption provider for the SAPA HANA system. Possible values are OPENSSL, COMMON_CRYPTO, SAP_CRYPTO."
    encryptionProvider: SapHanaSslInfoEncryptionProviderEnum!
    "The path where the encryption key for the SAP HANA system is stored."
    keyStorePath: String!
}

type SapHanaSystem implements CdmHierarchyObject & HierarchyObject {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    cdmId: String!
    "The cluster from which this object originated."
    cluster: Cluster!
    clusterUuid: UUID!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "List of descendants"
    descendantConnection(
        after: String,
        filter: [Filter!],
        first: Int,
        "provide optional snappable hierarchy for RBAC and SLA, none value is assumed to be All snappable hierarchy"
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): SapHanaSystemDescendantTypeConnection!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    hosts: [SapHanaHostObject!]!
    "The fid of the hierarchy object."
    id: UUID!
    instanceNumber: String!
    lastRefreshTime: DateTime
    lastStatusUpdateTime: DateTime
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "List of physical children"
    physicalChildConnection(
        after: String,
        filter: [Filter!],
        first: Int,
        "provide optional snappable hierarchy for RBAC and SLA, none value is assumed to be All snappable hierarchy"
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): SapHanaSystemPhysicalChildTypeConnection!
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    primaryClusterUuid: UUID!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    sid: String!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
    status: SapHanaSystemStatus!
    statusMessage: [String!]!
}

type SapHanaSystemConnection {
    count: Int!
    edges: [SapHanaSystemEdge!]!
    nodes: [SapHanaSystem!]!
    pageInfo: PageInfo!
}

type SapHanaSystemDescendantTypeConnection {
    count: Int!
    edges: [SapHanaSystemDescendantTypeEdge!]!
    nodes: [SapHanaSystemDescendantType!]!
    pageInfo: PageInfo!
}

type SapHanaSystemDescendantTypeEdge {
    cursor: String!
    node: SapHanaSystemDescendantType!
}

type SapHanaSystemEdge {
    cursor: String!
    node: SapHanaSystem!
}

type SapHanaSystemInfo {
    "The version of the SAP HANA system."
    hanaVersion: String!
    "Indicates whether the SAP HANA system has replication enabled."
    isSystemReplicationEnabled: Boolean!
}

type SapHanaSystemPhysicalChildTypeConnection {
    count: Int!
    edges: [SapHanaSystemPhysicalChildTypeEdge!]!
    nodes: [SapHanaSystemPhysicalChildType!]!
    pageInfo: PageInfo!
}

type SapHanaSystemPhysicalChildTypeEdge {
    cursor: String!
    node: SapHanaSystemPhysicalChildType!
}

type SapHanaSystemSummary {
    "The container type of the SAP HANA system. Possible values are SINGLE_CONTAINER, MULTI_CONTAINER."
    containerType: SapHanaSystemSummaryContainerTypeEnum!
    "Required. "
    hosts: [SapHanaHost!]!
    "Required. The ID of the SAP HANA system."
    id: String!
    "The instance number of the SAP HANA system."
    instanceNumber: String!
    "The UTC timestamp for when the SAP HANA system was last refreshed."
    lastRefreshTime: DateTime
    "The number of databases in the SAP HANA system."
    numDbs: Int!
    "Required. The SAP System Identification (SID) code for the SAP HANA system."
    sid: String!
    slaAssignable: SlaAssignable
    sslInfo: SapHanaSslInfo
    "Required. The status of the SAP HANA system."
    status: SapHanaSystemSummaryStatusEnum!
    "The message associated with the current SAP HANA system status."
    statusMessage: String
    systemInfo: SapHanaSystemInfo
    "Required. The username of the SAP HANA system."
    username: String!
}

type ScaleRuntime {
    deadline: DateTime
    newCount: Int!
    oldCount: Int!
    taskchainUuid: String!
}

"Metadata for rendering a scheduled report."
type ScheduledReport {
    createdAt: DateTime!
    creator: User!
    dailyTime: LocalTime
    hasCSVAttachment: Boolean!
    hasPDFAttachment: Boolean!
    "ID of the scheduled report."
    id: Int!
    lastEditor: User!
    lastUpdatedAt: DateTime!
    monthlyDate: Int
    monthlyTime: LocalTime
    recipients: [User!]!
    "The custom report id corresponding to this scheduled report."
    reportId: Int!
    title: String!
    weeklyDays: [WeekDayEnum!]
    weeklyTime: LocalTime
}

type ScheduledReportConnection {
    count: Int!
    edges: [ScheduledReportEdge!]!
    nodes: [ScheduledReport!]!
    pageInfo: PageInfo!
}

type ScheduledReportEdge {
    cursor: String!
    node: ScheduledReport!
}

"""

Supported in v5.0+
"""
type SearchResponse {
    """

    Supported in v5.0+
    """
    fileVersions: [FileVersion!]!
    """

    Supported in v5.0+
    Just the filename without the whole path
    """
    filename: String
    """

    Supported in v5.0+
    """
    path: String
}

"""

Supported in v5.0+
"""
type SearchResponseListResponse {
    """

    Supported in v5.0+
    List of matching objects
    """
    data: [SearchResponse!]!
    """

    Supported in v5.0+
    If there is more
    """
    hasMore: Boolean
    """

    Supported in v5.0+
    Total list responses
    """
    total: Long
}

type SecurityGroup {
    id: String!
    name: String!
}

type SeedEnabledPoliciesReply {
    policies: [ClassificationPolicyDetail!]!
}

type SeedInitialPoliciesReply {
    policies: [ClassificationPolicyDetail!]!
}

type SetupAzureO365ExocomputeResp {
    clusterId: String!
    taskchainId: String!
}

type ShareFileset implements CdmHierarchyObject & CdmHierarchySnappableNew & FilesetTemplateDescendantType & FilesetTemplatePhysicalChildType & HierarchyObject & HierarchySnappable & HostShareDescendantType & HostSharePhysicalChildType & PhysicalHostDescendantType & PhysicalHostPhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    cdmId: String!
    "A link to view the snappable on the CDM cluster. For dev use only."
    cdmLink: String!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    hardlinkSupportEnabled: Boolean!
    host: PhysicalHost!
    "The fid of the hierarchy object."
    id: UUID!
    isPassThrough: Boolean!
    isRelic: Boolean!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The list of missed snapshots for this VM"
    missedSnapshotConnection(
        after: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        first: Int
    ): MissedSnapshotCommonConnection
    "The list of missed snapshots for this VM"
    missedSnapshotGroupByConnection(
        after: String,
        before: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        first: Int,
        "group snapshots by field"
        groupBy: MissedSnapshotGroupByEnum!,
        last: Int,
        timezoneOffset: Float = 0.0
    ): MissedSnapshotGroupByConnection
    "The name of the hierarchy object."
    name: String!
    "the newest snapshot archived to AWS."
    newestArchivedSnapshot: CdmSnapshot
    "the newest snapshot replicated to a cluster."
    newestReplicatedSnapshot: CdmSnapshot
    "the most recent snapshot of this snappable"
    newestSnapshot: CdmSnapshot
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "the oldest snapshot of this snappable"
    oldestSnapshot: CdmSnapshot
    "the number of on-demand snapshots"
    onDemandSnapshotCount: Int!
    pathExceptions: [String!]!
    pathExcluded: [String!]!
    pathIncluded: [String!]!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "Share type of this fileset"
    shareType: ShareTypeEnum!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The list of snapshots taken for this VM"
    snapshotConnection(
        after: String,
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        first: Int,
        last: Int,
        "sort snapshots by field"
        sortBy: CdmSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): CdmSnapshotConnection
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this VM's snapshots."
    snapshotGroupByConnection(
        after: String,
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        first: Int,
        "group snapshots by field"
        groupBy: CdmSnapshotGroupByEnum!,
        last: Int,
        timezoneOffset: Float = 0.0
    ): cdmSnapshotGroupByConnection
    symlinkResolutionEnabled: Boolean!
}

type SlaAssignResult {
    success: Boolean!
}

"""

Supported in v5.0+
"""
type SlaAssignable {
    """

    Supported in v5.0+
    v5.0-v5.1: ID of the configured SLA domain
    v5.2+: The ID of the SLA Domain configured directly on the Rubrik object.
    """
    configuredSlaDomainId: String!
    """

    Supported in v5.0+
    v5.0-v5.1: name of the configured SLA domain
    v5.2+: The name of the SLA Domain configured directly on the Rubrik object.
    """
    configuredSlaDomainName: String!
    """

    Supported in v5.2+
    Specifies whether the SLA Domain is used for protection or retention.
    """
    configuredSlaDomainType: ConfiguredSlaTypeEnum!
    """

    Required. Supported in v5.0+
    v5.0-v5.1:
    v5.2+: The ID of the Rubrik object.
    """
    id: String!
    """

    Supported in v5.1+
    v5.1: A Boolean that indicates whether the configured SLA domain is Retention Locked. When this value is 'true', the configured SLA domain is a Retention Lock SLA Domain.
    v5.2+: Indicates whether the configured SLA Domain is Retention Locked. When this value is 'true', the configured SLA Domain is a Retention Lock SLA Domain.
    """
    isConfiguredSlaDomainRetentionLocked: Boolean
    """

    Required. Supported in v5.0+
    v5.0-v5.1:
    v5.2+: The name of the Rubrik object.
    """
    name: String!
    """

    Supported in v5.0+
    v5.0-v5.1:
    v5.2+: The ID of the cluster that manages the Rubrik object.
    """
    primaryClusterId: String!
    """

    Supported in v5.2+
    The UTC time when the SLA Domain was last updated.
    """
    slaLastUpdateTime: DateTime
}

type SlaDomainConnection {
    count: Int!
    edges: [SlaDomainEdge!]!
    nodes: [SlaDomain!]!
    pageInfo: PageInfo!
}

type SlaDomainEdge {
    cursor: String!
    node: SlaDomain!
}

"SLA Domain with warnings detail"
type SlaDomainWithWarnings {
    slaDomain: SlaDomain!
    warnings: [SlaWarning!]!
}

type SlaDuration {
    duration: Int!
    unit: RetentionUnitEnum!
}

type SlaLogFrequencyConfigResult {
    retention: SlaDuration
}

type SlaResult {
    success: Boolean!
}

"Warning for SLA Assignment for each object"
type SlaWarning {
    code: AssignSLAWarningsEnum!
    objectIds: [String!]!
    severity: WarningSeverityEnum!
}

"An object that can be snapshotted."
type Snappable {
    "The number of snapshots that have been archived."
    archiveSnapshots: Int
    "The amount of storage taken by archived snapshots."
    archiveStorage: Long
    "The cluster the snappable belongs to"
    cluster: Cluster
    "The current compliance status of the snappable."
    complianceStatus: ComplianceStatusEnum!
    "The change from transferred bytes to physical bytes"
    dataReduction: Float
    fid: UUID
    "The id of the snappable."
    id: String!
    "The timestamp of the last taken snapshot."
    lastSnapshot: DateTime
    "The number of snapshots locally present."
    localSnapshots: Int
    location: String!
    "Logical bytes taken by snapshots of this snappable."
    logicalBytes: Long
    logicalDataReduction: Float
    "The number of snapshots that were missed."
    missedSnapshots: Int!
    "The name of the snappable."
    name: String!
    "The object type of the snappable."
    objectType: ObjectTypeEnum!
    "Physical bytes taken by snapshots of this snappable."
    physicalBytes: Long
    "The date and time when the snappable was last protected."
    protectedOn: DateTime
    "The protection status of the snappable."
    protectionStatus: ProtectionStatusEnum!
    "The time this snappable data was pulled from cdm."
    pullTime: DateTime!
    "The number of snapshots that have been replicated."
    replicaSnapshots: Int
    "The amount of storage taken by replicated snapshots."
    replicaStorage: Long
    "The sla domain of the snappable."
    slaDomain: SlaDomain
    "The total number of snapshots present for the snapshot."
    totalSnapshots: Int!
    "Bytes ingested over the network for this snappable."
    transferredBytes: Long
}

type SnappableAggregation {
    archiveStorage: Long!
    missedSnapshots: Int!
    physicalBytes: Long!
    replicaStorage: Long!
    totalSnapshots: Int!
}

type SnappableChart {
    focus: ReportFocusEnum!
    groupBy: [SnappableGroupByEnum!]
    name: String!
}

type SnappableConnection {
    aggregation: SnappableAggregation!
    count: Int!
    edges: [SnappableEdge!]!
    nodes: [Snappable!]!
    pageInfo: PageInfo!
}

type SnappableEdge {
    cursor: String!
    node: Snappable!
}

"Snappable data with groupby info applied to it."
type SnappableGroupBy {
    "The data groupby info."
    groupByInfo: SnappableGroupByInfo!
    "Paginated snappable data."
    snappableConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "sort snappables by field"
        sortBy: SnappableSortByEnum = Name,
        "sort order"
        sortOrder: SortOrderEnum
    ): SnappableConnection!
    "Further provide groupings for the data."
    snappableGroupBy(
        "group snappables by field"
        groupBy: SnappableGroupByEnum!
    ): [SnappableGroupBy!]!
}

type SnappableGroupByConnection {
    count: Int!
    edges: [SnappableGroupByEdge!]!
    nodes: [SnappableGroupBy!]!
    pageInfo: PageInfo!
}

type SnappableGroupByEdge {
    cursor: String!
    node: SnappableGroupBy!
}

type SnappableInstanceType {
    awsInstanceType: AwsInstanceType!
}

type SnappableInstanceTypeConnection {
    count: Int!
    edges: [SnappableInstanceTypeEdge!]!
    nodes: [SnappableInstanceType!]!
    pageInfo: PageInfo!
    suggestInstanceType: SnappableInstanceType
}

type SnappableInstanceTypeEdge {
    cursor: String!
    node: SnappableInstanceType!
}

type SnappableRecoverySpec {
    awsSpec: AwsVMRecoverySpec!
}

type SnappableRecoverySpecMap {
    "the plan type, it can be FAILOVER and TEST_FAILOVER"
    planType: String!
    "the recovery spec"
    recoverySpec: SnappableRecoverySpec!
    "the fid of the recovery spec"
    recoverySpecFid: String!
    "the snappable Fid"
    snappableFid: String!
}

type SnappableSecurityGroup {
    description: String!
    id: String!
    name: String!
    ownerId: String!
    securityGroupId: String!
    "vpc of the security group"
    vpc: Vpc
}

type SnappableSecurityGroupConnection {
    count: Int!
    edges: [SnappableSecurityGroupEdge!]!
    nodes: [SnappableSecurityGroup!]!
    pageInfo: PageInfo!
}

type SnappableSecurityGroupEdge {
    cursor: String!
    node: SnappableSecurityGroup!
}

type SnappableStorageVolumeType {
    awsStorageVolumeType: AwsStorageVolumeType!
}

type SnappableStorageVolumeTypeConnection {
    count: Int!
    edges: [SnappableStorageVolumeTypeEdge!]!
    nodes: [SnappableStorageVolumeType!]!
    pageInfo: PageInfo!
}

type SnappableStorageVolumeTypeEdge {
    cursor: String!
    node: SnappableStorageVolumeType!
}

type SnappableSubnet {
    availabilityZone: String!
    cidrBlock: AddressBlockV4
    id: String!
    name: String!
    subnetId: String!
    "vpc of the subnet"
    vpc: Vpc
}

type SnappableSubnetConnection {
    count: Int!
    edges: [SnappableSubnetEdge!]!
    nodes: [SnappableSubnet!]!
    pageInfo: PageInfo!
}

type SnappableSubnetEdge {
    cursor: String!
    node: SnappableSubnet!
}

type SnappableTable {
    focus: ReportFocusEnum!
    groupBy: [SnappableGroupByEnum!]
    name: String!
    selectedColumns: [SnappableTableColumnEnum!]!
    sortBy: SnappableSortByEnum
    sortOrder: SortOrderEnum
}

type SnappableTypeSummary {
    count: Int!
    snappableType: HierarchyObjectTypeEnum!
}

type SnapshotDelta {
    deltaAmount: Long!
    deltaType: DeltaTypeEnum!
}

"A generic snapshot type"
type SnapshotDistribution {
    "The id of the snappable"
    id: UUID!
    "Number of on demand snapshots"
    onDemandCount: Long!
    "Number of retrieved snapshots"
    retrievedCount: Long!
    "Number of scheduled snapshots"
    scheduledCount: Long!
    "Total number of snapshots"
    totalCount: Long!
}

type SnapshotFile {
    absolutePath: String!
    displayPath: String!
    fileMode: FileModeEnum!
    filename: String!
    lastModified: DateTime!
    path: String!
    size: Long!
    statusMessage: String!
}

type SnapshotFileConnection {
    count: Int!
    edges: [SnapshotFileEdge!]!
    nodes: [SnapshotFile!]!
    pageInfo: PageInfo!
}

type SnapshotFileDelta {
    childrenDeltas: [SnapshotDelta!]!
    file: SnapshotFile!
    selfDeltas: [SnapshotDelta!]!
}

type SnapshotFileDeltaConnection {
    count: Int!
    currentSnapshot: CdmSnapshot!
    edges: [SnapshotFileDeltaEdge!]!
    nodes: [SnapshotFileDelta!]!
    pageInfo: PageInfo!
    previousSnapshot: CdmSnapshot
}

type SnapshotFileDeltaEdge {
    cursor: String!
    node: SnapshotFileDelta!
}

type SnapshotFileEdge {
    cursor: String!
    node: SnapshotFile!
}

"""

Supported in v5.2+
"""
type SnapshotLocationRetentionInfo {
    """

    Supported in v5.2+
    Time when the snapshot expired or is expected to expire at this location. This field will only be set if the snapshot has ever existed at the location. If the snapshot is present at the location, but the expiration time calculation is pending, this field will be absent. If the expiration time calculation is complete and the field is still absent, the snapshot will be retained forever at this location.
    """
    expirationTime: DateTime
    """

    Required. Supported in v5.2+
    ID of the location
    """
    id: String!
    """

    Supported in v5.2+
    A Boolean that indicates whether expiration date for snapshot has been calculated. This field will be absent if the snapshot has never existed at this location.
    """
    isExpirationDateCalculated: Boolean
    """

    Supported in v5.2+
    Indicates whether expiration information of the snapshot is unavailable at this location. This field is always and only present for replication locations. Its value is true if and only if the replicated snapshots are from pre-5.2 cluster.
    """
    isExpirationInformationUnavailable: Boolean
    """

    Supported in v5.2+
    Boolean that specifies whether the snapshot is present at this location. When this value is 'false,' the snapshot is expired at this location. Because retention information is unreliable for locations where the snapshots are not present, confirming that this value is 'true' is the best practice.
    """
    isSnapshotPresent: Boolean!
    """

    Required. Supported in v5.2+
    Name of the location
    """
    name: String!
    """

    Supported in v5.2+
    The tag to determine what frequency the snapshot corresponds to at this location. The snapshot tag can be hourly, daily, weekly, monthly, quarterly, or yearly depending on the SLA frequency which is used to determine the retention of the snapshot. A value of "Ready for Deletion" means that the snapshot will be deleted soon. A value of "Forever" means that the snapshot will never be deleted. This field is absent when the tag computation is incomplete.
    """
    snapshotFrequency: String
}

type SnapshotResult {
    snapshotFid: String!
    snapshotTime: Long!
}

type SnapshotResultConnection {
    count: Int!
    edges: [SnapshotResultEdge!]!
    nodes: [SnapshotResult!]!
    pageInfo: PageInfo!
}

type SnapshotResultEdge {
    cursor: String!
    node: SnapshotResult!
}

"""

Supported in v5.2+
"""
type SnapshotRetentionInfo {
    """

    Supported in v5.2+
    List of snapshot retention information on the archival locations.
    """
    archivalInfos: [SnapshotLocationRetentionInfo!]!
    """

    Supported in v5.2+
    Snapshot retention information such as frequency tag and expected expiration time on the cloud native locations.
    """
    cloudNativeLocationInfo: [SnapshotLocationRetentionInfo!]!
    """

    Supported in v5.2+
    Snapshot retention information on the local cluster.
    """
    localInfo: SnapshotLocationRetentionInfo
    """

    Supported in v5.2+
    List of snapshot retention information on the replicated locations.
    """
    replicationInfos: [SnapshotLocationRetentionInfo!]!
}

type SnapshotSchedule {
    daily: DailySnapshotSchedule
    hourly: HourlySnapshotSchedule
    minute: MinuteSnapshotSchedule
    monthly: MonthlySnapshotSchedule
    quarterly: QuarterlySnapshotSchedule
    weekly: WeeklySnapshotSchedule
    yearly: YearlySnapshotSchedule
}

type SonarContentReportChart {
    focus: ReportFocusEnum!
    groupBy: [SonarContentReportGroupByEnum!]
    name: String!
}

type SonarContentReportTable {
    focus: ReportFocusEnum!
    groupBy: [SonarContentReportGroupByEnum!]
    name: String!
    selectedColumns: [SonarContentReportTableColumnEnum!]!
    sortBy: SonarContentReportSortByEnum
    sortOrder: SortOrderEnum
}

type SonarContentReportTableRow {
    analyzerGroupResults: [AnalyzerGroupResult!]!
    analyzerId: String!
    analyzerResults: [AnalyzerResult!]!
    cluster: String!
    fileName: String!
    filesWithHits: Int!
    hits: Hits
    id: String!
    location: String!
    objectName: String!
    objectType: HierarchyObjectTypeEnum!
    path: String!
    policyId: String!
    size: Long!
    slaDomainId: String!
    snappableFid: String!
    snapshotTimestamp: Long!
}

type SonarContentReportTableRowConnection {
    count: Int!
    edges: [SonarContentReportTableRowEdge!]!
    nodes: [SonarContentReportTableRow!]!
    pageInfo: PageInfo!
}

type SonarContentReportTableRowEdge {
    cursor: String!
    node: SonarContentReportTableRow!
}

type SonarReportChart {
    focus: ReportFocusEnum!
    groupBy: [SonarReportGroupByEnum!]
    name: String!
}

type SonarReportGroupByResult {
    count: Long!
    groupByValue: String!
    timeSeriesResults: [TimeSeriesResult!]!
}

type SonarReportGroupByResultConnection {
    count: Int!
    edges: [SonarReportGroupByResultEdge!]!
    nodes: [SonarReportGroupByResult!]!
    pageInfo: PageInfo!
}

type SonarReportGroupByResultEdge {
    cursor: String!
    node: SonarReportGroupByResult!
}

type SonarReportTable {
    focus: ReportFocusEnum!
    groupBy: [SonarReportGroupByEnum!]
    name: String!
    selectedColumns: [SonarReportTableColumnEnum!]!
    sortBy: SonarReportSortByEnum
    sortOrder: SortOrderEnum
}

type SonarReportTableRow {
    numHighRiskLocations: Int!
    numObjects: Int!
    numViolatedFiles: Int!
    policyId: String!
    policyName: String!
    policyStatus: SonarReportTablePolicyStatusEnum!
    violations: Int!
}

type SonarReportTableRowConnection {
    count: Int!
    edges: [SonarReportTableRowEdge!]!
    nodes: [SonarReportTableRow!]!
    pageInfo: PageInfo!
}

type SonarReportTableRowEdge {
    cursor: String!
    node: SonarReportTableRow!
}

type SonarUserActivity {
    auditStatus: String!
    auditTs: String!
    domainName: String!
    eventId: DataGovAuditEventTypeEnum!
    eventName: String!
    paginationId: String!
    path: String!
    snappable: HierarchyObject!
    userName: String!
}

type SonarUserActivityConnection {
    count: Int!
    edges: [SonarUserActivityEdge!]!
    nodes: [SonarUserActivity!]!
    pageInfo: PageInfo!
}

type SonarUserActivityEdge {
    cursor: String!
    node: SonarUserActivity!
}

type Source {
    stringValue: String!
}

type SourceBlueprintInfo {
    blueprintId: String!
    sourceChildInfos: [SourceChildInfo!]!
}

type SourceChildInfo {
    childInfo: ChildInfo!
    failoverChildId: String!
}

type SpecificReplicationSpec {
    bidirectionalSpec: BidirectionalReplicationSpec
    cloudLocationSpec: ReplicationToCloudLocationSpec
    cloudRegionSpec: ReplicationToCloudRegionSpec
    unidirectionalSpec: UnidirectionalReplicationSpec
}

type StartCrawlReply {
    crawlId: String!
}

type StartNasAuditReply {
    id: String!
}

type StartSonarAuditReply {
    ids: [String!]!
}

type StartTimeAttributes {
    dayOfWeek: DayOfWeekOpt
    hour: Int!
    minute: Int!
}

type StartUpgradeReply {
    context: Context
}

type Status {
    stringValue: String!
}

type StopNasAuditReply {
    clusterUuid: String!
    hostId: String!
    shareName: String!
}

type StopSonarAuditReply {
    ids: [String!]!
}

type StorageAccount {
    accessTier: TierEnum!
    id: String!
    kind: String!
    name: String!
    regionName: String!
    resourceGroup: ResourceGroup
    sku: SkuEnum!
}

type StorageAccountConnection {
    count: Int!
    edges: [StorageAccountEdge!]!
    nodes: [StorageAccount!]!
    pageInfo: PageInfo!
}

type StorageAccountEdge {
    cursor: String!
    node: StorageAccount!
}

type Subnet {
    id: String!
    name: String!
    securityGroup: SecurityGroup
}

type SubnetConnection {
    count: Int!
    edges: [SubnetEdge!]!
    nodes: [Subnet!]!
    pageInfo: PageInfo!
}

type SubnetEdge {
    cursor: String!
    node: Subnet!
}

"A subnet group on AWS."
type SubnetGroup {
    arn: String!
    name: String!
    subnets: [AwsNativeSubnet!]!
    vpcId: String!
}

type SupportPortalLoginReply {
    status: UpgradeStatus
}

type SupportPortalLogoutReply {
    status: UpgradeStatus
}

type SupportPortalStatusReply {
    isLoggedIn: Boolean!
    status: UpgradeStatus
    username: String!
}

"Response type for getting information about a support tunnel"
type SupportTunnelInfoResp {
    enabledTime: DateTime
    inactivityTimeoutInSeconds: Long
    isTunnelEnabled: Boolean!
    lastActivityTime: DateTime
    nodeId: String!
    port: Long
}

type TableFilters {
    ProtectionTaskDetailsTable: ProtectionTaskDetailsTableFilter!
    RecoveryTaskDetailsTable: RecoveryTaskDetailsTableFilter!
}

type Tag {
    key: String!
    value: String!
}

"Represents the sla id and name"
type TagRuleEffectiveSla {
    id: String!
    name: String!
}

"Tag represents a tag key value pair"
type TagRuleTag {
    matchAllValues: Boolean!
    tagKey: String!
    tagValue: String!
}

"Represents the error in response to triggering the on-demand snapshot of the snappable"
type TakeOnDemandSnapshotError {
    error: String!
    snappableId: String!
}

"Represents the response to the take on-demand snapshot operation. For each snappable ID that the on-demand snapshot was triggered, it either ends up being in the taskchainUuids or the errors map depending on if the operation succeeded or failed respectively."
type TakeOnDemandSnapshotReply {
    errors: [TakeOnDemandSnapshotError!]!
    taskchainUuids: [TakeOnDemandSnapshotTaskchainUuid!]!
}

"Represents the taskchain UUID in response to triggering the on-demand snapshot of snappable"
type TakeOnDemandSnapshotTaskchainUuid {
    snappableId: String!
    taskchainUuid: String!
}

type TakeScreenshotReply {
    screenshots: [String!]!
}

"Result of the delete target operation"
type TargetDeleteResult {
    success: Boolean!
}

"Target Mapping info"
type TargetMapping {
    id: UUID!
    name: String!
    targetTemplate: TargetTemplate
    targetType: TargetTypeEnum!
    targets: [Target!]
}

type TargetMappingDeletionResult {
    success: Boolean!
}

type TargetPauseResult {
    success: Boolean!
}

type TargetResumeResult {
    success: Boolean!
}

type TargetSite {
    stringValue: String!
}

"A task details."
type TaskDetail {
    archivalTarget: String
    clusterLocation: String!
    clusterName: String!
    clusterType: String!
    clusterUuid: UUID!
    dataReduction: Float
    dataTransferred: Long
    dedupRatio: Float
    directArchive: String
    duration: Long!
    endTime: DateTime!
    failureReason: String
    id: Long!
    location: String!
    logicalBytes: Long
    logicalDataReduction: Float
    logicalDedupRatio: Float
    objectFid: String!
    objectName: String!
    objectType: String!
    physicalBytes: Long
    protectedVolume: String
    recoveryPoint: String
    recoveryPointType: String
    replicationSource: String
    replicationTarget: String
    reportJobInstanceId: String!
    slaDomainId: String!
    slaDomainName: String!
    snapshotConsistency: String
    startTime: DateTime!
    status: String!
    taskCategory: String!
    taskType: String!
    totalFilesTransferred: Long
    userName: String
}

type TaskDetailChart {
    focus: ReportFocusEnum!
    groupBy: [TaskDetailGroupByEnum!]
    name: String!
}

type TaskDetailClusterType {
    stringValue: String!
}

type TaskDetailConnection {
    count: Int!
    edges: [TaskDetailEdge!]!
    nodes: [TaskDetail!]!
    pageInfo: PageInfo!
}

type TaskDetailEdge {
    cursor: String!
    node: TaskDetail!
}

"Task detail with groupby info applied to it."
type TaskDetailGroupBy {
    "The data groupby info."
    groupByInfo: TaskDetailGroupByInfo!
    "Paginated task detail data."
    taskDetailConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "sort task detail by field"
        sortBy: TaskDetailSortByEnum = EndTime,
        "task detail sort order"
        sortOrder: SortOrderEnum = Desc
    ): TaskDetailConnection!
    taskDetailGroupBy(
        "group task detail by a field"
        groupBy: TaskDetailGroupByEnum!
    ): [TaskDetailGroupBy!]!
}

type TaskDetailGroupByConnection {
    count: Int!
    edges: [TaskDetailGroupByEdge!]!
    nodes: [TaskDetailGroupBy!]!
    pageInfo: PageInfo!
}

type TaskDetailGroupByEdge {
    cursor: String!
    node: TaskDetailGroupBy!
}

type TaskDetailObjectType {
    stringValue: String!
}

type TaskDetailTable {
    focus: ReportFocusEnum!
    groupBy: [TaskDetailGroupByEnum!]
    name: String!
    selectedColumns: [TaskDetailTableColumnEnum!]!
    sortBy: TaskDetailSortByEnum
    sortOrder: SortOrderEnum
}

"A backup task summary."
type TaskSummary {
    clusterUuid: UUID!
    date: DateTime!
    "Location of the associated backup task summary."
    location: String
    "The number of the canceled tasks."
    numCanceled: Int!
    "The number of the expected tasks."
    numExpected: Int!
    "The number of the failed and missed tasks."
    numFailed: Int!
    "The number of the successful tasks."
    numSucceeded: Int!
    "Object name of the associated backup task summary."
    objectName: String!
    "Object type of the associated backup task summary."
    objectType: ObjectTypeEnum!
    slaDomainId: String!
    "slaDomain name of the object."
    slaDomainName: String!
    "Snappable Id of the associated backup task summary"
    snappbleId: UUID!
}

type TaskSummaryAggregation {
    NumOfCanceled: Int!
    NumOfExpected: Int!
    NumOfFailed: Int!
    NumOfSucceeded: Int!
}

type TaskSummaryChart {
    focus: ReportFocusEnum!
    groupBy: [TaskSummaryGroupByEnum!]
    name: String!
}

type TaskSummaryConnection {
    aggregation: TaskSummaryAggregation!
    count: Int!
    edges: [TaskSummaryEdge!]!
    nodes: [TaskSummary!]!
    pageInfo: PageInfo!
}

type TaskSummaryEdge {
    cursor: String!
    node: TaskSummary!
}

"Task summary with groupby info applied to it."
type TaskSummaryGroupBy {
    "The data groupby info."
    groupByInfo: TaskSummaryGroupByInfo!
    "Paginated task summary data."
    taskSummaryConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "sort task summary by field"
        sortBy: TaskSummarySortByEnum = ObjectName,
        "sort order"
        sortOrder: SortOrderEnum
    ): TaskSummaryConnection!
    taskSummaryGroupBy(
        "group task summary by a field"
        groupBy: TaskSummaryGroupByEnum!
    ): [TaskSummaryGroupBy!]!
}

type TaskSummaryGroupByConnection {
    count: Int!
    edges: [TaskSummaryGroupByEdge!]!
    nodes: [TaskSummaryGroupBy!]!
    pageInfo: PageInfo!
}

type TaskSummaryGroupByEdge {
    cursor: String!
    node: TaskSummaryGroupBy!
}

type TaskSummaryTable {
    focus: ReportFocusEnum!
    groupBy: [TaskSummaryGroupByEnum!]
    name: String!
    selectedColumns: [TaskReportTableColumnEnum!]!
    sortBy: TaskSummarySortByEnum
    sortOrder: SortOrderEnum
}

"Taskchain"
type Taskchain {
    account: String!
    component: String!
    config: String!
    currentTaskExecutionAttempts: Int!
    currentTaskIndex: Int!
    endTime: DateTime
    error: String!
    id: Long!
    jobId: Long!
    jobType: String!
    name: String!
    parentTaskchainId: String!
    podName: String!
    priority: Int!
    progress: Long!
    progressedAt: DateTime
    startTime: DateTime
    state: TaskchainStateEnum!
    taskchainUuid: String!
    workflowName: String!
}

type TaskchainInfo {
    appId: String!
    taskchainId: String!
}

"A range of time"
type TimeRange {
    "End of the time range"
    end: DateTime!
    "Start of the time range"
    start: DateTime!
}

"A range of time and the unit of that range"
type TimeRangeWithUnit {
    "End of the time range"
    end: DateTime!
    "Start of the time range"
    start: DateTime!
    "Unit of the time range"
    unit: TimeUnitEnum!
}

type TimeSeriesResult {
    count: Long!
    timestamp: String!
}

type TimelineEntry {
    day: String!
    hits: Hits
    policyId: String!
}

"Lambda job information on certain cluster "
type TriggerRansomwareDetectionReply {
    clusterUuid: String!
    jobId: String!
}

type UnidirectionalReplicationSpec {
    replicationTargetId: String!
    replicationTargetName: String!
    retention: Int!
    retentionUnit: RetentionUnitEnum!
    "The cluster to which this SLA will replicate the snapshots."
    targetCluster: Cluster
}

"The status of update indexing status call. For each snappable ID in the request: an entry in errors if failed."
type UpdateCloudNativeIndexingStatusReply {
    errors: [UpdateIndexingStatusError!]!
}

type UpdateIndexingStatusError {
    error: String!
    snappableId: String!
}

type UpdateLdapConfigReply {
    ldapConfig: LDAPConfig
}

"Cluster upgrade data with groupby info applied to it."
type UpgradeInfoGroupBy {
    "Paginated snappable data."
    clusterConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "sort upgradeInfo by field"
        sortBy: UpgradeInfoSortByEnum = ClusterType,
        "cluster sort order"
        sortOrder: SortOrderEnum = Desc
    ): ClusterConnection!
    "Further provide groupings for the data."
    clusterGroupBy(
        after: String,
        before: String,
        first: Int,
        "group by field"
        groupBy: UpgradeInfoGroupByEnum!,
        last: Int
    ): [UpgradeGroupByInfo!]!
    "The data groupby info."
    groupByInfo: UpgradeGroupByInfo!
}

type UpgradeInfoGroupByConnection {
    count: Int!
    edges: [UpgradeInfoGroupByEdge!]!
    nodes: [UpgradeInfoGroupBy!]!
    pageInfo: PageInfo!
}

type UpgradeInfoGroupByEdge {
    cursor: String!
    node: UpgradeInfoGroupBy!
}

type UpgradeJobReply {
    message: String!
    success: Boolean!
}

type UpgradeJobReplyWithUuid {
    UpgradeJobReply: UpgradeJobReply!
    uuid: String!
}

type UpgradeStatus {
    code: String!
    excepshuns: String!
    message: String!
}

type UpgradeStatusReply {
    currentState: String!
    currentStateName: String!
    currentStateProgress: String!
    finishedStates: String!
    mode: String!
    nodeName: String!
    pendingStates: String!
    progress: String!
    tarballName: String!
    upgradeProgressPercentage: String!
    upgradeStatus: UpgradeStatus
    upgradeTimeLeftSecs: String!
    upgradeTimestamp: String!
    userSurfacedTaskName: String!
}

type User {
    domain: UserDomainEnum!
    email: String!
    emailConfig: [EventDigest!]!
    groups: [String!]!
    id: String!
    isAccountOwner: Boolean!
    lastLogin: DateTime
    roles: [Role!]!
    status: UserStatusEnum!
    username: String!
}

type UserAudit {
    auditType: UserAuditTypeEnum
    cluster: Cluster
    id: ID!
    message: String!
    objectId: String!
    objectName: String
    objectType: UserAuditObjectTypeEnum!
    severity: UserAuditSeverityEnum
    status: UserAuditStatusEnum!
    time: DateTime!
    userName: String
}

type UserAuditChart {
    focus: ReportFocusEnum!
    groupBy: [UserAuditGroupByEnum!]
    name: String!
}

type UserAuditConnection {
    count: Int!
    edges: [UserAuditEdge!]!
    nodes: [UserAudit!]!
    pageInfo: PageInfo!
}

type UserAuditEdge {
    cursor: String!
    node: UserAudit!
}

"User audit data with groupby info applied to it"
type UserAuditGroupBy {
    "The data group by info."
    groupByInfo: UserAuditGroupByInfo!
    "Paginated audit data."
    userAuditConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "sort user audit by field"
        sortBy: UserAuditSortByEnum = Time
    ): UserAuditConnection!
    "Further provide groupings for the data."
    userAuditGroupBy(
        "group audits by a field"
        groupBy: UserAuditGroupByEnum!
    ): [UserAuditGroupBy!]!
}

type UserAuditGroupByConnection {
    count: Int!
    edges: [UserAuditGroupByEdge!]!
    nodes: [UserAuditGroupBy!]!
    pageInfo: PageInfo!
}

type UserAuditGroupByEdge {
    cursor: String!
    node: UserAuditGroupBy!
}

type UserAuditObjectType {
    enumValue: UserAuditObjectTypeEnum!
}

type UserAuditStatus {
    enumValue: UserAuditStatusEnum!
}

type UserAuditTable {
    focus: ReportFocusEnum!
    groupBy: [UserAuditGroupByEnum!]
    name: String!
    selectedColumns: [UserAuditTableColumnEnum!]!
    sortBy: UserAuditSortByEnum
    sortOrder: SortOrderEnum
}

type UserAuditType {
    enumValue: UserAuditTypeEnum!
}

type UserConnection {
    count: Int!
    edges: [UserEdge!]!
    nodes: [User!]!
    pageInfo: PageInfo!
}

type UserDownload {
    id: Long!
    name: String!
    progress: Int!
    status: DownloadStatusEnum!
    url: String!
}

type UserEdge {
    cursor: String!
    node: User!
}

type VNet {
    id: String!
    name: String!
    regionName: String!
    resourceGroup: ResourceGroup
}

type VNetConnection {
    count: Int!
    edges: [VNetEdge!]!
    nodes: [VNet!]!
    pageInfo: PageInfo!
}

type VNetEdge {
    cursor: String!
    node: VNet!
}

type VSphereBlueprint implements Blueprint & CdmHierarchyObject & CdmHierarchySnappableNew & HierarchyObject & HierarchySnappable {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    cdmId: String!
    "A link to view the snappable on the CDM cluster. For dev use only."
    cdmLink: String!
    "The list of children snappable"
    childConnection: BlueprintChildConnection!
    children: [VSphereVmChild!]!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    currentFailoverStatus: AppBlueprintFailoverStatusEnum!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    isAssignedSlaSynced: Boolean!
    isMount: Boolean!
    isRelic: Boolean!
    "last failover"
    lastFailover: Failover
    lastFailoverStatus: AppBlueprintLastFailoverStatusEnum!
    lastFailoverTimeMillisOpt: Long
    "last test failover"
    lastTestFailover: Failover
    lastTestFailoverStatus: AppBlueprintLastFailoverStatusEnum!
    lastTestFailoverTimeMillisOpt: Long
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The list of missed snapshots for this VM"
    missedSnapshotConnection(
        after: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        first: Int
    ): MissedSnapshotCommonConnection
    "The list of missed snapshots for this VM"
    missedSnapshotGroupByConnection(
        after: String,
        before: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        first: Int,
        "group snapshots by field"
        groupBy: MissedSnapshotGroupByEnum!,
        last: Int,
        timezoneOffset: Float = 0.0
    ): MissedSnapshotGroupByConnection
    mountTimeMillisOpt: Long
    "The name of the hierarchy object."
    name: String!
    "the newest snapshot archived to AWS."
    newestArchivedSnapshot: CdmSnapshot
    "The newest snapshot ready for failover"
    newestFailoverReadySnapshot(isTestFailover: Boolean!): CdmSnapshot
    "the newest snapshot replicated to a cluster."
    newestReplicatedSnapshot: CdmSnapshot
    "the most recent snapshot of this snappable"
    newestSnapshot: CdmSnapshot
    "number of child snappables of the Blueprint"
    numChildren: Int!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "the oldest snapshot of this snappable"
    oldestSnapshot: CdmSnapshot
    "the number of on-demand snapshots"
    onDemandSnapshotCount: Int!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The recoverable ranges of the blueprint"
    recoveryInfo(
        "The id of the cluster"
        clusterUuid: UUID!
    ): BlueprintRecoverableRanges
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    rmStatus: AppBlueprintRmStatusEnum!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The list of snapshots taken for this VM"
    snapshotConnection(
        after: String,
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        first: Int,
        last: Int,
        "sort snapshots by field"
        sortBy: CdmSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): CdmSnapshotConnection
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this VM's snapshots."
    snapshotGroupByConnection(
        after: String,
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        first: Int,
        "group snapshots by field"
        groupBy: CdmSnapshotGroupByEnum!,
        last: Int,
        timezoneOffset: Float = 0.0
    ): cdmSnapshotGroupByConnection
    status: AppBlueprintStatusEnum!
}

type VSphereBlueprintChildFailoverInstance implements BlueprintFailoverInstance {
    failoverInstance: AwsEc2Instance!
    snappableId: String!
}

type VSphereComputeCluster implements CdmHierarchyObject & HierarchyObject & VSphereDatacenterDescendantType & VSphereDatacenterPhysicalChildType & VSphereVCenterDescendantType & VSphereVCenterPhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "List of descendants"
    descendantConnection(
        after: String,
        filter: [Filter!],
        first: Int,
        "provide optional snappable hierarchy for RBAC and SLA, none value is assumed to be All snappable hierarchy"
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VSphereComputeClusterDescendantTypeConnection!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "List of physical children"
    physicalChildConnection(
        after: String,
        filter: [Filter!],
        first: Int,
        "provide optional snappable hierarchy for RBAC and SLA, none value is assumed to be All snappable hierarchy"
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VSphereComputeClusterPhysicalChildTypeConnection!
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

type VSphereComputeClusterDescendantTypeConnection {
    count: Int!
    edges: [VSphereComputeClusterDescendantTypeEdge!]!
    nodes: [VSphereComputeClusterDescendantType!]!
    pageInfo: PageInfo!
}

type VSphereComputeClusterDescendantTypeEdge {
    cursor: String!
    node: VSphereComputeClusterDescendantType!
}

type VSphereComputeClusterPhysicalChildTypeConnection {
    count: Int!
    edges: [VSphereComputeClusterPhysicalChildTypeEdge!]!
    nodes: [VSphereComputeClusterPhysicalChildType!]!
    pageInfo: PageInfo!
}

type VSphereComputeClusterPhysicalChildTypeEdge {
    cursor: String!
    node: VSphereComputeClusterPhysicalChildType!
}

type VSphereDatacenter implements CdmHierarchyObject & HierarchyObject & VSphereVCenterDescendantType & VSphereVCenterLogicalChildType & VSphereVCenterPhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "List of descendants"
    descendantConnection(
        after: String,
        filter: [Filter!],
        first: Int,
        "provide optional snappable hierarchy for RBAC and SLA, none value is assumed to be All snappable hierarchy"
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VSphereDatacenterDescendantTypeConnection!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "List of logical children"
    logicalChildConnection(
        after: String,
        filter: [Filter!],
        first: Int,
        "provide optional snappable hierarchy for RBAC and SLA, none value is assumed to be All snappable hierarchy"
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VSphereDatacenterLogicalChildTypeConnection!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "List of physical children"
    physicalChildConnection(
        after: String,
        filter: [Filter!],
        first: Int,
        "provide optional snappable hierarchy for RBAC and SLA, none value is assumed to be All snappable hierarchy"
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VSphereDatacenterPhysicalChildTypeConnection!
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

type VSphereDatacenterDescendantTypeConnection {
    count: Int!
    edges: [VSphereDatacenterDescendantTypeEdge!]!
    nodes: [VSphereDatacenterDescendantType!]!
    pageInfo: PageInfo!
}

type VSphereDatacenterDescendantTypeEdge {
    cursor: String!
    node: VSphereDatacenterDescendantType!
}

type VSphereDatacenterLogicalChildTypeConnection {
    count: Int!
    edges: [VSphereDatacenterLogicalChildTypeEdge!]!
    nodes: [VSphereDatacenterLogicalChildType!]!
    pageInfo: PageInfo!
}

type VSphereDatacenterLogicalChildTypeEdge {
    cursor: String!
    node: VSphereDatacenterLogicalChildType!
}

type VSphereDatacenterPhysicalChildTypeConnection {
    count: Int!
    edges: [VSphereDatacenterPhysicalChildTypeEdge!]!
    nodes: [VSphereDatacenterPhysicalChildType!]!
    pageInfo: PageInfo!
}

type VSphereDatacenterPhysicalChildTypeEdge {
    cursor: String!
    node: VSphereDatacenterPhysicalChildType!
}

type VSphereDatastore implements CdmHierarchyObject & HierarchyObject & VSphereComputeClusterDescendantType & VSphereDatacenterDescendantType & VSphereHostDescendantType & VSphereVCenterDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    capacity: Long!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "object id"
    id: UUID!
    isLocal: Boolean!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

type VSphereDatastoreConnection {
    count: Int!
    edges: [VSphereDatastoreEdge!]!
    nodes: [VSphereDatastore!]!
    pageInfo: PageInfo!
}

type VSphereDatastoreEdge {
    cursor: String!
    node: VSphereDatastore!
}

type VSphereFolder implements CdmHierarchyObject & HierarchyObject & VSphereDatacenterDescendantType & VSphereDatacenterLogicalChildType & VSphereFolderDescendantType & VSphereFolderLogicalChildType & VSphereVCenterDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "List of descendants"
    descendantConnection(
        after: String,
        filter: [Filter!],
        first: Int,
        "provide optional snappable hierarchy for RBAC and SLA, none value is assumed to be All snappable hierarchy"
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VSphereFolderDescendantTypeConnection!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "List of logical children"
    logicalChildConnection(
        after: String,
        filter: [Filter!],
        first: Int,
        "provide optional snappable hierarchy for RBAC and SLA, none value is assumed to be All snappable hierarchy"
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VSphereFolderLogicalChildTypeConnection!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

type VSphereFolderDescendantTypeConnection {
    count: Int!
    edges: [VSphereFolderDescendantTypeEdge!]!
    nodes: [VSphereFolderDescendantType!]!
    pageInfo: PageInfo!
}

type VSphereFolderDescendantTypeEdge {
    cursor: String!
    node: VSphereFolderDescendantType!
}

type VSphereFolderLogicalChildTypeConnection {
    count: Int!
    edges: [VSphereFolderLogicalChildTypeEdge!]!
    nodes: [VSphereFolderLogicalChildType!]!
    pageInfo: PageInfo!
}

type VSphereFolderLogicalChildTypeEdge {
    cursor: String!
    node: VSphereFolderLogicalChildType!
}

type VSphereHost implements CdmHierarchyObject & HierarchyObject & VSphereComputeClusterDescendantType & VSphereComputeClusterPhysicalChildType & VSphereDatacenterDescendantType & VSphereDatacenterPhysicalChildType & VSphereVCenterDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "List of descendants"
    descendantConnection(
        after: String,
        filter: [Filter!],
        first: Int,
        "provide optional snappable hierarchy for RBAC and SLA, none value is assumed to be All snappable hierarchy"
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VSphereHostDescendantTypeConnection!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "List of physical children"
    physicalChildConnection(
        after: String,
        filter: [Filter!],
        first: Int,
        "provide optional snappable hierarchy for RBAC and SLA, none value is assumed to be All snappable hierarchy"
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VSphereHostPhysicalChildTypeConnection!
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

type VSphereHostConnection {
    count: Int!
    edges: [VSphereHostEdge!]!
    nodes: [VSphereHost!]!
    pageInfo: PageInfo!
}

type VSphereHostDescendantTypeConnection {
    count: Int!
    edges: [VSphereHostDescendantTypeEdge!]!
    nodes: [VSphereHostDescendantType!]!
    pageInfo: PageInfo!
}

type VSphereHostDescendantTypeEdge {
    cursor: String!
    node: VSphereHostDescendantType!
}

type VSphereHostEdge {
    cursor: String!
    node: VSphereHost!
}

type VSphereHostPhysicalChildTypeConnection {
    count: Int!
    edges: [VSphereHostPhysicalChildTypeEdge!]!
    nodes: [VSphereHostPhysicalChildType!]!
    pageInfo: PageInfo!
}

type VSphereHostPhysicalChildTypeEdge {
    cursor: String!
    node: VSphereHostPhysicalChildType!
}

type VSphereMount {
    attachingDiskCount: Int
    authorizedOperations: AuthorizedOperations!
    cdmId: String!
    cluster: Cluster!
    clusterName: String!
    hasAttachingDisk: Boolean
    host: VSphereHost
    id: UUID!
    isReady: Boolean!
    migrateDatastoreRequestId: String
    mountRequestId: String
    mountTimestamp: DateTime
    newVMName: String
    newVm: VSphereVmNew
    sourceSnapshot: CdmSnapshot
    sourceVm: VSphereVmNew
    status: VSphereLiveMountStatusEnum!
    unmountRequestId: String
}

type VSphereMountConnection {
    count: Int!
    edges: [VSphereMountEdge!]!
    nodes: [VSphereMount!]!
    pageInfo: PageInfo!
}

type VSphereMountEdge {
    cursor: String!
    node: VSphereMount!
}

type VSphereNetwork implements CdmHierarchyObject & HierarchyObject & VSphereHostDescendantType & VSphereVCenterDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "object id"
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

type VSphereRecoverySpec implements RecoverySpec {
    hostId: String!
    hostName: String!
    memoryMbs: Int!
    userData: String
    vCenterId: String!
    vCenterName: String!
    vCpus: Int!
    vSphereNicSpecs: [VSphereVMNicSpec!]!
    vSphereVolumeSpecs: [VSphereVMVolumeSpec!]!
    version: Long!
}

type VSphereTag implements CdmHierarchyObject & HierarchyObject & VSphereTagCategoryDescendantType & VSphereTagCategoryTagChildType & VSphereVCenterDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "object id"
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
    "List of tag children"
    tagChildConnection(
        after: String,
        filter: [Filter!],
        first: Int,
        "provide optional snappable hierarchy for RBAC and SLA, none value is assumed to be All snappable hierarchy"
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VSphereTagTagChildTypeConnection!
    vcenterId: String!
    vsphereTagPath: [PathNode!]!
}

type VSphereTagCategory implements CdmHierarchyObject & HierarchyObject & VSphereVCenterDescendantType & VSphereVCenterTagChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "object id"
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
    "List of tag children"
    tagChildConnection(
        after: String,
        filter: [Filter!],
        first: Int,
        "provide optional snappable hierarchy for RBAC and SLA, none value is assumed to be All snappable hierarchy"
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VSphereTagCategoryTagChildTypeConnection!
    vcenterId: String!
    vsphereTagPath: [PathNode!]!
}

type VSphereTagCategoryTagChildTypeConnection {
    count: Int!
    edges: [VSphereTagCategoryTagChildTypeEdge!]!
    nodes: [VSphereTagCategoryTagChildType!]!
    pageInfo: PageInfo!
}

type VSphereTagCategoryTagChildTypeEdge {
    cursor: String!
    node: VSphereTagCategoryTagChildType!
}

type VSphereTagTagChildTypeConnection {
    count: Int!
    edges: [VSphereTagTagChildTypeEdge!]!
    nodes: [VSphereTagTagChildType!]!
    pageInfo: PageInfo!
}

type VSphereTagTagChildTypeEdge {
    cursor: String!
    node: VSphereTagTagChildType!
}

type VSphereVCenter implements CdmHierarchyObject & HierarchyObject {
    aboutInfo: AboutInformation
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    caCerts: String!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    conflictResolutionAuthz: ConflictResolutionAuthzEnum
    connectionStatus: RefreshableObjectConnectionStatus!
    "List of descendants"
    descendantConnection(
        after: String,
        filter: [Filter!],
        first: Int,
        "provide optional snappable hierarchy for RBAC and SLA, none value is assumed to be All snappable hierarchy"
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VSphereVCenterDescendantTypeConnection!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    lastRefreshTime: DateTime
    "List of logical children"
    logicalChildConnection(
        after: String,
        filter: [Filter!],
        first: Int,
        "provide optional snappable hierarchy for RBAC and SLA, none value is assumed to be All snappable hierarchy"
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VSphereVCenterLogicalChildTypeConnection!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "List of physical children"
    physicalChildConnection(
        after: String,
        filter: [Filter!],
        first: Int,
        "provide optional snappable hierarchy for RBAC and SLA, none value is assumed to be All snappable hierarchy"
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VSphereVCenterPhysicalChildTypeConnection!
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
    "List of tag children"
    tagChildConnection(
        after: String,
        filter: [Filter!],
        first: Int,
        "provide optional snappable hierarchy for RBAC and SLA, none value is assumed to be All snappable hierarchy"
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VSphereVCenterTagChildTypeConnection!
    username: String!
    vcenterId: String!
    vsphereTagPath: [PathNode!]!
}

type VSphereVCenterConnection {
    count: Int!
    edges: [VSphereVCenterEdge!]!
    nodes: [VSphereVCenter!]!
    pageInfo: PageInfo!
}

type VSphereVCenterDescendantTypeConnection {
    count: Int!
    edges: [VSphereVCenterDescendantTypeEdge!]!
    nodes: [VSphereVCenterDescendantType!]!
    pageInfo: PageInfo!
}

type VSphereVCenterDescendantTypeEdge {
    cursor: String!
    node: VSphereVCenterDescendantType!
}

type VSphereVCenterEdge {
    cursor: String!
    node: VSphereVCenter!
}

type VSphereVCenterLogicalChildTypeConnection {
    count: Int!
    edges: [VSphereVCenterLogicalChildTypeEdge!]!
    nodes: [VSphereVCenterLogicalChildType!]!
    pageInfo: PageInfo!
}

type VSphereVCenterLogicalChildTypeEdge {
    cursor: String!
    node: VSphereVCenterLogicalChildType!
}

type VSphereVCenterPhysicalChildTypeConnection {
    count: Int!
    edges: [VSphereVCenterPhysicalChildTypeEdge!]!
    nodes: [VSphereVCenterPhysicalChildType!]!
    pageInfo: PageInfo!
}

type VSphereVCenterPhysicalChildTypeEdge {
    cursor: String!
    node: VSphereVCenterPhysicalChildType!
}

type VSphereVCenterTagChildTypeConnection {
    count: Int!
    edges: [VSphereVCenterTagChildTypeEdge!]!
    nodes: [VSphereVCenterTagChildType!]!
    pageInfo: PageInfo!
}

type VSphereVCenterTagChildTypeEdge {
    cursor: String!
    node: VSphereVCenterTagChildType!
}

type VSphereVMNicSpec {
    adapterType: NetworkAdapterTypeEnum!
    dnsInfos: [String!]!
    gateway: String!
    ipv4Address: String!
    ipv6Address: String!
    isPrimaryNic: Boolean!
    key: String!
    netmask: String!
    networkId: String!
    networkMoid: String!
    networkType: NetworkTypeEnum!
}

type VSphereVMVolumeSpec {
    dataStoreCdmId: String!
    dataStoreId: String!
    key: String!
    sizeGbs: Int!
}

type VSphereVirtualDisk {
    cdmId: String!
    cdmVersion: String!
    clusterUuid: UUID!
    deviceKey: Int
    excludeFromSnapshots: Boolean!
    fid: UUID!
    fileName: String!
    size: Long
    virtualMachineId: String!
}

type VSphereVirtualDiskConnection {
    count: Int!
    edges: [VSphereVirtualDiskEdge!]!
    nodes: [VSphereVirtualDisk!]!
    pageInfo: PageInfo!
}

type VSphereVirtualDiskEdge {
    cursor: String!
    node: VSphereVirtualDisk!
}

type VSphereVmChild implements BlueprintChild {
    bootPriority: Int!
    "failover instance of child snappable"
    failoverInstance: VSphereBlueprintChildFailoverInstance
    fid: UUID!
    "The recoverable ranges of the child virtual machine"
    recoveryInfo(
        "The id of the cluster"
        clusterUuid: UUID!
    ): VmwareVmRecoverableRanges
    "recoverySpec of child snappable"
    recoverySpec: RecoverySpec
    "resourceSpec of child snappable"
    resourceSpec: VmwareResourceSpec
    "the child snappable"
    snappable: VSphereVmNew
    snappableType: ObjectTypeEnum!
}

type VSphereVmNew implements CdmHierarchyObject & CdmHierarchySnappableNew & HierarchyObject & HierarchySnappable & VSphereComputeClusterDescendantType & VSphereDatacenterDescendantType & VSphereFolderDescendantType & VSphereFolderLogicalChildType & VSphereHostDescendantType & VSphereHostPhysicalChildType & VSphereTagCategoryDescendantType & VSphereTagDescendantType & VSphereTagTagChildType & VSphereVCenterDescendantType {
    "Status of the Rubrik Backup Service agent on this VM"
    agentStatus: AgentStatus
    "Whether array integration is enabled for this VM"
    arrayIntegrationEnabled: Boolean!
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    cdmId: String!
    "A link to view the snappable on the CDM cluster. For dev use only."
    cdmLink: String!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "Guest credential authorization status"
    guestCredentialAuthorizationStatus: GuestCredentialAuthorizationStatusEnum!
    guestOsName: String!
    "The Guest OS Type of this VM"
    guestOsType: GuestOsTypeEnum!
    "object id"
    id: UUID!
    isRelic: Boolean!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The list of missed snapshots for this VM"
    missedSnapshotConnection(
        after: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        first: Int
    ): MissedSnapshotCommonConnection
    "The list of missed snapshots for this VM"
    missedSnapshotGroupByConnection(
        after: String,
        before: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        first: Int,
        "group snapshots by field"
        groupBy: MissedSnapshotGroupByEnum!,
        last: Int,
        timezoneOffset: Float = 0.0
    ): MissedSnapshotGroupByConnection
    "The name of the hierarchy object."
    name: String!
    "the newest snapshot archived to AWS."
    newestArchivedSnapshot: CdmSnapshot
    "the newest snapshot replicated to a cluster."
    newestReplicatedSnapshot: CdmSnapshot
    "the most recent snapshot of this snappable"
    newestSnapshot: CdmSnapshot
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "the oldest snapshot of this snappable"
    oldestSnapshot: CdmSnapshot
    "the number of on-demand snapshots"
    onDemandSnapshotCount: Int!
    parentSnappableIdOpt: UUID
    parentSnappableTypeOpt: String
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "postBackupScript"
    postBackupScript: PrePostScript
    "postSnapScript"
    postSnapScript: PrePostScript
    powerStatus: VmPowerStatusEnum
    "preBackupScript"
    preBackupScript: PrePostScript
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "Date that effective SLA was assigned / inherited."
    protectionDate: DateTime
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "contains stats for this snappable (e.g., capacity)"
    reportSnappable: Snappable
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The list of snapshots taken for this VM"
    snapshotConnection(
        after: String,
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        first: Int,
        last: Int,
        "sort snapshots by field"
        sortBy: CdmSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): CdmSnapshotConnection
    "snapshot consistency mandate"
    snapshotConsistencyMandate: ConsistencyLevelEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this VM's snapshots."
    snapshotGroupByConnection(
        after: String,
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        first: Int,
        "group snapshots by field"
        groupBy: CdmSnapshotGroupByEnum!,
        last: Int,
        timezoneOffset: Float = 0.0
    ): cdmSnapshotGroupByConnection
    "list of liveMounts for this VM"
    vSphereMounts(
        after: String,
        "filter for VM live mounts"
        filter: VSphereMountFilter,
        first: Int,
        sortBy: VSphereMountSortByEnum,
        "sort order"
        sortOrder: SortOrderEnum
    ): VSphereMountConnection!
    vmwareToolsInstalled: Boolean!
    vsphereTagPath: [PathNode!]!
    "list of virtual disks for this VM"
    vsphereVirtualDisks(
        after: String,
        "filter for VM virtual disks"
        filter: VSphereVirtualDiskFilter,
        first: Int,
        sortBy: VSphereVirtualDiskSortByEnum,
        "sort order"
        sortOrder: SortOrderEnum
    ): VSphereVirtualDiskConnection!
}

type VSphereVmNewConnection {
    count: Int!
    edges: [VSphereVmNewEdge!]!
    nodes: [VSphereVmNew!]!
    pageInfo: PageInfo!
}

type VSphereVmNewEdge {
    cursor: String!
    node: VSphereVmNew!
}

type ValidateFailureReason {
    failureReason: String!
    planName: PlanNameEnum!
    snappableId: String!
    snapshotId: String!
}

type ValueBoolean implements Value {
    serializedValue: String!
    value: Boolean
}

type ValueDateTime implements Value {
    serializedValue: String!
    value: DateTime
}

type ValueFloat implements Value {
    serializedValue: String!
    value: Float
}

type ValueInteger implements Value {
    serializedValue: String!
    value: Int
}

type ValueLong implements Value {
    serializedValue: String!
    value: Long
}

type ValueNull implements Value {
    serializedValue: String!
}

type ValueString implements Value {
    serializedValue: String!
    value: String
}

type VcdOrg implements CdmHierarchyObject {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "List of direct children of VcdOrg"
    childConnection: VcdOrgVdcConnection!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "List of all descendants of VcdOrg"
    searchDescendantConnection: VcdOrgDescendantConnection!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

type VcdOrgDescendantConnection {
    count: Int!
    edges: [VcdOrgDescendantEdge!]!
    nodes: [VcdOrgDescendant!]!
    pageInfo: PageInfo!
}

type VcdOrgDescendantEdge {
    cursor: String!
    node: VcdOrgDescendant!
}

type VcdOrgVdc implements CdmHierarchyObject & VcdOrgDescendant {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "List of direct children of VcdOrgVdc"
    childConnection: VcdVappConnection!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
}

type VcdOrgVdcConnection {
    count: Int!
    edges: [VcdOrgVdcEdge!]!
    nodes: [VcdOrgVdc!]!
    pageInfo: PageInfo!
}

type VcdOrgVdcEdge {
    cursor: String!
    node: VcdOrgVdc!
}

type VcdVapp implements CdmHierarchyObject & CdmHierarchySnappableNew & VcdOrgDescendant {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    cdmId: String!
    "A link to view the snappable on the CDM cluster. For dev use only."
    cdmLink: String!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    "object id"
    id: UUID!
    isRelic: Boolean!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The list of missed snapshots for this VM"
    missedSnapshotConnection(
        after: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        first: Int
    ): MissedSnapshotCommonConnection
    "The list of missed snapshots for this VM"
    missedSnapshotGroupByConnection(
        after: String,
        before: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        first: Int,
        "group snapshots by field"
        groupBy: MissedSnapshotGroupByEnum!,
        last: Int,
        timezoneOffset: Float = 0.0
    ): MissedSnapshotGroupByConnection
    "The name of the hierarchy object."
    name: String!
    "the newest snapshot archived to AWS."
    newestArchivedSnapshot: CdmSnapshot
    "the newest snapshot replicated to a cluster."
    newestReplicatedSnapshot: CdmSnapshot
    "the most recent snapshot of this snappable"
    newestSnapshot: CdmSnapshot
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "the oldest snapshot of this snappable"
    oldestSnapshot: CdmSnapshot
    "the number of on-demand snapshots"
    onDemandSnapshotCount: Int!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The list of snapshots taken for this VM"
    snapshotConnection(
        after: String,
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        first: Int,
        last: Int,
        "sort snapshots by field"
        sortBy: CdmSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): CdmSnapshotConnection
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this VM's snapshots."
    snapshotGroupByConnection(
        after: String,
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        first: Int,
        "group snapshots by field"
        groupBy: CdmSnapshotGroupByEnum!,
        last: Int,
        timezoneOffset: Float = 0.0
    ): cdmSnapshotGroupByConnection
}

type VcdVappConnection {
    count: Int!
    edges: [VcdVappEdge!]!
    nodes: [VcdVapp!]!
    pageInfo: PageInfo!
}

type VcdVappEdge {
    cursor: String!
    node: VcdVapp!
}

type VersionedFile {
    absolutePath: String!
    displayPath: String!
    fileVersions: [HierarchySnappableFileVersion!]!
    filename: String!
    path: String!
}

type VersionedFileConnection {
    count: Int!
    edges: [VersionedFileEdge!]!
    nodes: [VersionedFile!]!
    pageInfo: PageInfo!
}

type VersionedFileEdge {
    cursor: String!
    node: VersionedFile!
}

type VmDatastore {
    datastoreId: String!
    datastoreName: String!
}

type VmDiskMapEntry {
    sourceDatastore: VmDatastore
    sourceVmDiskId: String!
    targetDiskId: String!
    targetDiskNativeId: String!
    targetIsOsDisk: Boolean!
    targetLogicalSize: Long!
    targetSnapshotId: String!
}

type VmHost {
    hostId: String!
    hostName: String!
    vcenterId: String!
    vcenterName: String!
}

type VmNic {
    nicId: String!
    nicMoid: String!
    nicName: String!
}

type VmNicMapEntry {
    sourceNic: VmNic
    sourceNicAdapterType: String!
    sourceNicId: String!
    targetNicId: String!
}

"""

Supported in v5.1+
"""
type VmwareCdpLiveInfo {
    """

    Supported in v5.1+
    The time on this node. Computed after computing the live CDP info for the virtual machine
    """
    currentTime: DateTime
    """

    Supported in v5.1+
    The latest time to which this virtual machine can be recovered locally.
    """
    localRecoveryPoint: DateTime
    """

    Supported in v5.1+
    The latest time to which this virtual machine can be recovered on a remote cluster.
    """
    remoteRecoveryPoint: DateTime
    """

    Supported in v5.1+
    The ID of the virtual machine that we are getting CDP live fields for.
    """
    vmId: String!
}

"""

Supported in v5.1+
"""
type VmwareRecoverableRange {
    """

    Supported in v5.1+
    """
    beginTime: DateTime
    """

    Supported in v5.1+
    """
    endTime: DateTime
}

type VmwareResourceSpec implements ResourceSpec {
    isArchived: Boolean!
    memoryMbs: Int!
    osType: String!
    snappableId: String!
    snappableName: String!
    snapshotId: String!
    vCpus: Int!
    vmWareVolumeSpecs: [VmwareVirtualMachineVolume!]!
    vmwareNics: [VmwareVirtualMachineNic!]!
}

type VmwareVirtualMachineNic {
    deviceLabel: String!
    key: Int!
    networkLabel: String!
    v4Addresses: [String!]!
}

type VmwareVirtualMachineResourceDesc {
    isArchived: Boolean!
    memoryMbs: Int!
    networkInterfaces: [VmwareVirtualMachineNic!]!
    numCpus: Int!
    osType: String!
    snappableId: String!
    snappableName: String!
    snapshotId: String!
    storageVolumes: [VmwareVirtualMachineVolume!]!
}

type VmwareVirtualMachineVolume {
    capacityKbs: Long!
    key: Int!
    label: String!
}

type VmwareVmConfig {
    logRetentionSeconds: Long!
}

type VmwareVmRecoverableRanges {
    "The recoverable ranges for the virtual machine."
    recoverableRanges: [VmwareRecoverableRange!]!
    "The ID of the virtual machine for which to retrieve recoverable ranges."
    vmId: String!
}

type Vpc {
    cidrBlock: AddressBlockV4
    id: String!
    name: String!
    vpcId: String!
}

type VpcConnection {
    count: Int!
    edges: [VpcEdge!]!
    nodes: [Vpc!]!
    pageInfo: PageInfo!
}

type VpcEdge {
    cursor: String!
    node: Vpc!
}

type VsphereBlueprintChildSnapshotInfo {
    host: VmHost
    memoryMbs: Int!
    nicMap: [VmNicMapEntry!]!
    osType: String!
    snapshotAppMetadata: String!
    snapshotId: String!
    vcpus: Int!
    volumeMap: [VmDiskMapEntry!]!
}

type WeeklySnapshotSchedule {
    basicSchedule: BasicSnapshotSchedule
    dayOfWeek: DayOfWeekEnum!
}

type WhitelistedAnalyzer {
    isExplicit: Boolean!
    whitelistedAnalyzerId: String!
    whitelistedPath: String!
}

type WindowsFileset implements CdmHierarchyObject & CdmHierarchySnappableNew & FilesetTemplateDescendantType & FilesetTemplatePhysicalChildType & HierarchyObject & HierarchySnappable & PhysicalHostDescendantType & PhysicalHostPhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    cdmId: String!
    "A link to view the snappable on the CDM cluster. For dev use only."
    cdmLink: String!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The Effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The Effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA source"
    effectiveSlaSourceObject: PathNode
    hardlinkSupportEnabled: Boolean!
    host: PhysicalHost!
    "The fid of the hierarchy object."
    id: UUID!
    isPassThrough: Boolean!
    isRelic: Boolean!
    "A sequential list containing this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The list of missed snapshots for this VM"
    missedSnapshotConnection(
        after: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        first: Int
    ): MissedSnapshotCommonConnection
    "The list of missed snapshots for this VM"
    missedSnapshotGroupByConnection(
        after: String,
        before: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        first: Int,
        "group snapshots by field"
        groupBy: MissedSnapshotGroupByEnum!,
        last: Int,
        timezoneOffset: Float = 0.0
    ): MissedSnapshotGroupByConnection
    "The name of the hierarchy object."
    name: String!
    "the newest snapshot archived to AWS."
    newestArchivedSnapshot: CdmSnapshot
    "the newest snapshot replicated to a cluster."
    newestReplicatedSnapshot: CdmSnapshot
    "the most recent snapshot of this snappable"
    newestSnapshot: CdmSnapshot
    "The number of snappable descendants of this object"
    numSnappableDescendants: Int!
    "The object type of this object."
    objectType: HierarchyObjectTypeEnum!
    "the oldest snapshot of this snappable"
    oldestSnapshot: CdmSnapshot
    "the number of on-demand snapshots"
    onDemandSnapshotCount: Int!
    pathExceptions: [String!]!
    pathExcluded: [String!]!
    pathIncluded: [String!]!
    "Mapping from objectId to object deletion pending status"
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "Non-null when a user has assigned a SLA to this object, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "A sequential list containing this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related by replication"
    replicatedObjects: [CdmHierarchyObject!]!
    "The assignmennt type for this object's SLA"
    slaAssignment: SlaAssignmentTypeEnum!
    "The list of snapshots taken for this VM"
    snapshotConnection(
        after: String,
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        first: Int,
        last: Int,
        "sort snapshots by field"
        sortBy: CdmSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): CdmSnapshotConnection
    "The distribution of the snapshots of the hierarchy object"
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this VM's snapshots."
    snapshotGroupByConnection(
        after: String,
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        first: Int,
        "group snapshots by field"
        groupBy: CdmSnapshotGroupByEnum!,
        last: Int,
        timezoneOffset: Float = 0.0
    ): cdmSnapshotGroupByConnection
    symlinkResolutionEnabled: Boolean!
}

type YearlySnapshotSchedule {
    basicSchedule: BasicSnapshotSchedule
    dayOfYear: DayOfYearEnum!
    yearStartMonth: MonthEnum!
}

"Snapshot data with groupby info applied to it."
type cdmSnapshotGroupBy {
    "Further provide groupings for the data."
    cdmSnapshotGroupBy(
        "group snapshots by field"
        groupBy: CdmSnapshotGroupByEnum!
    ): [cdmSnapshotGroupBy!]!
    "The data groupby info."
    groupByInfo: CdmSnapshotGroupByInfo!
    "Paginated snapshot data."
    snapshotConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "sort snapshots by field"
        sortBy: CdmSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): CdmSnapshotConnection!
}

type cdmSnapshotGroupByConnection {
    count: Int!
    edges: [cdmSnapshotGroupByEdge!]!
    nodes: [cdmSnapshotGroupBy!]!
    pageInfo: PageInfo!
}

type cdmSnapshotGroupByEdge {
    cursor: String!
    node: cdmSnapshotGroupBy!
}

"Cluster metric data grouped by a time unit."
type metricTimeSeries {
    "cluster metric data for the given time interval."
    metric: ClusterMetric!
    "The time groupby info."
    timeInfo: ClusterMetricGroupByInfo!
}

type pendingAction {
    actionType: PendingActionType
    actionTypeStr: String!
    clusterUuid: String!
    createdAt: DateTime
    description: String!
    info: String!
    pendingActionId: String!
    status: PendingActionStatusEnum!
    updatedAt: DateTime
}

"The status of the async cdm request"
type vSphereAsyncRequestStatus {
    endTime: DateTime!
    error: vSphereRequestErrorInfo
    id: String!
    links: [vSphereLink!]!
    nodeId: String!
    progress: Float!
    startTime: DateTime!
    status: String!
}

"a link with href and rel properties."
type vSphereLink {
    href: String!
    rel: String!
}

"contains error info for a cdm response"
type vSphereRequestErrorInfo {
    message: String!
}

enum AceFlagsEnum {
    CONTAINER_INHERIT
    EMPTY_FLAG
    FAILED_ACCESS
    INHERITED
    INHERIT_ONLY
    NO_PROPAGATE_INHERIT
    OBJECT_INHERIT
    SUCCESSFUL_ACCESS
}

enum AceQualifierEnum {
    ACCESS_ALLOWED
    ACCESS_DENIED
    CUSTOM
    SYSTEM_ALARM
    SYSTEM_AUDIT
}

enum AckClusterStatus {
    DownloadFailed
    PrechecksError
}

enum ActionEnum {
    RESUME
    ROLLBACK
    START
}

enum ActivityObjectTypeEnum {
    AppBlueprint
    AuthDomain
    AwsAccount
    AwsEventType
    AwsNativeAccount
    AwsNativeEbsVolume
    AwsNativeEc2Instance
    AwsNativeRdsInstance
    AzureNativeDisk
    AzureNativeSubscription
    AzureNativeVm
    Certificate
    CloudNativeVirtualMachine
    CloudNativeVm
    Cluster
    DataLocation
    Ec2Instance
    Exocompute
    FailoverClusterApp
    GcpNativeDisk
    GcpNativeGceInstance
    GcpNativeProject
    Hdfs
    Host
    HypervScvmm
    HypervServer
    HypervVm
    JobInstance
    Ldap
    LinuxFileset
    LinuxHost
    ManagedVolume
    Mssql
    NasHost
    NutanixCluster
    NutanixVm
    O365Calendar
    O365Mailbox
    O365Onedrive
    O365Organization
    O365SharepointDrive
    O365Site
    ObjectProtection
    Oracle
    OracleDb
    OracleHost
    OracleRac
    PolarisAccount
    PolarisEbsVolume
    PolarisEc2Instance
    PublicCloudMachineInstance
    SamlSso
    SapHanaDb
    SapHanaSystem
    ShareFileset
    SlaDomain
    SmbDomain
    StorageArray
    StorageArrayVolumeGroup
    StorageLocation
    Storm
    SupportBundle
    UnknownObjectType
    Upgrade
    Vcd
    VcdVapp
    Vcenter
    VmwareComputeCluster
    VmwareVm
    VolumeGroup
    WindowsFileset
    WindowsHost
}

enum ActivitySeriesGroupByEnum {
    Cluster
    ClusterType
    Day
    Hour
    LastActivityStatus
    LastActivityType
    Month
    ObjectType
    Quarter
    Week
    Year
}

enum ActivitySeriesSortByEnum {
    ActivityStatus
    ActivityType
    ClusterName
    LastUpdated
    Location
    ObjectName
    ObjectType
    Severity
    StartTime
}

enum ActivitySeverityEnum {
    Critical
    Info
    Warning
}

enum ActivityStatusEnum {
    Canceled
    Canceling
    Failure
    Info
    Queued
    Running
    Success
    TaskFailure
    TaskSuccess
    Warning
}

enum ActivityTableColumnEnum {
    ActivityStatus
    ActivityType
    ClusterName
    ClusterType
    ComplianceStatus
    LastUpdated
    Location
    ObjectName
    ObjectType
    SlaDomain
    StartTime
}

enum ActivityTypeEnum {
    Anomaly
    Archive
    AuthDomain
    AwsEvent
    Backup
    Classification
    CloudNativeSource
    CloudNativeVirtualMachine
    CloudNativeVm
    Configuration
    Connection
    Diagnostic
    Discovery
    EmbeddedEvent
    Failover
    Fileset
    Hardware
    Hdfs
    HostEvent
    HypervScvmm
    HypervServer
    Index
    Instantiate
    LegalHold
    Maintenance
    NutanixCluster
    Recovery
    Replication
    Storage
    StorageArray
    StormResource
    Support
    Sync
    System
    TestFailover
    UnknownEventType
    Upgrade
    VCenter
    Vcd
    VolumeGroup
}

enum AgentConnectStatusEnum {
    Connected
    Disconnected
    Unregistered
}

enum AnalyzerErrorCodeEnum {
    ANALYZER
    NOERROR
    OTHER
    PARSING
    READING
}

enum AnalyzerGroupTypeEnum {
    CCPA
    CUSTOM
    GLBA
    HIPAA
    PCI_DSS
    UK_PII
    UNDEFINED
    US_FINANCE
    US_PII
}

enum AnalyzerTypeEnum {
    ABA_ROUTING_NUMBER
    CREDIT_CARD
    CUSIP_NUMBER
    DEA_NUMBER
    EIN
    EMAIL_ADDRESS
    IBAN
    IPV4_ADDRESS
    KEYWORD
    MAC_ADDRESS
    PASSPORT
    PHONE_NUMBER
    REGEX
    SIMHASH
    UK_DL
    UK_NHS
    UK_NINO
    UK_UTR
    UNDEFINED
    US_BANK_ACCT
    US_CA_DL
    US_DL
    US_HEALTHCARE_NPI
    US_ITIN
    US_SSN
    US_VIN
    WORD_FREQUENCY
}

enum AnomalyResultGroupByEnum {
    ClusterUuid
    Day
    Hour
    IsAnomaly
    ManagedId
    Month
    Week
    Year
}

enum AnomalyResultSortByEnum {
    AnomalyProbability
    BytesCreatedCount
    BytesDeletedCount
    BytesModifiedCount
    BytesNetChangedCount
    ClusterUuid
    FilesCreatedCount
    FilesDeletedCount
    FilesModifiedCount
    IsAnomaly
    ManagedId
    ObjectType
    PreviousSnapshotDate
    PreviousSnapshotId
    SnappableName
    SnappableType
    SnapshotDate
    SnapshotId
}

enum AnomalyTableColumnEnum {
    BytesCreated
    BytesDeleted
    BytesModified
    BytesNetChanged
    FilesCreated
    FilesDeleted
    FilesModified
    IsAnomaly
    PreviousSnapshotDate
    PreviousSnapshotId
    SnappableName
    SnappableType
    SnapshotDate
    SnapshotId
    SuspiciousFilesAdded
}

enum AppBlueprintFailoverStatusEnum {
    CleanupInProgress
    InProgress
    Paused
    Ready
    TestCleanupInProgress
    TestInProgress
    TestPaused
    TestPending
    Tested
}

enum AppBlueprintLastFailoverStatusEnum {
    Failed
    NotExist
    Succeeded
}

enum AppBlueprintRmStatusEnum {
    Configured
    Invalid
    MissingVms
    NotConfigured
}

enum AppBlueprintStatusEnum {
    Creating
    Deleted
    Deleting
    Ready
    Updating
}

enum AppFilterFieldEnum {
    APP_ID
    APP_TYPE
    SUBSCRIPTION
}

enum AppSortByFieldEnum {
    ADDED_AT
    APP_ID
    APP_OWNER
    APP_TYPE
    IS_AUTHENTICATED
    SUBSCRIPTION
}

enum AppSortOrderEnum {
    ASC
    DESC
}

enum AppflowsBlueprintFailoverReportStatusEnum {
    ACTIVE
    CREATING
    EXPIRED
}

enum ArchivalLocationType {
    Azure
    Cleversafe
    Glacier
    Google
    HDS
    Nfs
    Qstar
    Rehydrated
    S3
    S3Compatible
    Scality
}

enum AssignSLAWarningsEnum {
    ARCHIVAL_CONFIGURATION_NOT_RESPECTED
    ARCHIVAL_LOCATION_NOT_SPECIFIED
    AWS_CROSS_ACCOUNT_REPLICATION_CONFIG_WARNING
    AZURE_FULL_SNAPSHOTS
    AZURE_NATIONAL_PUBLIC_REPLICATION_NOT_SUPPORTED
    BACKUP_WINDOWS_NOT_RESPECTED
    INCREMENTAL_BACKUP_FREQUENCY_NOT_RESPECTED
    NO_WARNING
    REMOTE_CONFIGURATION_NOT_RESPECTED
    REPLICATION_CONFIGURATION_NOT_RESPECTED
    REPLICATION_TARGET_SAME_AS_SOURCE
    SLA_NOT_SYNCED
    SNAPSHOTS_MAY_EXPIRE
}

enum AuthTypeEnum {
    KERBEROS
    NONE
}

enum AwsAccountStatusEnum {
    Added
    Deleted
    Deleting
    DeletionFailed
    Disconnected
    RefreshFailed
    Refreshed
    Refreshing
}

enum AwsCloudAccountRegionEnum {
    AP_NORTHEAST_1
    AP_NORTHEAST_2
    AP_SOUTHEAST_1
    AP_SOUTHEAST_2
    AP_SOUTH_1
    CA_CENTRAL_1
    CN_NORTHWEST_1
    CN_NORTH_1
    EU_CENTRAL_1
    EU_NORTH_1
    EU_WEST_1
    EU_WEST_2
    EU_WEST_3
    SA_EAST_1
    UNKNOWN_AWS_REGION
    US_EAST_1
    US_EAST_2
    US_WEST_1
    US_WEST_2
}

enum AwsCloudComputeSettingFilterFieldEnum {
    CLOUD_ACCOUNT_ID
    CLUSTER_ALL
    CLUSTER_ID
    IS_ARCHIVED
    IS_SG_POLARIS_MANAGED
    NAME
}

enum AwsCloudComputeSettingSortByFieldEnum {
    NAME
}

enum AwsCloudTypeEnum {
    CHINA
    STANDARD
}

enum AwsInstanceTenancyEnum {
    DEDICATED
    DEFAULT
    HOST
}

enum AwsNativeAccountSortFieldsEnum {
    EBS_VOLUME_COUNT
    EC2_INSTANCE_COUNT
    EFFECTIVE_SLA_DOMAIN
    NAME
}

enum AwsNativeEbsVolumeSortFieldsEnum {
    AWS_NATIVE_ACCOUNT_NAME
    EBS_VOLUME_ID
    EBS_VOLUME_NAME
    EBS_VOLUME_SIZE
    EBS_VOLUME_TYPE
    EFFECTIVE_SLA_DOMAIN
}

enum AwsNativeEbsVolumeTypeEnum {
    GP2
    IO1
    NOT_SPECIFIED
    SC1
    ST1
    STANDARD
    UNKNOWN
}

enum AwsNativeEc2InstanceSortFieldsEnum {
    ASSIGNED_SLA_DOMAIN
    AWS_NATIVE_ACCOUNT_NAME
    AWS_VPC_ID
    EC2_INSTANCE_ID
    EC2_INSTANCE_NAME
    EC2_INSTANCE_TYPE
    EFFECTIVE_SLA_DOMAIN
}

enum AwsNativeEc2InstanceTypeEnum {
    A1_2XLARGE
    A1_4XLARGE
    A1_LARGE
    A1_MEDIUM
    A1_METAL
    A1_XLARGE
    C1_MEDIUM
    C1_XLARGE
    C3_2XLARGE
    C3_4XLARGE
    C3_8XLARGE
    C3_LARGE
    C3_XLARGE
    C4_2XLARGE
    C4_4XLARGE
    C4_8XLARGE
    C4_LARGE
    C4_XLARGE
    C5D_12XLARGE
    C5D_18XLARGE
    C5D_24XLARGE
    C5D_2XLARGE
    C5D_4XLARGE
    C5D_9XLARGE
    C5D_LARGE
    C5D_METAL
    C5D_XLARGE
    C5N_18XLARGE
    C5N_2XLARGE
    C5N_4XLARGE
    C5N_9XLARGE
    C5N_LARGE
    C5N_XLARGE
    C5_12XLARGE
    C5_18XLARGE
    C5_24XLARGE
    C5_2XLARGE
    C5_4XLARGE
    C5_9XLARGE
    C5_LARGE
    C5_METAL
    C5_XLARGE
    CC1_4XLARGE
    CC2_8XLARGE
    CG1_4XLARGE
    CR1_8XLARGE
    D2_2XLARGE
    D2_4XLARGE
    D2_8XLARGE
    D2_XLARGE
    F1_16XLARGE
    F1_2XLARGE
    F1_4XLARGE
    G2_2XLARGE
    G2_8XLARGE
    G3S_XLARGE
    G3_16XLARGE
    G3_4XLARGE
    G3_8XLARGE
    G4DN_12XLARGE
    G4DN_16XLARGE
    G4DN_2XLARGE
    G4DN_4XLARGE
    G4DN_8XLARGE
    G4DN_XLARGE
    H1_16XLARGE
    H1_2XLARGE
    H1_4XLARGE
    H1_8XLARGE
    HI1_4XLARGE
    HS1_8XLARGE
    I2_2XLARGE
    I2_4XLARGE
    I2_8XLARGE
    I2_XLARGE
    I3EN_12XLARGE
    I3EN_24XLARGE
    I3EN_2XLARGE
    I3EN_3XLARGE
    I3EN_6XLARGE
    I3EN_LARGE
    I3EN_METAL
    I3EN_XLARGE
    I3_16XLARGE
    I3_2XLARGE
    I3_4XLARGE
    I3_8XLARGE
    I3_LARGE
    I3_METAL
    I3_XLARGE
    INF1_24XLARGE
    INF1_2XLARGE
    INF1_6XLARGE
    INF1_XLARGE
    M1_LARGE
    M1_MEDIUM
    M1_SMALL
    M1_XLARGE
    M2_2XLARGE
    M2_4XLARGE
    M2_XLARGE
    M3_2XLARGE
    M3_LARGE
    M3_MEDIUM
    M3_XLARGE
    M4_10XLARGE
    M4_16XLARGE
    M4_2XLARGE
    M4_4XLARGE
    M4_LARGE
    M4_XLARGE
    M5AD_12XLARGE
    M5AD_16XLARGE
    M5AD_24XLARGE
    M5AD_2XLARGE
    M5AD_4XLARGE
    M5AD_8XLARGE
    M5AD_LARGE
    M5AD_XLARGE
    M5A_12XLARGE
    M5A_16XLARGE
    M5A_24XLARGE
    M5A_2XLARGE
    M5A_4XLARGE
    M5A_8XLARGE
    M5A_LARGE
    M5A_XLARGE
    M5DN_12XLARGE
    M5DN_16XLARGE
    M5DN_24XLARGE
    M5DN_2XLARGE
    M5DN_4XLARGE
    M5DN_8XLARGE
    M5DN_LARGE
    M5DN_XLARGE
    M5D_12XLARGE
    M5D_16XLARGE
    M5D_24XLARGE
    M5D_2XLARGE
    M5D_4XLARGE
    M5D_8XLARGE
    M5D_LARGE
    M5D_METAL
    M5D_XLARGE
    M5N_12XLARGE
    M5N_16XLARGE
    M5N_24XLARGE
    M5N_2XLARGE
    M5N_4XLARGE
    M5N_8XLARGE
    M5N_LARGE
    M5N_XLARGE
    M5_12XLARGE
    M5_16XLARGE
    M5_24XLARGE
    M5_2XLARGE
    M5_4XLARGE
    M5_8XLARGE
    M5_LARGE
    M5_METAL
    M5_XLARGE
    NOT_SPECIFIED
    P2_16XLARGE
    P2_8XLARGE
    P2_XLARGE
    P3DN_24XLARGE
    P3_16XLARGE
    P3_2XLARGE
    P3_8XLARGE
    R3_2XLARGE
    R3_4XLARGE
    R3_8XLARGE
    R3_LARGE
    R3_XLARGE
    R4_16XLARGE
    R4_2XLARGE
    R4_4XLARGE
    R4_8XLARGE
    R4_LARGE
    R4_XLARGE
    R5AD_12XLARGE
    R5AD_16XLARGE
    R5AD_24XLARGE
    R5AD_2XLARGE
    R5AD_4XLARGE
    R5AD_8XLARGE
    R5AD_LARGE
    R5AD_XLARGE
    R5A_12XLARGE
    R5A_16XLARGE
    R5A_24XLARGE
    R5A_2XLARGE
    R5A_4XLARGE
    R5A_8XLARGE
    R5A_LARGE
    R5A_XLARGE
    R5DN_12XLARGE
    R5DN_16XLARGE
    R5DN_24XLARGE
    R5DN_2XLARGE
    R5DN_4XLARGE
    R5DN_8XLARGE
    R5DN_LARGE
    R5DN_XLARGE
    R5D_12XLARGE
    R5D_16XLARGE
    R5D_24XLARGE
    R5D_2XLARGE
    R5D_4XLARGE
    R5D_8XLARGE
    R5D_LARGE
    R5D_METAL
    R5D_XLARGE
    R5N_12XLARGE
    R5N_16XLARGE
    R5N_24XLARGE
    R5N_2XLARGE
    R5N_4XLARGE
    R5N_8XLARGE
    R5N_LARGE
    R5N_XLARGE
    R5_12XLARGE
    R5_16XLARGE
    R5_24XLARGE
    R5_2XLARGE
    R5_4XLARGE
    R5_8XLARGE
    R5_LARGE
    R5_METAL
    R5_XLARGE
    T1_MICRO
    T2_2XLARGE
    T2_LARGE
    T2_MEDIUM
    T2_MICRO
    T2_NANO
    T2_SMALL
    T2_XLARGE
    T3A_2XLARGE
    T3A_LARGE
    T3A_MEDIUM
    T3A_MICRO
    T3A_NANO
    T3A_SMALL
    T3A_XLARGE
    T3_2XLARGE
    T3_LARGE
    T3_MEDIUM
    T3_MICRO
    T3_NANO
    T3_SMALL
    T3_XLARGE
    UNKNOWN
    U_12TB1_METAL
    U_18TB1_METAL
    U_24TB1_METAL
    U_6TB1_METAL
    U_9TB1_METAL
    X1E_16XLARGE
    X1E_2XLARGE
    X1E_32XLARGE
    X1E_4XLARGE
    X1E_8XLARGE
    X1E_XLARGE
    X1_16XLARGE
    X1_32XLARGE
    Z1D_12XLARGE
    Z1D_2XLARGE
    Z1D_3XLARGE
    Z1D_6XLARGE
    Z1D_LARGE
    Z1D_METAL
    Z1D_XLARGE
}

enum AwsNativeFileRecoveryStatusEnum {
    DISABLED
    ENABLED
    NOT_SPECIFIED
}

enum AwsNativeProtectionFeatureEnum {
    EC2
    RDS
}

enum AwsNativeRdsDbEngineEnum {
    MARIADB
    MYSQL
    ORACLE_EE
    ORACLE_SE
    ORACLE_SE1
    ORACLE_SE2
    POSTGRES
    SQLSERVER_EE
    SQLSERVER_EX
    SQLSERVER_SE
    SQLSERVER_WEB
    UNKNOWN
}

enum AwsNativeRdsDbInstanceClassEnum {
    DB_M1_LARGE
    DB_M1_MEDIUM
    DB_M1_SMALL
    DB_M1_XLARGE
    DB_M2_2XLARGE
    DB_M2_4XLARGE
    DB_M2_XLARGE
    DB_M3_2XLARGE
    DB_M3_LARGE
    DB_M3_MEDIUM
    DB_M3_XLARGE
    DB_M4_10XLARGE
    DB_M4_16XLARGE
    DB_M4_2XLARGE
    DB_M4_4XLARGE
    DB_M4_LARGE
    DB_M4_XLARGE
    DB_M5_12XLARGE
    DB_M5_16XLARGE
    DB_M5_24XLARGE
    DB_M5_2XLARGE
    DB_M5_4XLARGE
    DB_M5_8XLARGE
    DB_M5_LARGE
    DB_M5_XLARGE
    DB_R3_2XLARGE
    DB_R3_4XLARGE
    DB_R3_8XLARGE
    DB_R3_LARGE
    DB_R3_XLARGE
    DB_R4_12XLARGE
    DB_R4_16XLARGE
    DB_R4_2XLARGE
    DB_R4_4XLARGE
    DB_R4_8XLARGE
    DB_R4_LARGE
    DB_R4_XLARGE
    DB_R5_12XLARGE
    DB_R5_16XLARGE
    DB_R5_24XLARGE
    DB_R5_2XLARGE
    DB_R5_4XLARGE
    DB_R5_8XLARGE
    DB_R5_LARGE
    DB_R5_XLARGE
    DB_T2_2XLARGE
    DB_T2_LARGE
    DB_T2_MEDIUM
    DB_T2_MICRO
    DB_T2_SMALL
    DB_T2_XLARGE
    DB_T3_2XLARGE
    DB_T3_LARGE
    DB_T3_MEDIUM
    DB_T3_MICRO
    DB_T3_SMALL
    DB_T3_XLARGE
    DB_X1E_16XLARGE
    DB_X1E_2XLARGE
    DB_X1E_32XLARGE
    DB_X1E_4XLARGE
    DB_X1E_8XLARGE
    DB_X1E_XLARGE
    DB_X1_16XLARGE
    DB_X1_32XLARGE
    DB_Z1D_12XLARGE
    DB_Z1D_2XLARGE
    DB_Z1D_4XLARGE
    DB_Z1D_6XLARGE
    DB_Z1D_LARGE
    DB_Z1D_XLARGE
    UNKNOWN
}

enum AwsNativeRdsInstanceSortFieldsEnum {
    ASSIGNED_SLA_DOMAIN
    AWS_NATIVE_ACCOUNT_NAME
    AWS_NATIVE_RDS_DB_ENGINE
    AWS_NATIVE_RDS_DB_INSTANCE_CLASS
    AWS_VPC_ID
    EFFECTIVE_SLA_DOMAIN
    NAME
}

enum AwsNativeRdsStorageTypeEnum {
    GP2
    IO1
    NOT_SPECIFIED
    STANDARD
    UNKNOWN
}

enum AwsNativeRegionEnum {
    AP_NORTHEAST_1
    AP_NORTHEAST_2
    AP_SOUTHEAST_1
    AP_SOUTHEAST_2
    AP_SOUTH_1
    CA_CENTRAL_1
    CN_NORTHWEST_1
    CN_NORTH_1
    EU_CENTRAL_1
    EU_NORTH_1
    EU_WEST_1
    EU_WEST_2
    EU_WEST_3
    NOT_SPECIFIED
    SA_EAST_1
    US_EAST_1
    US_EAST_2
    US_WEST_1
    US_WEST_2
}

enum AwsNativeRegionForReplicationEnum {
    AP_NORTHEAST_1
    AP_NORTHEAST_2
    AP_SOUTHEAST_1
    AP_SOUTHEAST_2
    AP_SOUTH_1
    CA_CENTRAL_1
    CN_NORTHWEST_1
    CN_NORTH_1
    EU_CENTRAL_1
    EU_NORTH_1
    EU_WEST_1
    EU_WEST_2
    EU_WEST_3
    NOT_DEFINED
    SA_EAST_1
    SOURCE_REGION
    US_EAST_1
    US_EAST_2
    US_WEST_1
    US_WEST_2
}

enum AwsRegionEnum {
    AP_NORTHEAST_1
    AP_NORTHEAST_2
    AP_NORTHEAST_3
    AP_SOUTHEAST_1
    AP_SOUTHEAST_2
    AP_SOUTH_1
    CA_CENTRAL_1
    CN_NORTHWEST_1
    CN_NORTH_1
    EU_CENTRAL_1
    EU_WEST_1
    EU_WEST_2
    EU_WEST_3
    SA_EAST_1
    UNKNOWN_AWS_REGION
    US_EAST_1
    US_EAST_2
    US_GOV_WEST_1
    US_WEST_1
    US_WEST_2
}

enum AwsStorageClassTypeEnum {
    ONEZONE_IA
    STANDARD
    STANDARD_IA
    UNKNOWN_STORAGE_CLASS
}

enum AzureCloudAccountRegionEnum {
    AUSTRALIACENTRAL
    AUSTRALIACENTRAL2
    AUSTRALIAEAST
    AUSTRALIASOUTHEAST
    BRAZILSOUTH
    CANADACENTRAL
    CANADAEAST
    CENTRALINDIA
    CENTRALUS
    CHINAEAST
    CHINAEAST2
    CHINANORTH
    CHINANORTH2
    EASTASIA
    EASTUS
    EASTUS2
    FRANCECENTRAL
    FRANCESOUTH
    GERMANYNORTH
    GERMANYWESTCENTRAL
    JAPANEAST
    JAPANWEST
    KOREACENTRAL
    KOREASOUTH
    NORTHCENTRALUS
    NORTHEUROPE
    NORWAYEAST
    NORWAYWEST
    SOUTHAFRICANORTH
    SOUTHAFRICAWEST
    SOUTHCENTRALUS
    SOUTHEASTASIA
    SOUTHINDIA
    SWITZERLANDNORTH
    SWITZERLANDWEST
    UAECENTRAL
    UAENORTH
    UKSOUTH
    UKWEST
    UNKNOWN_AZURE_REGION
    WESTCENTRALUS
    WESTEUROPE
    WESTINDIA
    WESTUS
    WESTUS2
}

enum AzureCloudTypeEnum {
    AZURECHINACLOUD
    AZUREPUBLICCLOUD
}

enum AzureFeatureForPermissionCheck {
    AZURE_EXPORT_VM_IN_POWERED_OFF_STATE
    UNSPECIFIED
}

enum AzureNativeDiskSortFieldsEnum {
    ASSIGNED_SLA_DOMAIN
    AZURE_DISK_RG_NAME
    AZURE_DISK_SIZE
    AZURE_DISK_SUBSCRIPTION_NAME
    AZURE_DISK_TYPE
    AZURE_REGION
    EFFECTIVE_SLA_DOMAIN
    NAME
}

enum AzureNativeManagedDiskTypeEnum {
    NOT_SPECIFIED
    Premium_LRS
    StandardSSD_LRS
    Standard_LRS
    UNKNOWN
    UltraSSD_LRS
}

enum AzureNativeRegionEnum {
    AustraliaCentral
    AustraliaCentral2
    AustraliaEast
    AustraliaSoutheast
    BrazilSouth
    CanadaCentral
    CanadaEast
    CentralIndia
    CentralUS
    ChinaEast
    ChinaEast2
    ChinaNorth
    ChinaNorth2
    EastAsia
    EastUS
    EastUS2
    FranceCentral
    FranceSouth
    GermanyNorth
    GermanyWestCentral
    JapanEast
    JapanWest
    KoreaCentral
    KoreaSouth
    NorthCentralUS
    NorthEurope
    NorwayEast
    NorwayWest
    NotSpecified
    SouthAfricaNorth
    SouthAfricaWest
    SouthCentralUS
    SouthIndia
    SoutheastAsia
    SwitzerlandNorth
    SwitzerlandWest
    UKSouth
    UKWest
    UaeCentral
    UaeNorth
    WestCentralUS
    WestEurope
    WestIndia
    WestUS
    WestUS2
}

enum AzureNativeRegionForReplicationEnum {
    AustraliaCentral
    AustraliaCentral2
    AustraliaEast
    AustraliaSoutheast
    BrazilSouth
    CanadaCentral
    CanadaEast
    CentralIndia
    CentralUS
    ChinaEast
    ChinaEast2
    ChinaNorth
    ChinaNorth2
    EastAsia
    EastUS
    EastUS2
    FranceCentral
    FranceSouth
    GermanyNorth
    GermanyWestCentral
    JapanEast
    JapanWest
    KoreaCentral
    KoreaSouth
    NorthCentralUS
    NorthEurope
    NorwayEast
    NorwayWest
    NotDefined
    SourceRegion
    SouthAfricaNorth
    SouthAfricaWest
    SouthCentralUS
    SouthIndia
    SoutheastAsia
    SwitzerlandNorth
    SwitzerlandWest
    UKSouth
    UKWest
    UaeCentral
    UaeNorth
    WestCentralUS
    WestEurope
    WestIndia
    WestUS
    WestUS2
}

enum AzureNativeSubscriptionSortFieldsEnum {
    ASSIGNED_SLA_DOMAIN
    AZURE_SUBSCRIPTION_DISKCOUNT
    AZURE_SUBSCRIPTION_VMCOUNT
    AZURE_TENANT_ID
    EFFECTIVE_SLA_DOMAIN
    NAME
}

enum AzureNativeVMResourceGroupSortFieldsEnum {
    AZURE_REGION
    AZURE_VM_RG_SUBSCRIPTION_NAME
    EFFECTIVE_SLA_DOMAIN
    NAME
}

enum AzureNativeVirtualMachineSortFieldsEnum {
    ASSIGNED_SLA_DOMAIN
    AZURE_REGION
    AZURE_SUBNET_NAME
    AZURE_VM_RG_NAME
    AZURE_VM_SIZE
    AZURE_VM_SUBSCRIPTION_NAME
    AZURE_VNET_NAME
    EFFECTIVE_SLA_DOMAIN
    NAME
}

enum AzureNativeVmOsTypeEnum {
    Linux
    Unknown
    Windows
}

enum AzureNetworkSecurityRulesStatusEnum {
    BLOCKING
    GOOD
    MAYBE_BLOCKING
}

enum AzureRegionEnum {
    ASIA_EAST
    ASIA_SOUTHEAST
    AUSTRALIA_EAST
    AUSTRALIA_SOUTHEAST
    BRAZIL_SOUTH
    CANADA_CENTRAL
    CANADA_EAST
    CHINA_EAST
    CHINA_NORTH
    EUROPE_NORTH
    EUROPE_WEST
    GERMANY_CENTRAL
    GERMANY_NORTHEAST
    GOV_US_ARIZONA
    GOV_US_DOD_CENTRAL
    GOV_US_DOD_EAST
    GOV_US_IOWA
    GOV_US_TEXAS
    GOV_US_VIRGINIA
    INDIA_CENTRAL
    INDIA_SOUTH
    INDIA_WEST
    JAPAN_EAST
    JAPAN_WEST
    KOREA_CENTRAL
    KOREA_SOUTH
    UK_SOUTH
    UK_WEST
    UNKNOWN_AZURE_REGION
    US_CENTRAL
    US_EAST
    US_EAST2
    US_NORTH_CENTRAL
    US_SOUTH_CENTRAL
    US_WEST
    US_WEST2
    US_WEST_CENTRAL
}

enum AzureSubscriptionStatusEnum {
    Added
    Deleted
    Deleting
    DeletionFailed
    RefreshFailed
    Refreshed
    Refreshing
}

enum CalendarEmailAddressFilterTypeEnum {
    ALL
    ATTENDEE
    ORGANIZER
}

enum CalendarEventTypeEnum {
    SERIES_EXCEPTION
    SERIES_MASTER
    SERIES_OCCURRENCE
    SINGLE_INSTANCE
}

enum CalendarSearchKeywordTypeEnum {
    NAME
}

enum CalendarSearchObjectTypeEnum {
    ALL
    CALENDAR
    EVENT
}

enum CdmClusterStatusTypeEnum {
    Disconnected
    DownloadPackageFailed
    DownloadingPackage
    FailedToInitiateUpgrade
    OnOldRelease
    PrechecksFailureError
    PrechecksFailureWarning
    ReadyForDownload
    ReadyForUpgrade
    ResumingUpgrade
    RollbackFailed
    RollingBackUpgrade
    Stable
    Unknown
    UpgradeFailed
    UpgradeRecommended
    UpgradeScheduled
    Upgrading
}

enum CdmSnapshotGroupByEnum {
    Day
    Hour
    Month
    Quarter
    Week
    Year
}

enum CdmSnapshotSortByEnum {
    Date
    SnappableId
    SnapshotId
}

enum ChartType {
    BAR
    LINE
    PIE
    STACKED_BAR
}

enum ChronologicalOrderEnum {
    ASC
    DESC
}

enum ClassificationPolicyColor {
    COLOR_001
    COLOR_002
    COLOR_003
    COLOR_004
    COLOR_005
    COLOR_006
    COLOR_007
    COLOR_008
    COLOR_009
    COLOR_010
    COLOR_011
    COLOR_012
    UNKNOWN
}

enum ClassificationPolicyMode {
    COMPLIANCE
    DISCOVERY
}

enum CloudAccountActionEnum {
    CREATE
    DELETE
    UPDATE_CHILD_ACCOUNTS
    UPDATE_PERMISSIONS
    UPDATE_REGIONS
}

enum CloudAccountFeatureEnum {
    ALL
    APP_FLOWS
    ARCHIVAL
    CLOUDACCOUNTS
    CLOUD_NATIVE_PROTECTION
    EXOCOMPUTE
    GCP_SHARED_VPC_HOST
    RDS_PROTECTION
}

enum CloudAccountFilterFieldEnum {
    ACCOUNT_PROVIDER_TYPE
    IS_KEY_BASED
    NAME
}

enum CloudAccountSortByFieldEnum {
    NAME
}

enum CloudAccountStatusEnum {
    CONNECTED
    CONNECTING
    DISABLED
    DISCONNECTED
    MISSING_PERMISSIONS
}

enum CloudNativeLabelObjectType {
    GCP_DISK
    GCP_GCE_INSTANCE
}

enum CloudNativeTagObjectType {
    AWS_EBS_VOLUME
    AWS_EC2_INSTANCE
    AWS_RDS_INSTANCE
    AZURE_MANAGED_DISK
    AZURE_VIRTUAL_MACHINE
}

enum CloudNativeTagRuleFilterFieldsEnum {
    AWS_ACCOUNT
    CLOUD_NATIVE_ACCOUNT
    NAME
    SLA_DOMAIN
}

enum CloudNativeTagRuleSortByFieldsEnum {
    NAME
    SLA_DOMAIN
    TAG
}

enum CloudProviderEnum {
    AWS
    AZURE
}

enum CloudProviderTypeEnum {
    CLOUD_ACCOUNT_AWS
    CLOUD_ACCOUNT_AWS_ROLE_BASED
    CLOUD_ACCOUNT_AZURE
    CLOUD_ACCOUNT_GCP
    UNKNOWN_CLOUD_ACCOUNT
}

enum ClusterDiskStatus {
    ACTIVE
    FAILED
    LOCKED
    MISSING
    REMOVED
    UNFORMATTED
    UNKNOWN
}

enum ClusterDiskType {
    FLASH
    HDD
    UNKNOWN
}

enum ClusterGroupByEnum {
    Day
    Hour
    Month
    Quarter
    Type
    Week
    Year
}

enum ClusterJobStatusTypeEnum {
    DownloadPackageFailed
    DownloadingPackage
    FailedToInitiateUpgrade
    PreCheckFailureError
    PreCheckFailureWarning
    ReadyForDownload
    ReadyForUpgrade
    ResumingUpgrade
    RollbackFailed
    RollingBackUpgrade
    Unknown
    UpToDate
    UpgradeFailed
    Upgrading
}

enum ClusterProductEnum {
    CDM
    DATOS
    POLARIS
}

enum ClusterSortByEnum {
    ClusterName
    ClusterType
    RegisteredAt
}

enum ClusterStatus {
    Connected
    Disconnected
    Initializing
}

enum ClusterTypeEnum {
    Cloud
    ExoCompute
    OnPrem
    Polaris
    Robo
    Unknown
}

enum ComplianceStatusEnum {
    Empty
    InCompliance
    NotApplicable
    NotAvailable
    OutOfCompliance
    Unprotected
}

enum ComponentEnum {
    APP_FLOWS
    AWS_NATIVE
    AWS_SOURCE
    AZURE_NATIVE
    BLOBSTORE
    CEREBRO
    CLOUD_ACCOUNTS
    CLOUD_NATIVE
    COLOSSUS
    DATA_GOV
    EXO_COMPUTE
    GCP_NATIVE
    GPS
    O365
    PLATFORM
    SNAPPABLES
    USER_MANAGEMENT
}

enum ConfiguredSlaTypeEnum {
    CONFIGURED_SLA_TYPE_EMPTY_VALUE
    CONFIGURED_SLA_TYPE_PROTECTION_SLA
    CONFIGURED_SLA_TYPE_RETENTION_SLA
}

enum ConflictResolutionAuthzEnum {
    ALLOW_AUTO_CONFLICT_RESOLUTION
    NONE
    NO_CONFLICT_RESOLUTION
}

enum ConnectionStatusType {
    CONNECTED
    DISCONNECTED
}

"Tells whether snapshot has app or crash consistency"
enum ConsistencyLevelEnum {
    AppConsistent
    CrashConsistent
    FileSystemConsistent
    Inconsistent
    Unknown
    VssConsistent
}

enum ContextFilterTypeEnum {
    APPFLOWS_FAILOVER_TO_AWS
    APPFLOWS_FAILOVER_TO_CDM
    DEFAULT
}

enum CrawlStatusEnum {
    COMPLETE
    COMPLETE_WITH_FAIL
    IN_PROGRESS
    IN_PROGRESS_WITH_FAIL
}

enum CustomReportGroupByEnum {
    ReportFocus
}

enum CustomReportSortByEnum {
    CreationTime
    UpdateTime
    ViewTime
}

enum DataGovAuditEventTypeEnum {
    CREATE
    DELETE
    READ
    RENAME
    UNKNOWN_EVENT
    WRITE
}

enum DataGovAuditTargetTypeEnum {
    ISILON
    NETAPP
    UNKNOWN_TARGET
    WINDOWS
    WINDOWS_MINIFILTER
}

enum DataGovFileModeEnum {
    DIRECTORY
    FILE
    SYMLINK
    UNKNOWN
}

enum DataGovOsTypeEnum {
    LINUX
    NONE
    WINDOWS
}

enum DataGovShareTypeEnum {
    NFS
    SMB
    UNKNOWN_SHARE_TYPE
}

enum DataGovSortOrderEnum {
    ASC
    DESC
}

enum DataTypeEnum {
    BOOLEAN
    BYTE
    DATE_TIME
    FILTER_DATE_RANGE
    FLOAT
    INTEGER
    LONG
    STRING
    URL
}

enum DataViewTypeEnum {
    BACKUP_COMPLIANCE
    INDEXING
    MONITORING_ALL
    MONITORING_CANCELED
    MONITORING_COMPLETED
    MONITORING_FAILED
    MONITORING_IN_PROGRESS
    MONITORING_SCHEDULED
}

enum DayOfMonthEnum {
    FIFTEENTH
    FIRST_DAY
    LAST_DAY
}

enum DayOfQuarterEnum {
    FIRST_DAY
    LAST_DAY
}

enum DayOfWeekEnum {
    FRIDAY
    MONDAY
    SATURDAY
    SUNDAY
    THURSDAY
    TUESDAY
    WEDNESDAY
}

enum DayOfYearEnum {
    FIRST_DAY
    LAST_DAY
}

enum DeltaTypeEnum {
    BYTES_CREATED
    BYTES_DELETED
    BYTES_MODIFIED
    NODES_CREATED
    NODES_DELETED
    NODES_MODIFIED
    NODES_SUSPICIOUS
}

enum DiskEncryptionType {
    CUSTOMER_MANAGED_KEY
    CUSTOMER_MANAGED_KEY_RESOURCE_ID
    GOOGLE_MANAGED_KEY
    SOURCE_DISK_ENCRYPTION
}

enum DownloadStatusEnum {
    COMPLETED
    FAILED
    IN_PROGRESS
    PENDING
}

enum EmailAddressFilterTypeEnum {
    ALL
    FROM
    TO
}

"Available options for retention for existing snapshots"
enum ExistingSnapshotRetentionEnum {
    "Expire immediately"
    EXPIRE_IMMEDIATELY
    "Keep forever"
    KEEP_FOREVER
    NOT_APPLICABLE
    "Preserve retention from previous SLA"
    RETAIN_SNAPSHOTS
}

enum FailoverGroupByEnum {
    Day
    FailoverStatus
    FailoverType
    Hour
    LastTestStatus
    Month
    Quarter
    Source
    TargetSite
    Week
    Year
}

enum FailoverSortByEnum {
    AppBlueprintName
    SourceSiteName
    StartTime
    TargetSiteName
}

enum FailoverStatusEnum {
    FailoverCleanupStarted
    FailoverFailed
    FailoverJobFailed
    FailoverJobSucceeded
    Ongoing
    Paused
    TestFailoverSucceeded
}

enum FailoverTableColumnEnum {
    AppBlueprintName
    Duration
    EndTime
    FailoverStatus
    FailoverType
    LastTestStatus
    LastTestTime
    Source
    StartTime
    TargetSite
}

enum FailoverTypeEnum {
    FAILOVER
    TEST_FAILOVER
}

enum FeatureFlagEntityTypeEnum {
    ACCOUNT
    RANDOM
    SESSION
    USER
}

enum FeatureFlagNameEnum {
    AWSAutoProtectByTagsEnabled
    AWSCrossRegionReplicationEnabled
    AWSCustomCMKInExportEnabled
    AWSCustomKeyPairInExportEnabled
    AWSEc2CrashConsistentSnapshotEnabled
    AWSFileIndexingEnabled
    AWSFilterByTagsEnabled
    AWSReplaceVolumeOptionEnabled
    AWSSnapshotIntegrityEnabled
    AddonsUIEnabled
    AppFlowsEnabled
    AppFlowsGAEnabled
    AutoStorageSettingClusterListEnabled
    AwsChinaCloudEnabled
    AwsComputeSettingsEnabled
    AwsCrossAccountReplicationEnabled
    AwsExocomputeConfigEnabled
    AwsNativeArchivalEnabled
    AwsRDSAutoProtectByTagsEnabled
    AwsRDSProtectionEnabled
    AwsRoleBasedArchivalLocationsEnabled
    AwsSnsSqsBasedAutomatedFlowEnabled
    AzureAutoProtectByTagsEnabled
    AzureCrossRegionReplicationEnabled
    AzureCrossSubscriptionExportEnabled
    AzureLockSnapshotsEnabled
    AzureNationalCloudEnabled
    AzureRecoverPoweredOffEnabled
    AzureSeparateResourceGroupEnabled
    AzureSnapshotIntegrityEnabled
    CapacityReportNativeSnappableEnabled
    CdmUpgradesEnabled
    CloudAccountForAppFlowsEnabled
    CloudAccountListCombinedEnabled
    CloudAccountsAwsUpgradePermissionEnabled
    CloudAccountsAzureUpgradePermissionEnabled
    CloudAccountsSeamlessFlowEnabled
    CloudAccountsStackSetFlowEnabled
    CloudNativeAWSEnabled
    CloudNativeAzureEnabled
    CloudNativeGCPEnabled
    CloudNativeOnDemandSnapshotsWithSLA
    CloudNativeSnapshotIntegrityEnabled
    ClusterAddForbidden
    ClusterListFilterEnabled
    ClusterStatusEnabled
    ComplianceReportNativeSnappableEnabled
    DarkSiteEnabled
    DataClassificationDevEnabled
    DataClassificationEnabled
    DatagovNasAuditEnabled
    DatagovUAEnabled
    EnforceMoatOnAPIsEnabled
    ExpandedGlobalSearchEnabled
    FederatedLoginEnabled
    FilesetInventoryEnabled
    FilesetInventoryGAEnabled
    FilesetRbacEnabled
    GcpNativeAutoProtectByTagsEnabled
    GcpNativeCrossProjectInstanceExport
    GcpNativeDiskProtection
    GcpNativeExportEncryptedInstances
    GcpNativeExportInstanceInStoppedState
    GcpNativeExportInstancesInSharedVPC
    GcpNativeRestoreEncryptedInstances
    GcpNativeSnapshotStorageReport
    GlobalSLAGPSEnabled
    JobMonitoringUIEnabled
    LambdaEnabled
    LdapEnabled
    MetadataSyncAdvancedMetricsEnabled
    MetadataSyncEnabled
    MetadataSyncQuickHashEnabled
    NasFilesetRbacEnabled
    O365CalendarEnabled
    O365InventoryEnabled
    O365OnedriveEnabled
    O365OnedriveGAEnabled
    O365SharePointEnabled
    O365SharedMailboxEnabled
    ObjectLevelRBACEnabled
    ObjectTypeSLAEnhancementEnabled
    OnDemandCrawlEnabled
    OnDemandSnapshotExpirationEnabled
    OnPremNotificationEnabled
    RBACForGlobalSLAEnabled
    RBACRemoveCasbinEnabled
    RadarAnomalyModelBEnabled
    RadarBetaEnabled
    RadarDemoEnabled
    RadarDevEnabled
    ReportAsyncDownloadEnabled
    ReportForecasterEnabled
    ReportLastSyncedDateEnabled
    ReportPDFEnabled
    RollbackOnSuccessEnabled
    SLAHierarchyEnabled
    SLASyncHighFreqEnabled
    SSOEnhancementEnabled
    SapHanaInventoryEnabled
    ScheduledReportEnabled
    SecureUploadEnabled
    SkipFailedEventQueryEnabled
    SnapshotWindowEnabled
    SonarDashEnabled
    SonarUKAnalyzersEnabled
    SsoEnabled
    StaticRetentionEnabled
    SystemAnnouncementsEnabled
    UAFileCountsEnabled
    UnmanagedObjectEnabled
    VSphereFeatureEnablementEnabled
    VSphereInventoryEnabled
    VSphereSearchAndRecoveryRolloutEnabled
    WIPEnabled
    WorkflowBasedRolesEnabled
}

enum FeatureNameEnum {
    FilesetManagement
    NotSpecified
    VmwareManagement
}

enum FieldEnum {
    ALL
    IS_COMPLETE
    IS_DELETED_FROM_SOURCE
    IS_EXPIRED
    IS_HINT_SET
    IS_INDEXED
    IS_INDEX_MERGED
    IS_ON_DEMAND
    TIME_RANGE_WITH_OFFSET
}

enum FileCountTypeEnum {
    ANY
    HITS
    OPEN_ACCESS
    OPEN_ACCESS_HITS
    STALE
    STALE_HITS
}

enum FileModeEnum {
    DIRECTORY
    FILE
    SYMLINK
}

enum FileResultSortByEnum {
    DAILY_CHANGE
    HITS
    NAME
}

enum FileVersionSourceEnum {
    CLOUD
}

enum FilesetOSType {
    LINUX
    NO_OS_TYPE
    UNIX_LIKE
    WINDOWS
}

enum FilesetTemplateCreateOperatingSystemTypeEnum {
    FILESET_TEMPLATE_CREATE_OPERATING_SYSTEM_TYPE_EMPTY_VALUE
    FILESET_TEMPLATE_CREATE_OPERATING_SYSTEM_TYPE_UNIX_LIKE
    FILESET_TEMPLATE_CREATE_OPERATING_SYSTEM_TYPE_WINDOWS
}

enum FilesetTemplateCreateShareTypeEnum {
    FILESET_TEMPLATE_CREATE_SHARE_TYPE_EMPTY_VALUE
    FILESET_TEMPLATE_CREATE_SHARE_TYPE_NFS
    FILESET_TEMPLATE_CREATE_SHARE_TYPE_SMB
}

enum FilesetTemplatePatchOperatingSystemTypeEnum {
    FILESET_TEMPLATE_PATCH_OPERATING_SYSTEM_TYPE_EMPTY_VALUE
    FILESET_TEMPLATE_PATCH_OPERATING_SYSTEM_TYPE_UNIX_LIKE
    FILESET_TEMPLATE_PATCH_OPERATING_SYSTEM_TYPE_WINDOWS
}

enum FilesetTemplatePatchShareTypeEnum {
    FILESET_TEMPLATE_PATCH_SHARE_TYPE_EMPTY_VALUE
    FILESET_TEMPLATE_PATCH_SHARE_TYPE_NFS
    FILESET_TEMPLATE_PATCH_SHARE_TYPE_SMB
}

enum FilterTypeEnum {
    DATE_RANGE
    MULTI_SELECT
    SEARCH
    SINGLE_SELECT
}

enum FrequencyUnitEnum {
    DAILY
    MONTHLY
}

enum GcpNativeDiskSortFieldsEnum {
    ASSIGNED_SLA_DOMAIN
    EFFECTIVE_SLA_DOMAIN
    GCP_DISK_LOCATION
    GCP_DISK_NATIVE_ID
    GCP_DISK_NATIVE_NAME
    GCP_DISK_PROJECT_NAME
    GCP_DISK_SIZE
}

enum GcpNativeGCEInstanceSortFieldsEnum {
    ASSIGNED_SLA_DOMAIN
    EFFECTIVE_SLA_DOMAIN
    GCP_INSTANCE_NATIVE_ID
    GCP_INSTANCE_NATIVE_NAME
    GCP_INSTANCE_NETWORK_NAME
    GCP_INSTANCE_PROJECT_NAME
    GCP_INSTANCE_REGION
    GCP_INSTANCE_TYPE
}

enum GcpNativeLabelFilterTypeEnum {
    LABEL_KEY
    LABEL_KEY_VALUE
}

enum GcpNativeProjectSortFieldsEnum {
    EFFECTIVE_SLA_DOMAIN
    GCP_PROJECT_DISK_COUNT
    GCP_PROJECT_INSTANCE_COUNT
    GCP_PROJECT_NATIVE_ID
    GCP_PROJECT_NUMBER
    GCP_PROJECT_ORG_NAME
    NAME
}

enum GcpNativeProjectStatusEnum {
    Deleted
    Deleting
    DeletionFailed
    Refreshed
    Refreshing
}

enum GlobalSlaQueryFilterInputField {
    CLUSTER_UUID
    NAME
    OBJECT_TYPE
}

enum GroupByFieldEnum {
    Analyzer
    Cluster
    ClusterType
    ClusterUuid
    ComplianceStatus
    Day
    FailoverStatus
    FailoverType
    File
    Hour
    IsAnomaly
    LastActivityStatus
    LastActivityType
    LastTestStatus
    ManagedId
    Month
    Object
    ObjectName
    ObjectType
    POLICY_VIOLATIONS
    Policy
    ProtectionStatus
    PullTimeWithOffset
    Quarter
    SLADomain
    STATUS_POLICY
    SlaDomain
    Source
    Status
    TIME_ISSUES
    TIME_VIOLATIONS
    TargetSite
    TaskDetailClusterType
    TaskDetailObjectType
    Time
    Type
    UserAuditStatus
    UserAuditType
    Week
    Year
}

enum GuestCredentialAuthorizationStatusEnum {
    FAILED
    PENDING
    SUCCESSFUL
}

enum GuestOSEnum {
    CENTOS
    RHEL
    UBUNTU
    UNKNOWN
    WINDOWS
}

"The guest operating system"
enum GuestOsTypeEnum {
    "Linux Operating System"
    Linux
    "Unknown Guest OS type"
    Unknown
    "Windows Operating System"
    Windows
}

enum HierarchyFilterField {
    AWS_NATIVE_ACCOUNT_ENABLED_FEATURE
    AWS_NATIVE_ACCOUNT_ID
    AWS_NATIVE_EC2_INSTANCE_ID
    AWS_NATIVE_RDS_DB_ENGINE
    AWS_NATIVE_RDS_DB_INSTANCE_CLASS
    AWS_REGION
    AWS_TAG
    AWS_VPC_ID
    AZURE_DISK_ATTACHED_VM
    AZURE_DISK_RG_NAME
    AZURE_DISK_RG_SUBSCRIPTION_ID
    AZURE_DISK_SIZE
    AZURE_DISK_SUBSCRIPTION_ID
    AZURE_DISK_TYPE
    AZURE_REGION
    AZURE_TAG
    AZURE_VM_RG_NAME
    AZURE_VM_RG_SUBSCRIPTION_ID
    AZURE_VM_SIZE
    AZURE_VM_SUBSCRIPTION_ID
    AZURE_VNET_NAME
    CLUSTER_ID
    CLUSTER_TYPE
    EBS_VOLUME_ID
    EBS_VOLUME_INDEXING_STATUS
    EBS_VOLUME_NAME
    EBS_VOLUME_NAME_OR_VOLUME_ID
    EBS_VOLUME_TYPE
    EC2_INSTANCE_ID
    EC2_INSTANCE_INDEXING_STATUS
    EC2_INSTANCE_NAME
    EC2_INSTANCE_NAME_OR_INSTANCE_ID
    EC2_INSTANCE_TYPE
    EFFECTIVE_SLA
    EFFECTIVE_SLA_SOURCE_OBJECT
    EFFECTIVE_SLA_TYPE
    FILESET_SLA
    FILESET_TEMPLATE_ID
    FILESET_TEMPLATE_OS_TYPE
    GCP_LABEL
    GCP_NATIVE_DISK_LOCATION
    GCP_NATIVE_DISK_NAME_OR_NATIVE_ID
    GCP_NATIVE_DISK_PROJECT
    GCP_NATIVE_DISK_TYPE
    GCP_NATIVE_INSTANCE_NAME_OR_NATIVE_ID
    GCP_NATIVE_INSTANCE_NETWORK_NAME
    GCP_NATIVE_INSTANCE_TYPE
    GCP_NATIVE_PROJECT_ID
    GCP_NATIVE_PROJECT_NAME_OR_PROJECT_NUMBER
    GCP_NATIVE_REGION
    HAS_PARENT_SNAPPABLE
    IS_ARCHIVED
    IS_GHOST
    IS_PHYSICAL_HOST_RELIC
    IS_PROTECTED
    IS_RELIC
    IS_REPLICATED
    NAME
    NAME_EXACT_MATCH
    NAME_OR_EMAIL_ADDRESS
    O365_SPECIFIC_TYPE
    ON_OR_ABOVE_CLUSTER_VERSION
    OS_NAME
    OS_TYPE
    PHYSICAL_HOST_CONNECTION_STATUS
    PHYSICAL_HOST_EFFECTIVE_SLA
    PHYSICAL_HOST_ID
    SAP_HANA_SYSTEM_ID
    SAP_HANA_SYSTEM_SID
    SAP_HANA_SYSTEM_STATUS
}

enum HierarchyObjectTypeEnum {
    AllSubHierarchyType
    AppBlueprint
    AwsNativeAccount
    AwsNativeEbsVolume
    AwsNativeEc2Instance
    AwsNativeRdsInstance
    AzureNativeDiskResourceGroup
    AzureNativeManagedDisk
    AzureNativeSubscription
    AzureNativeVMResourceGroup
    AzureNativeVm
    CloudNativeTagRule
    Ec2Instance
    Fileset
    FilesetTemplate
    GcpNativeDisk
    GcpNativeGCEInstance
    GcpNativeProject
    HostShare
    HypervVirtualMachine
    LinuxFileset
    ManagedVolume
    MongoCollection
    MongoDb
    MongoSource
    Mssql
    NutanixVirtualMachine
    O365Calendar
    O365File
    O365Mailbox
    O365Onedrive
    O365Org
    O365SharepointDrive
    O365Site
    O365User
    OracleDatabase
    PhysicalHost
    PolarisEbsVolume
    PolarisEc2Instance
    SapHanaDatabase
    SapHanaSystem
    ShareFileset
    StorageArrayVolumeGroup
    VSphereComputeCluster
    VSphereDatacenter
    VSphereDatastore
    VSphereFolder
    VSphereHost
    VSphereNetwork
    VSphereTag
    VSphereTagCategory
    VSphereVCenter
    VcdOrg
    VcdOrgVdc
    VcdVapp
    VmwareVirtualMachine
    WindowsFileset
    WindowsVolumeGroup
}

enum HierarchySortByField {
    ASSIGNED_SLA_DOMAIN
    AWS_NATIVE_ACCOUNT_NAME
    AWS_NATIVE_RDS_DB_ENGINE
    AWS_NATIVE_RDS_DB_INSTANCE_CLASS
    AWS_REGION
    AWS_VPC_ID
    AZURE_DISK_ATTACHED_VM
    AZURE_DISK_RG_DISKCOUNT
    AZURE_DISK_RG_NAME
    AZURE_DISK_RG_SUBSCRIPTION_NAME
    AZURE_DISK_SIZE
    AZURE_DISK_SUBSCRIPTION_NAME
    AZURE_DISK_TYPE
    AZURE_REGION
    AZURE_SUBNET_NAME
    AZURE_SUBSCRIPTION_DISKCOUNT
    AZURE_SUBSCRIPTION_VMCOUNT
    AZURE_TENANT_ID
    AZURE_VM_RG_NAME
    AZURE_VM_RG_SUBSCRIPTION_NAME
    AZURE_VM_RG_VMCOUNT
    AZURE_VM_SIZE
    AZURE_VM_SUBSCRIPTION_NAME
    AZURE_VNET_NAME
    EBS_VOLUME_COUNT
    EBS_VOLUME_ID
    EBS_VOLUME_NAME
    EBS_VOLUME_SIZE
    EBS_VOLUME_TYPE
    EC2_INSTANCE_COUNT
    EC2_INSTANCE_ID
    EC2_INSTANCE_NAME
    EC2_INSTANCE_TYPE
    EFFECTIVE_SLA_DOMAIN
    EMAIL_ADDRESS
    FILESET_TEMPLATE_DOES_NOT_EXCLUDE
    FILESET_TEMPLATE_EXCLUDES
    FILESET_TEMPLATE_INCLUDES
    GCP_DISK_LOCATION
    GCP_DISK_NATIVE_ID
    GCP_DISK_NATIVE_NAME
    GCP_DISK_PROJECT_NAME
    GCP_DISK_SIZE
    GCP_INSTANCE_NATIVE_ID
    GCP_INSTANCE_NATIVE_NAME
    GCP_INSTANCE_NETWORK_NAME
    GCP_INSTANCE_PROJECT_NAME
    GCP_INSTANCE_REGION
    GCP_INSTANCE_TYPE
    GCP_PROJECT_DISK_COUNT
    GCP_PROJECT_INSTANCE_COUNT
    GCP_PROJECT_NATIVE_ID
    GCP_PROJECT_NUMBER
    GCP_PROJECT_ORG_NAME
    ID
    NAME
    PHYSICAL_HOST_CONNECTION_STATUS
    PHYSICAL_HOST_OS_NAME
    SAP_HANA_SYSTEM_SID
    SAP_HANA_SYSTEM_STATUS
}

enum HierarchySortOrder {
    ASC
    DESC
}

enum HostConnectivityStatusEnum {
    BADLY_CONFIGURED
    CONNECTED
    CONNECTING
    CONNECTOR_NOT_DEPLOYED
    DELETING
    DELETION_FAILED
    DISCONNECTED
    PARTIALLY_CONNECTED
    REFRESHING
    REFRESH_FAILED
    REMOTE
    REPLICATED_TARGET
    UNKNOWN_CONNECTIVITY_STATUS
}

enum HostRoot {
    LINUX_HOST_ROOT
    NAS_HOST_ROOT
    WINDOWS_HOST_ROOT
}

enum HostVfdInstallConfigEnum {
    HOST_VFD_INSTALL_CONFIG_DISABLED
    HOST_VFD_INSTALL_CONFIG_EMPTY_VALUE
    HOST_VFD_INSTALL_CONFIG_ENABLED
}

enum HostVfdStateEnum {
    HOST_VFD_STATE_EMPTY_VALUE
    HOST_VFD_STATE_INSTALLED
    HOST_VFD_STATE_INSTALLED_BUT_RESTART_REQUIRED
    HOST_VFD_STATE_NOT_INSTALLED
    HOST_VFD_STATE_UNINSTALLED_BUT_RESTART_REQUIRED
}

enum InfrastructureTableColumnEnum {
    ClusterName
    ClusterType
    EncryptionEnabled
    EstimatedRunway
    Location
    TotalCapacity
    UsedCapacity
}

enum InstanceTypeEnum {
    AZURE_CHINA
    AZURE_DEFAULT
    AZURE_GERMANY
    AZURE_GOVERNMENT
    UNKNOWN_INSTANCE
}

enum InterfaceTypeEnum {
    BOND0
    BOND1
    CUSTOM
    UNKNOWN_TYPE
}

enum InventorySubHierarchyRootEnum {
    APPFLOWS_ROOT
    AWSNATIVE_ROOT
    AZURENATIVE_ROOT
    CLOUD_NATIVE_TAG_RULE_ROOT
    GCPNATIVE_ROOT
    HYPERV_ROOT
    LINUX_HOST_ROOT
    MANAGED_VOLUME_ROOT
    MONGO_ROOT
    MSSQL_ROOT
    NAS_HOST_ROOT
    NUTANIX_ROOT
    O365_ROOT
    ORACLE_ROOT
    PHYSICAL_HOST_ROOT
    SAP_HANA_ROOT
    VCD_ROOT
    VSPHERE_ROOT
    WINDOWS_HOST_ROOT
}

enum IssueEventTypeEnum {
    ADD_WHITELIST_EVENT
    CREATE_EVENT
    DELETE_POLICY_EVENT
    NO_ISSUES_SNAPSHOT_EVENT
    REMOVE_POLICY_OBJ_EVENT
    REMOVE_WHITELIST_EVENT
    SNAPSHOT_EVENT
}

enum IssueStatusEnum {
    OPEN
    RESOLVED
}

enum LastTestStatusEnum {
    Failed
    NotExist
    Succeeded
}

enum LdapAuthorizedPrincipalFieldEnum {
    DirectoryName
    Email
    Name
}

enum LdapIntegrationFieldEnum {
    Name
}

enum LdapPrincipalFieldEnum {
    Name
}

"type of data location"
enum LocationTypeEnum {
    Azure
    CLOUD_NATIVE_AWS
    CLOUD_NATIVE_GCP
    Cleversafe
    Glacier
    Google
    HDS
    LOCAL
    Nfs
    Qstar
    REPLICATION_OFF
    REPLICATION_POLARIS_SOURCE
    REPLICATION_SOURCE
    REPLICATION_SOURCE_AND_TARGET
    REPLICATION_TARGET
    Rehydrated
    S3
    S3Compatible
    Scality
}

enum LogLevelEnum {
    DEBUG
    INFO
}

enum ManagedObjectType {
    APP_BLUEPRINT
    AWS_NATIVE_ACCOUNT
    AWS_NATIVE_EBS_VOLUME
    AWS_NATIVE_EC2_INSTANCE
    AWS_NATIVE_RDS_INSTANCE
    AZURE_MANAGED_DISK
    AZURE_RESOURCE_GROUP_FOR_DISK_HIERARCHY
    AZURE_RESOURCE_GROUP_FOR_VM_HIERARCHY
    AZURE_SUBSCRIPTION
    AZURE_UNMANAGED_DISK
    AZURE_VIRTUAL_MACHINE
    CLOUD_NATIVE_TAG_RULE
    FILESET_TEMPLATE
    GCP_NATIVE_DISK
    GCP_NATIVE_GCE_INSTANCE
    GCP_NATIVE_PROJECT
    HOST_SHARE
    LINUX_FILESET
    MONGO_COLLECTION
    MONGO_DB
    MONGO_SOURCE
    O365_CALENDAR
    O365_INDIVIDUAL_MAILBOX
    O365_INDIVIDUAL_USER
    O365_MAILBOX
    O365_ONEDRIVE
    O365_ORGANIZATION
    O365_SHARED_MAILBOX
    O365_SHARED_USER
    O365_SHAREPOINT_DRIVE
    O365_SITE
    O365_USER
    PHYSICAL_HOST
    SAP_HANA_DATABASE
    SAP_HANA_SYSTEM
    SHARE_FILESET
    VCD_ORG
    VCD_ORG_VDC
    VCD_VAPP
    VSPHERE_COMPUTE_CLUSTER
    VSPHERE_DATACENTER
    VSPHERE_DATASTORE
    VSPHERE_FOLDER
    VSPHERE_HOST
    VSPHERE_NETWORK
    VSPHERE_TAG
    VSPHERE_TAG_CATEGORY
    VSPHERE_VCENTER
    VSPHERE_VIRTUAL_MACHINE
    WINDOWS_FILESET
}

enum MissedSnapshotGroupByEnum {
    Day
    Hour
    Month
    Quarter
    Week
    Year
}

enum MissedSnapshotSortByEnum {
    Date
}

enum MonthEnum {
    APRIL
    AUGUST
    DECEMBER
    FEBRUARY
    JANUARY
    JULY
    JUNE
    MARCH
    MAY
    NOVEMBER
    OCTOBER
    SEPTEMBER
}

enum MssqlCbtEffectiveStatusTypeEnum {
    MSSQL_CBT_EFFECTIVE_STATUS_TYPE_EMPTY_VALUE
    MSSQL_CBT_EFFECTIVE_STATUS_TYPE_OFF
    MSSQL_CBT_EFFECTIVE_STATUS_TYPE_OFF_DEFAULT
    MSSQL_CBT_EFFECTIVE_STATUS_TYPE_ON
    MSSQL_CBT_EFFECTIVE_STATUS_TYPE_ON_DEFAULT
}

enum MssqlCbtStatusTypeEnum {
    MSSQL_CBT_STATUS_TYPE_DEFAULT
    MSSQL_CBT_STATUS_TYPE_DISABLED
    MSSQL_CBT_STATUS_TYPE_EMPTY_VALUE
    MSSQL_CBT_STATUS_TYPE_ENABLED
}

enum NetworkAdapterTypeEnum {
    E1000
    E1000E
    PCNET32
    VMXNET
    VMXNET2
    VMXNET3
}

enum NetworkTypeEnum {
    DHCP
    STATIC
}

enum O365ServiceAccountStatusEnum {
    INVALID
    NOT_CONFIGURED
    VALID
}

enum ObjectPolicyStatus {
    STALE
    UNKNOWN
    UP_TO_DATE
}

enum ObjectTypeEnum {
    AppBlueprint
    AwsNativeEbsVolume
    AwsNativeEc2Instance
    AwsNativeRdsInstance
    AzureNativeManagedDisk
    AzureNativeVm
    Ec2Instance
    Fileset
    GcpNativeDisk
    GcpNativeGCEInstance
    HypervVirtualMachine
    LinuxFileset
    ManagedVolume
    Mssql
    NutanixVirtualMachine
    O365Calendar
    O365File
    O365Mailbox
    O365Onedrive
    O365SharepointDrive
    O365Site
    OracleDatabase
    PolarisEbsVolume
    PolarisEc2Instance
    SapHanaDatabase
    ShareFileset
    StorageArrayVolumeGroup
    VcdVapp
    VmwareVirtualMachine
    WindowsFileset
    WindowsVolumeGroup
}

enum OnedriveSearchKeywordTypeEnum {
    FILE_TYPE
    NAME
}

enum OnedriveSearchObjectTypeEnum {
    ALL
    O365_FOLDER
    ONEDRIVE_FILE
}

enum OpenAccessTypeEnum {
    EXPLICIT
    INHERITED
    NOT_OPEN
    UNKNOWN_ACCESS
}

enum OperationEnum {
    AddAwsCloudAccount
    AddAzureCloudAccount
    AddCluster
    AddGcpCloudAccount
    AddInventory
    AddStorageSettings
    CancelRunningActivity
    CategoryManageDataSource
    CategoryProtection
    CategoryRecovery
    CategoryViewDataSource
    ConfigureDataClassGlobal
    CreateReport
    CreateSLA
    DeleteAwsCloudAccount
    DeleteAzureCloudAccount
    DeleteCluster
    DeleteGcpCloudAccount
    DeleteInventory
    DeleteReport
    DeleteSLA
    DeleteSnapshot
    DeleteStorageSettings
    Download
    DownloadFromArchivalLocation
    EditAwsCloudAccount
    EditAzureCloudAccount
    EditCdmNetworkSetting
    EditCdmSupportSetting
    EditCdmSysConfig
    EditGcpCloudAccount
    EditSecuritySettings
    EditStorageSettings
    EditSystemPreference
    EditUserManagement
    Export
    ExportDataClassGlobal
    ExportFiles
    ExportSnapshots
    InstantRecover
    ManageAccess
    ManageDataSource
    ManageLegalHold
    ManageProtection
    ManageSLA
    ModifyCluster
    ModifyInventory
    ModifyReport
    ModifySLA
    Mount
    ProvisionOnInfrastructure
    RefreshDataSource
    Restore
    RestoreToOrigin
    TakeOnDemandSnapshot
    TransferAccountOwnership
    UpgradeCluster
    ViewAccess
    ViewAuditLog
    ViewAwsCloudAccount
    ViewAzureCloudAccount
    ViewCdmNetworkSetting
    ViewCdmSupportSetting
    ViewCdmSysConfig
    ViewCluster
    ViewDashboard
    ViewDataClassGlobal
    ViewGcpCloudAccount
    ViewInventory
    ViewNonSystemEvent
    ViewReport
    ViewSLA
    ViewSecuritySettings
    ViewStorageSettings
    ViewSystemEvent
    ViewSystemPreference
    ViewUserManagement
}

enum OrgStatusEnum {
    ACTIVE
    DELETED
    DELETING
    REFRESHING
}

enum OsTypeEnum {
    Linux
    Other
    Undefined
    Windows
}

enum PendingActionGroupTypeEnum {
    APP_FLOW
    ARCHIVAL_LOCATION
    CLOUD_ACCOUNTS
    GLOBAL_SLA
    REPLICATION
    UNMANAGED_OBJECTS
}

enum PendingActionStatusEnum {
    FAILED
    IN_PROGRESS
    QUEUED
    SUCCEEDED
    SYNCED_TO_CDM
}

enum PendingActionSubGroupTypeEnum {
    ARCHIVAL_LOCATION_DELETE
    ARCHIVAL_LOCATION_PAUSE
    ARCHIVAL_LOCATION_RESUME
    AWS_COMPUTE_SETTING_UPSERT
    AWS_IAM_CUSTOMER_ACCOUNT_UPSERT
    AWS_ROLE_BASED_ARCHIVAL_LOCATION
    BLUEPRINT_CREATE
    BLUEPRINT_DELETE
    BLUEPRINT_DEPRECATE
    BLUEPRINT_UPDATE
    CLUSTER_PEER_TOKEN_GET
    CLUSTER_PEER_TOKEN_GET_AND_SET
    CLUSTER_PEER_TOKEN_SET
    DISABLE_REPLICATION_LOCATION_PUT
    ENABLE_LOCATION_AS_REPLICATION_TARGET
    ENABLE_POLARIS_AS_REPLICATION_SOURCE
    GLOBAL_SLA_ASSIGN
    GLOBAL_SLA_ASSIGN_RETENTION_SLA_TO_SNAPPABLE
    GLOBAL_SLA_ASSIGN_RETENTION_SLA_TO_SNAPSHOT
    GLOBAL_SLA_ASSIGN_RETENTION_SLA_TO_SNAPSHOT_V2
    GLOBAL_SLA_DELETE
    GLOBAL_SLA_PUT
    NFS_LOCATION_PUT
    OBJECT_STORE_LOCATION_PUT
    UNMANAGED_OBJECT_DELETE_SNAPSHOTS
    UNMANAGED_OBJECT_DELETE_SNAPSHOTS_OF_OBJECT
}

enum PendingActionSyncTypeEnum {
    CDM
    POLARIS
}

enum PlanNameEnum {
    FAILOVER
    TEST_FAILOVER
}

enum PolarisObjectAuthorizedOperationsEnum {
    ManageDataSource
    ManageProtection
    RefreshDataSource
    ViewInventory
}

enum PolarisSLASyncStatusEnum {
    FAILED
    PENDING
    SUCCEEDED
}

enum PolarisSnappableAuthorizedOperationsEnum {
    DeleteSnapshot
    Download
    ExportSnapshots
    ManageProtection
    RestoreToOrigin
    TakeOnDemandSnapshot
    ViewInventory
}

enum PolarisSnapshotGroupByEnum {
    Day
    Hour
    Month
    Quarter
    Week
    Year
}

enum PolarisSnapshotSortByEnum {
    Date
    SnappableId
    SnapshotId
}

enum PolicyObjectFilterEnum {
    ALL
    HAS_OBJECTS
    NO_OBJECTS
}

enum PrePostScriptFailureHandlingEnum {
    abort
    continue
}

enum PrechecksStatusTypeEnum {
    PrechecksFailureError
    PrechecksFailureWarning
    PrechecksSuccess
    Unknown
}

enum PrincipalTypeEnum {
    GROUP
    UNKNOWN
    USER
}

enum ProtectionStatusEnum {
    DoNotProtect
    NoSla
    Protected
}

enum RansomwareResultGroupByEnum {
    ClusterUuid
    ManagedId
    SnapshotDay
    SnapshotHour
    SnapshotMonth
    SnapshotWeek
    SnapshotYear
}

enum RansomwareResultSortByEnum {
    ClusterUuid
    EncryptionProbability
    IsEncrypted
    ManagedId
    SnappableId
    SnapshotDate
    SnapshotId
}

enum RecoverySpecTypeEnum {
    AWS_EC2
    UNKNOWN_VM
    VMWARE_VM
}

enum ReplicationTypeEnum {
    REPLICATION_TO_CLOUD_LOCATION
    REPLICATION_TO_CLOUD_REGION
    UNIDIRECTIONAL_REPLICATION_TO_CLUSTER
    UNKNOWN_REPLICATION_TYPE
}

enum ReportFocusEnum {
    Activity
    Anomaly
    Audit
    Capacity
    Compliance
    Failover
    Infrastructure
    Protection
    ProtectionTaskDetail
    RecoveryTaskDetail
    Sonar
    SonarContent
    TaskSummary
}

enum ReportTableColumnEnum {
    ActivityStatus
    ActivityType
    AnalyzersBreakdown
    AppBlueprintName
    ArchivalTarget
    ArchiveSnapshots
    ArchiveStorage
    BytesCreated
    BytesDeleted
    BytesModified
    BytesNetChanged
    Cluster
    ClusterLocation
    ClusterName
    ClusterType
    ComplianceStatus
    DataReduction
    DataTransferred
    DirectArchive
    Duration
    EncryptionEnabled
    EndDate
    EndTime
    EstimatedRunway
    FailoverStatus
    FailoverType
    FailureReason
    FileName
    FilesCreated
    FilesDeleted
    FilesModified
    IsAnomaly
    LastSnapshot
    LastTestStatus
    LastTestTime
    LastUpdated
    LocalSnapshots
    Location
    LogicalByte
    LogicalBytes
    MissedSnapshots
    NumCoveredObjects
    NumHighRiskLocations
    NumOfCanceled
    NumOfExpected
    NumOfFailed
    NumOfSucceeded
    NumViolatedFiles
    NumViolations
    ObjectName
    ObjectType
    Path
    PhysicalBytes
    PoliciesBreakdown
    PolicyName
    PolicyStatus
    PreviousSnapshotDate
    PreviousSnapshotId
    ProtectedVolume
    RecoveryPoint
    RecoveryPointType
    ReplicaSnapshots
    ReplicaStorage
    ReplicationSource
    ReplicationTarget
    Size
    SlaDomain
    SlaDomainName
    SnappableName
    SnappableType
    SnapshotConsistency
    SnapshotDate
    SnapshotId
    SnapshotTime
    Source
    StartDate
    StartTime
    Status
    SuspiciousFilesAdded
    TargetSite
    TaskType
    TotalCapacity
    TotalFileTransferred
    TotalHits
    TotalSnapshots
    TransferredBytes
    UsedCapacity
    UserAuditStatus
    UserAuditType
    UserName
}

enum RetentionUnitEnum {
    DAYS
    HOURS
    MINUTES
    MONTHS
    QUARTERS
    WEEKS
    YEARS
}

enum RoleFieldEnum {
    Name
}

enum SLAObjectTypeEnum {
    AWS_EC2_EBS_OBJECT_TYPE
    AWS_RDS_OBJECT_TYPE
    AZURE_OBJECT_TYPE
    GCP_OBJECT_TYPE
    O365_OBJECT_TYPE
    SAP_HANA_OBJECT_TYPE
    UNKNOWN_OBJECT_TYPE
    VSPHERE_OBJECT_TYPE
}

enum SLAQuerySortByFieldEnum {
    NAME
    PROTECTED_OBJECT_COUNT
}

enum SLAQuerySortByOrderEnum {
    ASC
    DESC
}

enum SMTPSecurityTypeEnum {
    NONE
    SSL
    STARTTLS
    TLS
}

enum SapHanaHostHostTypeEnum {
    SAP_HANA_HOST_HOST_TYPE_EMPTY_VALUE
    SAP_HANA_HOST_HOST_TYPE_MASTER
    SAP_HANA_HOST_HOST_TYPE_SECONDARY_MASTER
    SAP_HANA_HOST_HOST_TYPE_SECONDARY_SLAVE
    SAP_HANA_HOST_HOST_TYPE_SLAVE
}

enum SapHanaLogSnapshotSortByEnum {
    Date
}

enum SapHanaRecoverableRangeSortByEnum {
    EndTime
    StartTime
}

enum SapHanaSslInfoEncryptionProviderEnum {
    SAP_HANA_SSL_INFO_ENCRYPTION_PROVIDER_COMMON_CRYPTO
    SAP_HANA_SSL_INFO_ENCRYPTION_PROVIDER_EMPTY_VALUE
    SAP_HANA_SSL_INFO_ENCRYPTION_PROVIDER_OPENSSL
    SAP_HANA_SSL_INFO_ENCRYPTION_PROVIDER_SAP_CRYPTO
}

enum SapHanaSystemStatus {
    ERROR
    OK
    UNKNOWN_SYSTEM_STATUS
    WARNING
}

enum SapHanaSystemSummaryContainerTypeEnum {
    SAP_HANA_SYSTEM_SUMMARY_CONTAINER_TYPE_EMPTY_VALUE
    SAP_HANA_SYSTEM_SUMMARY_CONTAINER_TYPE_MULTI_CONTAINER
    SAP_HANA_SYSTEM_SUMMARY_CONTAINER_TYPE_SINGLE_CONTAINER
}

enum SapHanaSystemSummaryStatusEnum {
    SAP_HANA_SYSTEM_SUMMARY_STATUS_EMPTY_VALUE
    SAP_HANA_SYSTEM_SUMMARY_STATUS_ERROR
    SAP_HANA_SYSTEM_SUMMARY_STATUS_OK
    SAP_HANA_SYSTEM_SUMMARY_STATUS_UNKNOWN
    SAP_HANA_SYSTEM_SUMMARY_STATUS_WARNING
}

enum SearchKeywordTypeEnum {
    ALL
    FOLDER_NAME
    SUBJECT
}

enum SearchObjectTypeEnum {
    EMAIL
    FOLDER
}

"Share type for fileset"
enum ShareTypeEnum {
    "NFS share"
    NFS
    "not shared"
    NoShareType
    "SMB share"
    SMB
}

enum SkuEnum {
    STANDARD_GRS
    STANDARD_LRS
    STANDARD_ZRS
}

enum SlaAssignTypeEnum {
    doNotProtect
    noAssignment
    protectWithSlaId
}

enum SlaAssignmentTypeEnum {
    Derived
    Direct
    Unassigned
}

enum SnappableAggregationsEnum {
    ArchiveStorage
    Count
    MissedSnapshots
    PhysicalBytes
    ReplicaStorage
    TotalSnapshots
}

enum SnappableCrawlStatus {
    COMPLETE
    FAIL
    IN_PROGRESS
}

enum SnappableGroupByEnum {
    Cluster
    ClusterType
    ComplianceStatus
    Day
    Hour
    Month
    ObjectType
    ProtectionStatus
    PullTimeWithOffset
    Quarter
    SlaDomain
    Week
    Year
}

enum SnappableLevelHierarchyTypeEnum {
    AllSubHierarchyType
    AwsNativeEbsVolume
    AwsNativeEc2Instance
    AwsNativeRdsInstance
    GcpNativeGCEInstance
    O365Mailbox
    O365Onedrive
    O365SharepointDrive
    O365Site
}

enum SnappableSortByEnum {
    ArchiveSnapshots
    ArchiveStorage
    Cluster
    ClusterName
    ClusterType
    ComplianceStatus
    DataReduction
    LastSnapshot
    LocalSnapshots
    Location
    LogicalBytes
    LogicalDataReduction
    MissedSnapshots
    Name
    ObjectType
    PhysicalBytes
    ProtectionStatus
    ReplicaSnapshots
    ReplicaStorage
    SlaDomainName
    TotalSnapshots
    TransferredBytes
}

enum SnappableTableColumnEnum {
    ArchiveSnapshots
    ArchiveStorage
    ClusterName
    ClusterType
    ComplianceStatus
    DataReduction
    LastSnapshot
    LocalSnapshots
    Location
    LogicalByte
    MissedSnapshots
    ObjectType
    PhysicalBytes
    ReplicaSnapshots
    ReplicaStorage
    SlaDomain
    SnappableName
    TotalSnapshots
    TransferredBytes
}

enum SnapshotCloudStorageTierEnum {
    SNAPSHOT_CLOUD_STORAGE_TIER_AZURE_ARCHIVE
    SNAPSHOT_CLOUD_STORAGE_TIER_COLD
    SNAPSHOT_CLOUD_STORAGE_TIER_COOL
    SNAPSHOT_CLOUD_STORAGE_TIER_EMPTY_VALUE
    SNAPSHOT_CLOUD_STORAGE_TIER_GLACIER
    SNAPSHOT_CLOUD_STORAGE_TIER_GLACIER_DEEP_ARCHIVE
    SNAPSHOT_CLOUD_STORAGE_TIER_HOT
}

enum SnapshotFrequencyEnum {
    DAILY
    HOURLY
    MONTHLY
    NA
    QUARTERLY
    WEEKLY
    YEARLY
}

enum SnapshotGroupByTimeEnum {
    Day
    Hour
    Month
    Quarter
    Week
    Year
}

enum SnapshotQueryFilterField {
    EBS_AWS_NATIVE_ACCOUNT_ID
    EC2_AWS_NATIVE_ACCOUNT_ID
    IS_ARCHIVED
    IS_DELETED_FROM_SOURCE
    IS_DOWNLOADED
    IS_GCED
    IS_ON_DEMAND
    IS_REPLICA
    IS_SAP_HANA_INCREMENTAL_SNAPSHOT
    SLA_ID
    SNAPSHOT_TYPE
}

enum SnapshotQuerySortByField {
    CREATION_TIME
    UNKNOWN
}

enum SnapshotTypeEnum {
    DOWNLOADED
    ON_DEMAND
    SCHEDULED
}

enum SonarContentReportGroupByEnum {
    Analyzer
    Cluster
    File
    ObjectName
    Policy
    SLADomain
    Time
}

enum SonarContentReportSortByEnum {
    AnalyzerName
    Cluster
    FileName
    FilesWithHits
    Location
    ObjectName
    Path
    PolicyName
    SLADomain
    Size
    SnapshotTime
    TotalHits
}

enum SonarContentReportTableColumnEnum {
    AnalyzersBreakdown
    Cluster
    FileName
    ObjectName
    ObjectType
    Path
    PoliciesBreakdown
    Size
    SnapshotTime
    TotalHits
}

enum SonarReportGroupByEnum {
    POLICY_VIOLATIONS
    STATUS_POLICY
    TIME_ISSUES
    TIME_VIOLATIONS
}

enum SonarReportSortByEnum {
    NUM_HIGH_RISK_LOCATIONS
    NUM_OBJECTS
    NUM_VIOLATED_FILES
    NUM_VIOLATION
    POLICY_NAME
    POLICY_STATUS
}

enum SonarReportTableColumnEnum {
    NumCoveredObjects
    NumHighRiskLocations
    NumViolatedFiles
    NumViolations
    PolicyName
    PolicyStatus
}

enum SonarReportTablePolicyStatusEnum {
    DISCOVERY
    IN_COMPLIANCE
    OUT_OF_COMPLIANCE
}

enum SortByFieldEnum {
    ActivityStatus
    ActivityType
    AnalyzerName
    AnomalyProbability
    AppBlueprintName
    ArchiveSnapshots
    ArchiveStorage
    BytesCreatedCount
    BytesDeletedCount
    BytesModifiedCount
    BytesNetChangedCount
    Cluster
    ClusterName
    ClusterType
    ClusterUuid
    ComplianceStatus
    DataReduction
    Date
    EndTime
    FileName
    FilesCreatedCount
    FilesDeletedCount
    FilesModifiedCount
    FilesWithHits
    IsAnomaly
    LastSnapshot
    LastUpdated
    LocalSnapshots
    Location
    LogicalBytes
    LogicalDataReduction
    ManagedId
    MissedSnapshots
    NUM_HIGH_RISK_LOCATIONS
    NUM_OBJECTS
    NUM_VIOLATED_FILES
    NUM_VIOLATION
    Name
    NumCanceled
    NumExpected
    NumFailed
    NumSucceeded
    ObjectName
    ObjectType
    POLICY_NAME
    POLICY_STATUS
    Path
    PhysicalBytes
    PolicyName
    PreviousSnapshotDate
    PreviousSnapshotId
    ProtectionStatus
    RegisteredAt
    ReplicaSnapshots
    ReplicaStorage
    SLADomain
    Severity
    Size
    SlaDomainName
    SnappableName
    SnappableType
    SnapshotDate
    SnapshotId
    SnapshotTime
    SourceSiteName
    StartTime
    TargetSiteName
    Time
    TotalHits
    TotalSnapshots
    TransferredBytes
}

enum SortOrderEnum {
    Asc
    Desc
}

enum StalenessTypeEnum {
    IS_STALE
    NOT_STALE
}

enum TagFilterType {
    TAG_KEY
    TAG_KEY_VALUE
}

enum TagRuleSlaAssignTypeEnum {
    doNotProtect
    protectWithSlaId
}

enum TargetEncryptionTypeEnum {
    KMS_MASTER_KEY_BASED
    RSA_KEY_BASED
    UNKNOWN_ENCRYPTION_TYPE
}

enum TargetMappingQueryFilterFieldEnum {
    ARCHIVAL_GROUP_TYPE
    ARCHIVAL_LOCATION_TYPE
    NAME
}

enum TargetMappingSortByFieldEnum {
    NAME
}

enum TargetQueryFilterFieldEnum {
    IS_MANAGED_BY_AUTO_AG
    LOCATION_TYPE
    NAME
}

enum TargetSortByFieldEnum {
    NAME
}

enum TargetSyncStatusEnum {
    ACTION_FAILED
    NOT_CREATED_ON_CDM
    PENDING_SYNC
    SYNCED
}

enum TargetTypeEnum {
    AWS
    AZURE
    NFS
}

enum TaskDetailGroupByEnum {
    Cluster
    Day
    Hour
    Month
    Quarter
    Status
    TaskDetailClusterType
    TaskDetailObjectType
    Week
    Year
}

enum TaskDetailSortByEnum {
    EndTime
}

enum TaskDetailTableColumnEnum {
    ArchivalTarget
    ClusterLocation
    DataTransferred
    DirectArchive
    EndTime
    FailureReason
    Location
    LogicalBytes
    ObjectName
    ObjectType
    PhysicalBytes
    ProtectedVolume
    RecoveryPoint
    RecoveryPointType
    ReplicationSource
    ReplicationTarget
    SlaDomainName
    SnapshotConsistency
    StartTime
    Status
    TaskType
    TotalFileTransferred
    UserName
}

enum TaskReportTableColumnEnum {
    EndDate
    Location
    NumOfCanceled
    NumOfExpected
    NumOfFailed
    NumOfSucceeded
    ObjectName
    ObjectType
    SlaDomainName
    StartDate
}

enum TaskSummaryGroupByEnum {
    Cluster
    ClusterType
    Day
    Month
    Object
    ObjectType
    Quarter
    SlaDomain
    Week
    Year
}

enum TaskSummarySortByEnum {
    Date
    NumCanceled
    NumExpected
    NumFailed
    NumSucceeded
    ObjectName
    ObjectType
    SlaDomainName
}

enum TaskchainStateEnum {
    CANCELED
    CANCELING
    FAILED
    READY
    RUNNING
    SUCCEEDED
    UNDOING
}

enum TierEnum {
    COOL
    HOT
}

enum TimeDurationEnum {
    DAY
    HOUR
    MONTH
}

enum TimeUnitEnum {
    Day
    Hour
    Month
    Quarter
    Week
    Year
}

enum UpgradeInfoGroupByEnum {
    ClusterJobStatus
    Type
    VersionStatus
}

enum UpgradeInfoSortByEnum {
    ClusterJobStatus
    ClusterLocation
    ClusterName
    ClusterType
    DownloadedVersion
    InstalledVersion
    RegisteredAt
    VersionStatus
}

enum UserAuditGroupByEnum {
    Cluster
    ClusterType
    Day
    Hour
    Month
    ObjectType
    Quarter
    UserAuditStatus
    UserAuditType
    Week
    Year
}

enum UserAuditObjectTypeEnum {
    AppBlueprint
    ArchivalLocation
    AuthDomain
    AwsAccount
    AwsEventType
    AwsNativeAccount
    AwsNativeEbsVolume
    AwsNativeEc2Instance
    AwsNativeRdsInstance
    AzureNativeDisk
    AzureNativeSubscription
    AzureNativeVm
    Blueprint
    CloudNativeTagRule
    Cluster
    DataLocation
    Ec2Instance
    FailoverClusterApp
    GcpNativeDisk
    GcpNativeGceInstance
    GcpNativeProject
    Host
    HypervScvmm
    HypervServer
    HypervVm
    IpWhitelist
    JobInstance
    Ldap
    LinuxFileset
    LinuxHost
    ManagedVolume
    Mssql
    NasHost
    NutanixCluster
    NutanixVm
    O365Calendar
    O365Mailbox
    O365Onedrive
    O365Organization
    OracleDb
    OracleHost
    OracleRac
    PublicCloudMachineInstance
    SapHanaDb
    SapHanaSystem
    ShareFileset
    Sla
    SlaDomain
    SmbDomain
    Snapshot
    StorageArray
    StorageArrayVolumeGroup
    StorageSettings
    Storm
    SupportTunnel
    SystemPreference
    UnknownObjectType
    Upgrade
    User
    UserActionAudit
    UserGroup
    UserRole
    Vcd
    VcdVapp
    Vcenter
    VmwareMount
    VmwareVm
    VolumeGroup
    WindowsFileset
    WindowsHost
}

enum UserAuditSeverityEnum {
    Critical
    Info
    NA
    Warning
}

enum UserAuditSortByEnum {
    Time
}

enum UserAuditStatusEnum {
    Failure
    Success
}

enum UserAuditTableColumnEnum {
    ClusterName
    ClusterType
    UserAuditStatus
    UserAuditType
}

enum UserAuditTypeEnum {
    AccessManagement
    Audit
    Backup
    Classification
    Configuration
    Diagnostic
    Failover
    Login
    Recovery
    Search
    SlaAssignment
    SlaModification
    Sync
    UnknownUserAuditType
}

enum UserDomainEnum {
    LDAP
    LOCAL
    SHARED_SSO
    SSO
}

enum UserFieldEnum {
    Domain
    Email
    LastLogin
    Status
}

enum UserStatusEnum {
    ACTIVE
    DEACTIVATED
    UNKNOWN
}

enum VCenterConnectionStatusEnum {
    BADLY_CONFIGURED
    CONNECTED
    CONNECTION_STATUS_UNKNOWN
    DELETING
    DISCONNECTED
    REFRESHING
    REMOTE
}

enum VSphereLiveMountStatusEnum {
    DatastoreMounted
    MigratingDatastore
    Mounting
    PoweredOff
    PoweredOn
    Unknown
    Unmounting
}

enum VSphereMountSortByEnum {
    ClusterName
    MountTime
    NewVmName
    SourceVmName
    Status
}

enum VSphereVirtualDiskSortByEnum {
    FileName
    Size
}

enum VersionStatusTypeEnum {
    Stable
    Unknown
    UpgradeRecommended
}

enum VmPowerStatusEnum {
    poweredOff
    poweredOn
    suspended
}

enum WarningSeverityEnum {
    BLOCKING
    NONE
    NON_BLOCKING
}

enum WeekDayEnum {
    Friday
    Monday
    Saturday
    Sunday
    Thursday
    Tuesday
    Wednesday
}

enum WhitelistModeEnum {
    ALL_USERS
    LOCAL_USERS
}

"Filter Activity series data"
input ActivitySeriesFilterInput {
    cluster: CommonClusterFilterInput
    lastActivityStatus: [ActivityStatusEnum!]
    lastActivityType: [ActivityTypeEnum!]
    lastUpdated_gt: DateTime
    lastUpdated_lt: DateTime
    objectFids: [UUID!]
    objectName: String
    objectType: [ActivityObjectTypeEnum!]
    searchTerm: String
    severity: [ActivitySeverityEnum!]
    startTime_gt: DateTime
    startTime_lt: DateTime
}

input AnalyzerGroupInput {
    analyzers: [AnalyzerInput!] = []
    groupType: AnalyzerGroupTypeEnum = UNDEFINED
    id: String = ""
    name: String = ""
}

input AnalyzerInput {
    analyzerType: AnalyzerTypeEnum = UNDEFINED
    dictionary: [String!] = []
    dictionaryCsv: String = ""
    id: String = ""
    name: String = ""
    regex: String = ""
}

"Filter anomaly result data."
input AnomalyResultFilterInput {
    clusterUuid: [UUID!]
    endTime: DateTime
    isAnomaly: Boolean
    managedId: [String!]
    snappableFid: [UUID!]
    startTime: DateTime
}

input AppBlueprintChildInput {
    bootPriority: Int!
    fid: UUID!
    snappableType: ObjectTypeEnum!
}

input AppBlueprintChildSnappableExportSpec {
    datastoreId: String! = ""
    localRecoverySpec: AppBlueprintChildSnappableLocalRecoverySpec
    vmName: String = ""
}

input AppBlueprintChildSnappableInstantRecoverySpec {
    dataStoreName: String = ""
    localRecoverySpec: AppBlueprintChildSnappableLocalRecoverySpec
    preserveMoid: Boolean = false
    vlan: Int = 0
}

input AppBlueprintChildSnappableLocalRecoverySpec {
    disableNetwork: Boolean = false
    hostId: String = ""
    originalVmId: String! = ""
    recoveredVmName: String = ""
    removeNetworkDevices: Boolean = false
    shouldKeepMacAddresses: Boolean = false
    shouldUnregisterVm: Boolean = false
}

input AppBlueprintChildSnappableMountSpec {
    dataStoreName: String = ""
    localRecoverySpec: AppBlueprintChildSnappableLocalRecoverySpec
    vlan: Int = 0
    vmName: String = ""
}

input AppBlueprintExportSnapshotJobConfig {
    baseConfig: AppBlueprintRestoreSnapshotJobConfigBase
    childrenToRestore: [AppBlueprintChildSnappableExportSpec!]! = []
    newAppName: String = ""
}

input AppBlueprintMountSnapshotJobConfig {
    childrenToRestore: [AppBlueprintChildSnappableMountSpec!]! = []
    jobConfigBase: AppBlueprintRestoreSnapshotJobConfigBase
    newAppName: String = ""
}

input AppBlueprintRecoverySpecCreateReqInputType {
    childRecoverySpecs: [ChildRecoverySpecCreateReqInputType!]!
    planType: PlanNameEnum!
    userData: String
}

input AppBlueprintRestoreSnapshotJobConfigBase {
    "True if the new virtual machine(s) should be power on"
    shouldPowerOn: Boolean = true
}

"O365 list app filter"
input AppFilter {
    field: AppFilterFieldEnum = APP_TYPE
    texts: [String!] = []
}

"O365 list app sort by param"
input AppSortByParam {
    field: AppSortByFieldEnum = APP_ID
    sortOrder: AppSortOrderEnum = ASC
}

input ArchivalSpecInput {
    archivalGroupId: String = ""
    threshold: Int = 0
    thresholdUnit: RetentionUnitEnum = MINUTES
}

input AuditEventFiltersInput {
    eventIds: [DataGovAuditEventTypeEnum!] = []
    snappableFids: [String!] = []
}

input AuditObjectInfo {
    auditObject: String = ""
    auditTargetType: DataGovAuditTargetTypeEnum = UNKNOWN_TARGET
    snappableFid: String = ""
}

input AutomaticAwsTargetMappingCreateRequest {
    awsComputeSettingsId: String
    bucketPrefix: String!
    cloudAccountId: UUID!
    clusterUuidList: [String!]
    isConsolidationEnabled: Boolean!
    kmsMasterKeyId: String
    name: String!
    proxySettings: ProxySettingsInput
    region: AwsRegionEnum!
    rsaKey: String
    storageClass: AwsStorageClassTypeEnum!
}

input AutomaticAwsTargetMappingEditRequest {
    awsComputeSettingsId: String
    cloudAccountId: UUID
    clusterUuidList: [String!]
    id: String!
    isConsolidationEnabled: Boolean
    name: String
    proxySettings: ProxySettingsInput
    storageClass: AwsStorageClassTypeEnum
}

input AutomaticAzureTargetMappingCreateRequest {
    accessKey: String!
    cloudAccountId: UUID!
    clusterUuidList: [String!]
    computeSettings: AzureCloudComputeSettingsInput
    containerNamePrefix: String!
    instanceType: InstanceTypeEnum!
    isConsolidationEnabled: Boolean!
    name: String!
    proxySettings: ProxySettingsInput
    rsaKey: String!
    storageAccountName: String!
}

input AutomaticAzureTargetMappingEditRequest {
    accessKey: String
    cloudAccountId: UUID
    clusterUuidList: [String!]
    computeSettings: AzureCloudComputeSettingsInput
    id: String!
    isConsolidationEnabled: Boolean
    name: String
    proxySettings: ProxySettingsInput
    storageAccountName: String
}

input AwsAccountCreateRequest {
    accessKey: String!
    description: String
    name: String!
    secretKey: String!
}

input AwsAccountEditRequest {
    accessKey: String!
    description: String
    id: String!
    name: String!
    secretKey: String!
}

input AwsCloudAccountAdminInput {
    accountName: String = ""
    "Cloud type (Standard/China) for the cloud account"
    cloudType: AwsCloudTypeEnum = STANDARD
    id: String = ""
    nativeId: String = ""
    seamlessFlowEnabled: Boolean = false
}

input AwsCloudAccountDeleteInitiateInput {
    feature: CloudAccountFeatureEnum!
}

input AwsCloudAccountDeleteProcessInput {
    feature: CloudAccountFeatureEnum!
    featureVersion: [AwsCloudAccountFeatureVersionInput!]
}

input AwsCloudAccountFeatureVersionInput {
    feature: CloudAccountFeatureEnum!
    version: Long!
}

input AwsCloudAccountGetAccountInput {
    features: [CloudAccountFeatureEnum!]!
}

input AwsCloudAccountInitiateInput {
    action: CloudAccountActionEnum!
    "Admin account, required for bulk upload."
    awsAdminAccount: AwsCloudAccountInput
    awsChildAccounts: [AwsCloudAccountInput!]!
    features: [CloudAccountFeatureEnum!]!
}

input AwsCloudAccountInput {
    accountName: String = ""
    "Cloud type (Standard/China) for the cloud account"
    cloudType: AwsCloudTypeEnum = STANDARD
    id: String = ""
    nativeId: String = ""
    seamlessFlowEnabled: Boolean = false
}

input AwsCloudAccountProcessInput {
    action: CloudAccountActionEnum!
    "Admin account, required for bulk upload."
    awsAdminAccount: AwsCloudAccountInput
    awsChildAccounts: [AwsCloudAccountInput!]!
    awsRegions: [AwsCloudAccountRegionEnum!]
    externalId: String!
    featureVersion: [AwsCloudAccountFeatureVersionInput!]
    features: [CloudAccountFeatureEnum!]!
    stackName: String
    stackSetName: String
}

input AwsCloudAccountSaveInput {
    action: CloudAccountActionEnum!
    awsRegions: [AwsCloudAccountRegionEnum!]
    feature: CloudAccountFeatureEnum!
    roleArn: String
    stackArn: String
}

input AwsCloudAccountValidateInput {
    awsAdminAccount: AwsCloudAccountAdminInput
    awsChildAccounts: [AwsCloudAccountInput!]!
    features: [CloudAccountFeatureEnum!]!
}

input AwsCloudAccountsInput {
    "Admin account id to filter."
    awsAdminAccountFilter: UUID
    "Search in native id, account name, and role arn."
    columnSearchFilter: String
    feature: CloudAccountFeatureEnum!
    "List for status."
    statusFilters: [CloudAccountStatusEnum!]!
}

input AwsCloudComputeSettingFilterInput {
    field: AwsCloudComputeSettingFilterFieldEnum = NAME
    text: String = ""
}

input AwsComputeSettingsCreateRequest {
    cloudAccountId: String = ""
    clusterInterfaceCidrs: [ClusterInfCidrsInput!] = []
    isSecurityGroupPolarisManaged: Boolean = false
    name: String = ""
    region: AwsRegionEnum = UNKNOWN_AWS_REGION
    securityGroupId: String = ""
    subnetId: String = ""
    vpcId: String = ""
}

input AwsComputeSettingsEditRequest {
    id: String = ""
    name: String = ""
    securityGroupId: String = ""
    subnetId: String = ""
    vpcId: String = ""
}

"Aws exocompute config to add."
input AwsExocomputeAddConfigInputType {
    "AWS ID of cluster control plane security group. Not required if isPolarisManaged is true"
    clusterSecurityGroupId: String = ""
    "True, if security groups are to be managed to be polaris. False, if security groups are managed by user."
    isPolarisManaged: Boolean!
    "AWS ID of worker node security group. Not required if isPolarisManaged is true"
    nodeSecurityGroupId: String = ""
    "The region for which the config is specified"
    region: AwsCloudAccountRegionEnum!
    "List of exactly 2 subnets."
    subnets: [AwsExocomputeSubnetInputType!]!
    "AWS ID of the VPC"
    vpcId: String!
}

"Aws exocompute subnet input"
input AwsExocomputeSubnetInputType {
    "Availability zone of the subnet"
    availabilityZone: String!
    "AWS ID of subnet"
    subnetId: String!
}

"Filter to return AWS objects which have account rubrik ID in the given list of account rubrik IDs."
input AwsNativeAccountFilter {
    accountIds: [String!]!
}

"Filters for list of AWS accounts."
input AwsNativeAccountFilters {
    effectiveSlaFilter: EffectiveSlaFilter
    nameSubstringFilter: NameSubstringFilter
}

"Filter to return AWS EBS volumes which are attached to one of the EC2 instances in the given list of EC2 instance IDs."
input AwsNativeAttachedInstanceFilter {
    ec2InstanceIds: [String!]!
}

"Filter to return AWS EBS volumes which have file recovery enabled."
input AwsNativeEbsVolumeFileRecoveryStatusFilter {
    statuses: [AwsNativeFileRecoveryStatusEnum!]!
}

"Filters for list of AWS EBS volumes."
input AwsNativeEbsVolumeFilters {
    accountFilter: AwsNativeAccountFilter
    attachedInstanceFilter: AwsNativeAttachedInstanceFilter
    effectiveSlaFilter: EffectiveSlaFilter
    fileRecoveryStatusFilter: AwsNativeEbsVolumeFileRecoveryStatusFilter
    nameOrIdSubstringFilter: AwsNativeEbsVolumeNameOrIdSubstringFilter
    regionFilter: AwsNativeRegionFilter
    relicFilter: RelicFilter
    tagFilter: AwsNativeTagFilter
    typeFilter: AwsNativeEbsVolumeTypeFilter
}

"Filter to return AWS EBS volumes with a given substring in their name or instance ID."
input AwsNativeEbsVolumeNameOrIdSubstringFilter {
    nameOrIdSubstring: String!
}

"Filter to return AWS EBS volumes which have volume type in the given list of volume types."
input AwsNativeEbsVolumeTypeFilter {
    ebsVolumeTypes: [AwsNativeEbsVolumeTypeEnum!]!
}

"Filter to return AWS EC2 instances which have file recovery enabled."
input AwsNativeEc2InstanceFileRecoveryStatusFilter {
    statuses: [AwsNativeFileRecoveryStatusEnum!]!
}

"Filters for list of AWS EC2 instances."
input AwsNativeEc2InstanceFilters {
    accountFilter: AwsNativeAccountFilter
    effectiveSlaFilter: EffectiveSlaFilter
    fileRecoveryStatusFilter: AwsNativeEc2InstanceFileRecoveryStatusFilter
    nameOrIdSubstringFilter: AwsNativeEc2InstanceNameOrIdSubstringFilter
    regionFilter: AwsNativeRegionFilter
    relicFilter: RelicFilter
    tagFilter: AwsNativeTagFilter
    typeFilter: AwsNativeEc2InstanceTypeFilter
    vpcFilter: AwsNativeVPCFilter
}

"Filter to return AWS EC2 instances with a given substring in their name or instance ID."
input AwsNativeEc2InstanceNameOrIdSubstringFilter {
    nameOrIdSubstring: String!
}

"Filter to return AWS EC2 instances which have instance type in the given list of instance types."
input AwsNativeEc2InstanceTypeFilter {
    ec2InstanceTypes: [AwsNativeEc2InstanceTypeEnum!]!
}

input AwsNativeProtectionAccountAddRequest {
    "12 digit aws cloud account Id"
    accountId: String!
    "Name or account alias to identify aws account"
    name: String!
    "regions to be enabled for native protection"
    regions: [String!]!
}

"Filter to return AWS RDS instances which have database engine in the given list of database engines."
input AwsNativeRdsDbEngineFilter {
    dbEngines: [AwsNativeRdsDbEngineEnum!]!
}

"Filter to return AWS RDS instances which have database instance class in the given list of database instance classes."
input AwsNativeRdsDbInstanceClassFilter {
    dbInstanceClasses: [AwsNativeRdsDbInstanceClassEnum!]!
}

"Filters for list of AWS RDS instances."
input AwsNativeRdsInstanceFilters {
    accountFilter: AwsNativeAccountFilter
    dbEngineFilter: AwsNativeRdsDbEngineFilter
    dbInstanceClassFilter: AwsNativeRdsDbInstanceClassFilter
    effectiveSlaFilter: EffectiveSlaFilter
    nameSubstringFilter: NameSubstringFilter
    regionFilter: AwsNativeRegionFilter
    relicFilter: RelicFilter
    tagFilter: AwsNativeTagFilter
    vpcFilter: AwsNativeVPCFilter
}

"Filter to return AWS objects which have region in the given list of regions."
input AwsNativeRegionFilter {
    regions: [AwsNativeRegionEnum!]!
}

"Filter to return AWS objects which have at least one tag in the given list of tags."
input AwsNativeTagFilter {
    tagFilterParams: [TagFilterParams!]!
}

"Filter to return AWS EC2 instances which have VPC ID in the given list of VPC IDs."
input AwsNativeVPCFilter {
    vpcIDs: [String!]!
}

input AwsRdsConfigInput {
    logRetention: SlaDurationInput
}

input AwsTargetCreateRequest {
    awsComputeSettingsId: String
    bucketName: String!
    cloudAccountId: UUID!
    clusterUuid: String!
    isConsolidationEnabled: Boolean!
    kmsMasterKeyId: String
    name: String!
    proxySettings: ProxySettingsInput
    region: AwsRegionEnum!
    rsaKey: String
    storageClass: AwsStorageClassTypeEnum!
}

input AwsTargetEditRequest {
    awsComputeSettingsId: String
    cloudAccountId: UUID
    id: String!
    isConsolidationEnabled: Boolean
    name: String
    proxySettings: ProxySettingsInput
    storageClass: AwsStorageClassTypeEnum
}

input AwsVMNicSpecInputType {
    awsSecurityGroupId: String = ""
    awsSubnetId: String = ""
    ipv4Address: String = ""
    key: Int = 0
    securityGroupId: String = ""
    subnetId: String = ""
}

input AwsVMRecoverySpecInputType {
    availabilityZone: String = ""
    dedicatedHostId: String = ""
    hostAffinity: String = ""
    instanceTypeId: Int! = 0
    instanceTypeName: String = ""
    keyName: String = ""
    nics: [AwsVMNicSpecInputType!] = []
    placementGroup: String = ""
    tenancy: AwsInstanceTenancyEnum = DEDICATED
    userData: String = ""
    version: Long = 0
    volumes: [AwsVMVolumeSpecInputType!] = []
}

input AwsVMVolumeSpecInputType {
    iops: Int = 0
    "key value defined in VMWare VM"
    key: Int = 0
    sizeGbs: Int = 0
    volumeTypeId: Int = 0
}

input AzureAccountCreateRequest {
    description: String
    name: String!
    subscriptionId: String!
}

input AzureAccountEditRequest {
    description: String
    id: String!
    name: String
    subscriptionId: String
}

input AzureCloudAccountSubscriptionInput {
    id: String = ""
    name: String = ""
}

input AzureCloudComputeSettingsInput {
    appId: String = ""
    appSecretKey: String = ""
    computeProxySettings: ProxySettingsInput
    generalPurposeStorageContainer: String = ""
    generalPurposeStorageName: String = ""
    region: AzureRegionEnum = UNKNOWN_AZURE_REGION
    resourceGroup: String = ""
    securityGroupId: String = ""
    subnetId: String = ""
    virtualNetworkId: String = ""
}

"Filter to return Azure disks which are attached to one of the virtual machines in the given list of virtual machine IDs."
input AzureNativeAttachedVMFilter {
    virtualMachineIds: [String!]!
}

"Filters for list of Azure disks."
input AzureNativeDiskFilters {
    attachedVMFilter: AzureNativeAttachedVMFilter
    diskTypeFilter: AzureNativeDiskTypeFilter
    effectiveSlaFilter: EffectiveSlaFilter
    nameSubstringFilter: NameSubstringFilter
    regionFilter: AzureNativeRegionFilter
    relicFilter: RelicFilter
    resourceGroupFilter: AzureNativeDiskResourceGroupFilter
    subscriptionFilter: AzureNativeDiskSubscriptionFilter
    tagFilter: AzureNativeTagFilter
}

"Filter to return Azure disks which have resource group name in the given list of resource group names."
input AzureNativeDiskResourceGroupFilter {
    resourceGroupNames: [String!]!
}

"Filter to return Azure disks which have rubrik subscription ID in the given list of rubrik subscription IDs."
input AzureNativeDiskSubscriptionFilter {
    subscriptionIds: [String!]!
}

"Filter to return Azure virtual machine which have VM size in the given list of VM sizes."
input AzureNativeDiskTypeFilter {
    diskTypes: [String!]!
}

"Filter to return Azure resource groups which have rubrik subscription ID in the given list of rubrik subscription IDs."
input AzureNativeRGSubscriptionFilter {
    subscriptionIds: [String!]!
}

"Filter to return Azure virtual machine which have region in the given list of regions."
input AzureNativeRegionFilter {
    regions: [AzureNativeRegionEnum!]!
}

"Filters for list of Azure resource groups."
input AzureNativeResourceGroupFilters {
    effectiveSlaFilter: EffectiveSlaFilter
    nameSubstringFilter: NameSubstringFilter
    regionFilter: AzureNativeRegionFilter
    subscriptionFilter: AzureNativeRGSubscriptionFilter
}

"Filters for list of Azure subscriptions."
input AzureNativeSubscriptionFilters {
    effectiveSlaFilter: EffectiveSlaFilter
    nameSubstringFilter: NameSubstringFilter
}

"Filter to return Azure objects which have at least one tag in the given list of tags."
input AzureNativeTagFilter {
    tagFilterParams: [TagFilterParams!]!
}

"Filter to return Azure virtual machines which have resource group name in the given list of resource group names."
input AzureNativeVMResourceGroupFilter {
    resourceGroupNames: [String!]!
}

"Filter to return Azure virtual machine which have VM size in the given list of VM sizes."
input AzureNativeVMSizeFilter {
    vmSizes: [String!]!
}

"Filter to return Azure virtual machines which have rubrik subscription ID in the given list of rubrik subscription IDs."
input AzureNativeVMSubscriptionFilter {
    subscriptionIds: [String!]!
}

"Filters for list of Azure virtual machines."
input AzureNativeVirtualMachineFilters {
    effectiveSlaFilter: EffectiveSlaFilter
    nameSubstringFilter: NameSubstringFilter
    regionFilter: AzureNativeRegionFilter
    relicFilter: RelicFilter
    resourceGroupFilter: AzureNativeVMResourceGroupFilter
    subscriptionFilter: AzureNativeVMSubscriptionFilter
    tagFilter: AzureNativeTagFilter
    vmSizeFilter: AzureNativeVMSizeFilter
    vnetFilter: AzureNativeVnetFilter
}

"Filter to return Azure virtual machine which have Vnet name in the given list of Vnet names."
input AzureNativeVnetFilter {
    vnetNames: [String!]!
}

"Exocompute config"
input AzureO365ExocomputeConfig {
    existingComputeConfig: ExistingComputeConfig
    existingGroupConfig: GroupConfig
    existingStorageAccountConfig: ExistingStorageAccountConfig
    newComputeConfig: NewComputeConfig
    newGroupConfig: GroupConfig
    newStorageAccountConfig: NewStorageAccountConfig
    regionName: String!
}

input AzureSubscriptionInput {
    name: String!
    nativeId: String!
}

input AzureTargetCreateRequest {
    accessKey: String!
    cloudAccountId: UUID!
    clusterUuid: UUID!
    computeSettings: AzureCloudComputeSettingsInput
    containerName: String!
    instanceType: InstanceTypeEnum!
    isConsolidationEnabled: Boolean!
    name: String!
    proxySettings: ProxySettingsInput
    rsaKey: String!
    storageAccountName: String!
}

input AzureTargetEditRequest {
    accessKey: String
    cloudAccountId: UUID
    computeSettings: AzureCloudComputeSettingsInput
    id: UUID!
    isConsolidationEnabled: Boolean
    name: String
    proxySettings: ProxySettingsInput
    storageAccountName: String
}

"Specifies backup window params"
input BackupWindowInput {
    durationInHours: Int = 0
    startTimeAttributes: StartTimeAttributesInput
}

input BaseOnDemandSnapshotConfig {
    slaFid: String = ""
}

"""

Supported in v5.0+
"""
input BaseOnDemandSnapshotConfigInput {
    """

    Supported in v5.0+
    """
    slaId: String
}

input BasicSnapshotScheduleInput {
    frequency: Int = 0
    retention: Int = 0
    retentionUnit: RetentionUnitEnum = MINUTES
}

"""

Supported in v5.0+
"""
input BatchMountSnapshotJobConfigInput {
    """

    Required. Supported in v5.0+
    v5.0: Array of virtual machine IDs with snapshots to be live mounted.
    v5.1+: Array of vm_ids to live mount a snapshot from
    """
    snapshots: [MountSnapshotJobConfigForBatchV1Input!] = []
}

input BatchVmwareVmRecoverableRangesRequestInput {
    "Query filter - only ranges after this time will be included. The date-time string should be in ISO8601 format, such as `2018-01-01T01:23:45.678Z`."
    afterTime: DateTime
    "Query filter - only ranges before this time will be included. The date-time string should be in ISO8601 format, such as `2018-01-01T01:23:45.678Z`."
    beforeTime: DateTime
    "The ID of each CDP-enabled virtual machine for which recoverable ranges are being retrieved."
    vmIds: [String!] = []
}

input BidirectionalReplicationSpecInput {
    replicationSpec1: UnidirectionalReplicationSpecInput
    replicationSpec2: UnidirectionalReplicationSpecInput
}

input BlueprintFailoverReportGeneratorJobInfo {
    "The IDs for the failover records in the report"
    failoverIds: [String!]!
}

input BrowseDirectoryFiltersInput {
    analyzerGroupIds: [String!] = []
    whitelistEnabled: Boolean = false
}

"Email address input for organizer and/or attendee"
input CalendarEmailAddressFilter {
    emailAddress: String = ""
    filterType: CalendarEmailAddressFilterTypeEnum = ORGANIZER
}

"Parameters for calendar event search"
input CalendarSearchFilter {
    emailAddresses: [CalendarEmailAddressFilter!] = []
    searchKeywordFilter: CalendarSearchKeywordFilter
    searchObjectFilter: CalendarSearchObjectFilter
    timerange: TimeRangeFilter
}

"Calendar search keyword and type"
input CalendarSearchKeywordFilter {
    keywordType: CalendarSearchKeywordTypeEnum = NAME
    searchKeyword: String = ""
}

"Calendar search object type"
input CalendarSearchObjectFilter {
    searchObjectType: CalendarSearchObjectTypeEnum = CALENDAR
}

input CdmSnapshotFilterInput {
    clusterUuid: [UUID!]
    isOnDemandSnapshot: Boolean
    snappableId: [String!]
    snapshotId: [UUID!]
    timeRange: TimeRangeInput
}

"Filters for the cluster list"
input CdmUpgradeInfoFilterInput {
    "Location of cluster"
    clusterLocation: [String!]
    connectionState: [ClusterStatus!]
    "Cluster software version greater than or equal to"
    downloadedVersion: [String!]
    "Cluster UUIDs"
    id: [UUID!]
    installedVersion: [String!]
    "Cluster software version greater than or equal to"
    minSoftwareVersion: String
    "Cluster names"
    name: [String!]
    "Prechecks status of cluster"
    prechecksStatus: [PrechecksStatusTypeEnum!]
    "Product type of Rubrik cluster"
    productType: [ClusterProductEnum!]
    "Cluster registration time greater than"
    registrationTime_gt: DateTime
    "Cluster registration time less than"
    registrationTime_lt: DateTime
    "Cluster types"
    type: [ClusterTypeEnum!]
    "Cluster upgrade job status"
    upgradeJobStatus: [ClusterJobStatusTypeEnum!]
    upgradeScheduled: Boolean
    versionStatus: [VersionStatusTypeEnum!]
}

input ChartConfigInput {
    groupBy: [String!]!
    type: ChartType!
}

input ChildRecoverySpecCreateReqInputType {
    recoverySpec: ChildRecoverySpecInputType!
    snappableId: String!
}

input ChildRecoverySpecInputType {
    awsSpec: AwsVMRecoverySpecInputType
    vSphereSpec: VSphereVMRecoverySpecInputType
}

input ClassificationPolicyInput {
    analyzerIds: [String!] = []
    colorEnum: ClassificationPolicyColor = UNKNOWN
    description: String = ""
    id: String = ""
    mode: ClassificationPolicyMode = DISCOVERY
    name: String = ""
    updateAnalyzerIds: Boolean = false
    updateDescription: Boolean = false
    updateMode: Boolean = false
    updateName: Boolean = false
}

input CleanupFailoverJobInfo {
    appBlueprintFID: UUID!
    comments: String
}

input CloudAccountFilterInput {
    field: CloudAccountFilterFieldEnum = NAME
    text: String = ""
}

"Feature for which required permissions have to be checked."
input CloudNativeFeatureForPermissionsCheck {
    azureFeature: AzureFeatureForPermissionCheck
}

"DataType representing filters on cloud native tag or label rules"
input CloudNativeFilter {
    field: CloudNativeTagRuleFilterFieldsEnum = SLA_DOMAIN
    texts: [String!] = []
}

"DataType representing cloud native ids"
input CloudNativeIDs {
    awsNativeAccountIds: [String!]
    azureNativeSubscriptionIds: [String!]
    gcpNativeProjectIds: [String!]
}

"Filters for the cluster disk list"
input ClusterDiskFilterInput {
    status: ClusterDiskStatus
    type: ClusterDiskType
}

"Filters for the cluster list"
input ClusterFilterInput {
    "Exclude clusters that do not have any nodes connected"
    excludeEmptyCluster: Boolean
    "Cluster UUIDs"
    id: [UUID!]
    "Cluster software version greater than or equal to"
    minSoftwareVersion: String
    "Cluster names"
    name: [String!]
    "Object types of snappables protected by the cluster"
    objectType: [ObjectTypeEnum!]
    "Cluster registration time greater than"
    registrationTime_gt: DateTime
    "Cluster registration time less than"
    registrationTime_lt: DateTime
    "Cluster types"
    type: [ClusterTypeEnum!]
}

input ClusterInfCidrsInput {
    clusterId: String = ""
    clusterName: String = ""
    interfaceCidr: [InterfaceCidrInput!] = []
}

"GeoLocation of the cluster"
input ClusterLocationEdit {
    address: String!
    latitude: Float!
    longitude: Float!
}

"Filter cluster data."
input CommonClusterFilterInput {
    id: [UUID!]
    type: [ClusterTypeEnum!]
}

input ContextFilterInputField {
    field: String!
    text: String!
}

input CustomReportCreate {
    "Chart configs for the report."
    charts: [ReportChartCreate!]
    "Filters for the report data."
    filters: CustomReportFiltersConfig!
    focus: ReportFocusEnum!
    "True if report should be hidden from gallery view."
    isHidden: Boolean = false
    "True if report is auto-generated and not allowed to be edited."
    isReadOnly: Boolean = false
    "Name of the report."
    name: String!
    "Table configs for the report."
    tables: [ReportTableCreate!]
}

"Filter custom reports data."
input CustomReportFilterInput {
    creationTime_gt: DateTime
    creationTime_lt: DateTime
    focus: ReportFocusEnum
    isHidden: Boolean
    isReadOnly: Boolean
    searchTerm: String
}

input CustomReportFiltersConfig {
    activityObjectType: [ActivityObjectTypeEnum!]
    "List of cluster id to filter on."
    clusterId: [UUID!]
    clusterLocation: [String!]
    "List of cluster types to filter on."
    clusterType: [ClusterTypeEnum!]
    complianceStatus: [ComplianceStatusEnum!]
    failoverStatus: [FailoverStatusEnum!]
    failoverType: FailoverTypeEnum
    "Whether the snapshot is anomalous or not"
    isAnomaly: Boolean
    "List of activity types to filter on."
    lastActivityStatus: [ActivityStatusEnum!]
    "List of activity types to filter on."
    lastActivityType: [ActivityTypeEnum!]
    "List of managed ids to filter data on."
    managedId: [String!]
    "List of snappable types to filter on."
    objectType: [ObjectTypeEnum!]
    "List of policy IDs to filter on."
    policyId: [String!]
    protectionStatus: [ProtectionStatusEnum!]
    replicationSource: [String!]
    searchTerm: String
    "List of sla domain ids to filter on."
    slaDomainId: [String!]
    sonarObjectTypes: [HierarchyObjectTypeEnum!]
    source: [String!]
    targetSite: [String!]
    taskCategory: [String!]
    taskStatus: [String!]
    taskType: [String!]
    "Start and end time range to filter data on."
    timeRange: GenericTimeRangeInput
    "List of object types to filter on for Audits."
    userAuditObjectType: [UserAuditObjectTypeEnum!]
    "List of user audit status to filter on."
    userAuditStatus: [UserAuditStatusEnum!]
    "List of user audit types to filter on."
    userAuditType: [UserAuditTypeEnum!]
}

input DailySnapshotScheduleInput {
    basicSchedule: BasicSnapshotScheduleInput
}

input DayOfWeekOptInput {
    day: DayOfWeekEnum = MONDAY
}

input DiskIdToIsExcluded {
    diskId: UUID!
    isExcluded: Boolean!
}

"Filters for cdm upgrades page for pdf generation"
input DownloadCdmUpgradesPdfFiltersInput {
    clusterLocations: [String!] = []
    clusterNames: [String!] = []
    clusterTypes: [String!] = []
    clusterUuids: [String!] = []
    downloadedVersions: [String!] = []
    installedVersions: [String!] = []
    prechecksStatus: [String!] = []
    upgradeJobStatus: [String!] = []
    versionStatus: [String!] = []
}

input DownloadResultsCsvFiltersInput {
    analyzerGroupIds: [String!] = []
    browseDirectorySnappablePath: SnappablePathInput
    fileType: FileCountTypeEnum!
    listFileResultsSearchText: String = ""
    listFileResultsSnappablePaths: [SnappablePathInput!] = []
    listFileResultsSnappableTypes: [String!] = []
    whitelistEnabled: Boolean = false
}

"Filter to return objects whose effective SLA ID is one of the given SLA IDs"
input EffectiveSlaFilter {
    effectiveSlaIds: [String!]!
}

"Email address and to/from/both"
input EmailAddressFilter {
    emailAddress: String = ""
    emailAddressType: EmailAddressFilterTypeEnum = TO
}

"Event digest config to specify events criteria."
input EventDigestConfig {
    activitySeverity: [ActivitySeverityEnum!]
    activityStatus: [ActivityStatusEnum!]
    "Activity type to filter for emails. Valid types are Storage, Classification, LegalHold, HypervScvmm, Hdfs, VolumeGroup, Instantiate, HypervServer, Configuration, Upgrade, CloudNativeVm, StorageArray, Connection, AuthDomain, UnknownEventType, CloudNativeVirtualMachine, Discovery, Replication, Maintenance, Support, Fileset, System, Failover, StormResource, Diagnostic, Vcd, Anomaly, Archive, CloudNativeSource, HostEvent, AwsEvent, Backup, Sync, Hardware, TestFailover, Recovery, EmbeddedEvent, NutanixCluster, VCenter, Index, and OTHER_FILTER_ITEM"
    activityType: [String!]
    clusters: [String!]
    objectType: [ActivityObjectTypeEnum!]
}

"existing compute config"
input ExistingComputeConfig {
    subnetId: String = ""
    vnetId: String = ""
}

"existing storage account config"
input ExistingStorageAccountConfig {
    id: String = ""
}

"Config for O365 mailbox export"
input ExportO365MailboxInput {
    exportConfigs: [RestoreObjectConfig!]!
    fromMailboxUUID: UUID!
    snapshotUUID: UUID
    toMailboxUUID: UUID!
}

"""

Supported in v5.0+
"""
input ExportPathPairInput {
    """

    Supported in v5.0+
    Destination path of export files.
    """
    dstPath: String = ""
    """

    Supported in v5.0+
    Original file path.
    """
    srcPath: String = ""
}

input FailoverAppBlueprintJobInfo {
    "The ID of the Blueprint to be failed over"
    appBlueprintFID: UUID!
    childSnappableFailoverInfos: [SnappableFailoverInfoType!]
    "True if newly created Blueprint should be assigned to a cloned SLA"
    cloneSLA: Boolean = true
    clusterUUID: UUID
    "Whether deprecate the primary Blueprint after failover"
    deprecatePrimaryApp: Boolean = true
    failoverFailureAction: String
    "The type of the failover job, FAILOVER or TEST_FAILOVER"
    failoverType: String!
    newSlaID: String
    recoverySpec: AppBlueprintRecoverySpecCreateReqInputType
    "The ID of the snapshot to be used for the failover"
    snapshotFID: UUID
    "Whether clean the provisioned resources when error occurs"
    undoOnFailure: Boolean
    zeroDataLoss: Boolean
}

"Filter appflows failover jobs"
input FailoverFilterInput {
    failoverStatus: [FailoverStatusEnum!]
    failoverType: FailoverTypeEnum
    source: [String!]
    targetSite: [String!]
    time_gt: DateTime
    time_lt: DateTime
}

"A contextual value affecting the evaluation of a feature flag"
input FeatureFlagContextField {
    "Key corresponding to this field"
    key: String!
    "The value of this field. Can be any GraphQL scalar."
    value: AnyScalar!
}

"Struct representing the Onedrive file to be restored"
input FileInfo {
    FileID: String!
    FileSnapshotsToRestore: [FileSnapshotInfo!]!
}

input FileResultSortInput {
    analyzerGroupId: String = ""
    sortBy: FileResultSortByEnum = HITS
    sortOrder: DataGovSortOrderEnum = ASC
}

"Struct representing the Onedrive file snapshot to be restored"
input FileSnapshotInfo {
    FileSize: Long!
    SnapshotID: UUID!
    SnapshotNum: Int!
}

"""

Supported in v5.0+
"""
input FilesetArraySpecInput {
    """

    Supported in v5.0+
    ID assigned to a proxy host for array-enabled backups. This property is only required for array-enabled backups.
    """
    proxyHostId: String
}

"""

Supported in v5.0+
"""
input FilesetCreateInput {
    """

    Supported in v5.0+
    """
    arraySpec: FilesetArraySpecInput
    """

    Supported in v5.1+
    A Boolean value that determines whether to recognize and dedupe hardlinks in a fileset. When 'true,' performs a hardlink deduplication. When 'false,' performs a normal backup that treats hardlinks as normal files. If not specified, this defaults to false.
    """
    enableHardlinkSupport: Boolean
    """

    Supported in v5.1+
    A Boolean value that determines whether to resolve symlink in a fileset. When 'true,' performs a symlink resolution. When 'false,' performs no symlink resolution. If not specified, this defaults to false.
    """
    enableSymlinkResolution: Boolean
    """

    Supported in v5.2+
    ID of the failover cluster app.
    """
    failoverClusterAppId: String
    """

    Supported in v5.0+
    """
    hostId: String
    """

    Supported in v5.0+
    v5.0: A Boolean value that determines whether to take a direct archive backup. When 'true,' performs a direct archive backup. When 'false,' performs a normal backup.
    v5.1+: A Boolean value that determines whether to take a direct archive backup. When 'true,' performs a direct archive backup. When 'false,' performs a normal backup. If not specified, this defaults to false.
    """
    isPassthrough: Boolean
    """

    Supported in v5.0+
    """
    shareId: String
    """

    Supported in v5.0+
    """
    templateId: String = ""
}

"""

Supported in v5.0+
"""
input FilesetDownloadFilesJobConfigInput {
    """

    Supported in v5.2+
    An optional argument containing a Boolean parameter to depict if the download is being triggered for Legal Hold use case.
    """
    legalHoldDownloadConfig: LegalHoldDownloadConfigInput
    """

    Supported in v5.0+
    An array containing the full source path of each file and folder that is part of the download job. The array must contain at least one path.
    """
    sourceDirs: [String!] = []
}

"""

Supported in v5.0+
"""
input FilesetExportFilesJobConfigInput {
    """

    Supported in v5.0+
    Pairs of source path and destination path.
    """
    exportPathPairs: [FilesetExportPathPairInput!] = []
    """

    Supported in v5.0+
    Host ID
    """
    hostId: String = ""
    """

    Supported in v5.0+
    Optional Boolean value that determines whether or not to ignore errors during an export. By default, this value is set to False. Set this value to True to ignore errors.
    """
    ignoreErrors: Boolean
    """

    Supported in v5.0+
    Network share ID
    """
    shareId: String
}

"""

Supported in v5.0+
"""
input FilesetExportPathPairInput {
    exportPathPair: ExportPathPairInput
}

"""

Supported in v5.0+
"""
input FilesetOptionsInput {
    """

    Supported in v5.0+
    Include or exclude hidden folders inside locally-mounted remote file systems from backups.
    """
    allowBackupHiddenFoldersInNetworkMounts: Boolean
    """

    Supported in v5.0+
    Include or exclude locally-mounted remote file systems from backups.
    """
    allowBackupNetworkMounts: Boolean
    """

    Supported in v5.0+
    Use VSS during Windows backups.
    """
    useWindowsVss: Boolean
}

"""

Supported in v5.0+
"""
input FilesetRestoreFilesJobConfigInput {
    """

    Supported in v5.0+
    Optional field to determine if we should ignore single error during restore. Default value is false
    """
    ignoreErrors: Boolean
    """

    Supported in v5.0+
    Absolute file path and restore path if not restored back to itself
    """
    restoreConfig: [FilesetRestorePathPairInput!] = []
}

"""

Supported in v5.0+
"""
input FilesetRestorePathPairInput {
    restorePathPair: RestorePathPairInput
}

"""

Supported in v5.0+
"""
input FilesetTemplateCreateInput {
    """

    Supported in v5.0+
    Action taken if script fails. Options are "abort", "continue"
  """
    backupScriptErrorHandling: String
    """

    Supported in v5.0+
    Number of seconds after which the script is killed if it has not completed execution
    """
    backupScriptTimeout: Long
    """

    Supported in v5.0+
    """
    exceptions: [String!] = []
    """

    Supported in v5.0+
    """
    excludes: [String!] = []
    filesetOptions: FilesetOptionsInput
    """

    Required. Supported in v5.0+
    """
    includes: [String!] = []
    """

    Supported in v5.0+
    Boolean value that determines whether the fileset is array-enabled. Set to true to indicate that the fileset is array-enabled. Set to false to indicate that the fileset is not array-enabled. When a fileset is array-enabled, the includes must be top-level LVM logical volume mount points.
    """
    isArrayEnabled: Boolean
    """

    Required. Supported in v5.0+
    """
    name: String = ""
    """

    Supported in v5.0+
    Operating system type of filesets created by template.
    """
    operatingSystemType: FilesetTemplateCreateOperatingSystemTypeEnum = FILESET_TEMPLATE_CREATE_OPERATING_SYSTEM_TYPE_EMPTY_VALUE
    """

    Supported in v5.0+
    Script to run after backup of this fileset ends
    """
    postBackupScript: String
    """

    Supported in v5.0+
    Script to run before backup of this fileset starts
    """
    preBackupScript: String
    """

    Supported in v5.0+
    """
    shareType: FilesetTemplateCreateShareTypeEnum = FILESET_TEMPLATE_CREATE_SHARE_TYPE_EMPTY_VALUE
}

"""

Supported in v5.0+
"""
input FilesetTemplatePatchInput {
    """

    Supported in v5.0+
    Action taken if script fails. Options are "abort", "continue"
  """
    backupScriptErrorHandling: String
    """

    Supported in v5.0+
    Number of seconds after which the script is killed if it has not completed execution
    """
    backupScriptTimeout: Long
    """

    Supported in v5.0+
    """
    exceptions: [String!] = []
    """

    Supported in v5.0+
    """
    excludes: [String!] = []
    filesetOptions: FilesetOptionsInput
    """

    Required. Supported in v5.0+
    """
    id: String = ""
    """

    Supported in v5.0+
    """
    includes: [String!] = []
    """

    Supported in v5.0+
    """
    name: String
    """

    Supported in v5.0+
    Operating system type of filesets created by template
    """
    operatingSystemType: FilesetTemplatePatchOperatingSystemTypeEnum = FILESET_TEMPLATE_PATCH_OPERATING_SYSTEM_TYPE_EMPTY_VALUE
    """

    Supported in v5.0+
    Script to run after backup of this Fileset ends
    """
    postBackupScript: String
    """

    Supported in v5.0+
    Script to run before backup of this Fileset starts
    """
    preBackupScript: String
    """

    Supported in v5.0+
    """
    shareType: FilesetTemplatePatchShareTypeEnum = FILESET_TEMPLATE_PATCH_SHARE_TYPE_EMPTY_VALUE
}

"Filter"
input Filter {
    awsNativeProtectionFeatureNames: [AwsNativeProtectionFeatureEnum!] = []
    field: HierarchyFilterField = IS_ARCHIVED
    isNegative: Boolean = false
    objectTypeFilterParams: [ManagedObjectType!] = []
    tagFilterParams: [TagFilterParams!] = []
    texts: [String!] = []
}

"Struct representing the Onedrive folder to be restored"
input FolderInfo {
    FolderID: String!
    FolderSize: Long!
    SnapshotID: UUID!
    SnapshotNum: Int!
}

"Filters for list of GCP disks."
input GcpNativeDiskFilters {
    diskTypeFilter: GcpNativeDiskTypeFilter
    effectiveSlaFilter: EffectiveSlaFilter
    labelFilter: GcpNativeLabelFilter
    locationFilter: GcpNativeDiskLocationFilter
    nameOrIDSubstringFilter: GcpNativeDiskNameOrIDSubstringFilter
    projectFilter: GcpNativeDiskProjectFilter
    relicFilter: RelicFilter
}

"Filter to return GCP disks which have location in the given list of locations. Location can be a zone or a region."
input GcpNativeDiskLocationFilter {
    locations: [String!]!
}

"Filter to return GCP disks with a given substring in their name or ID."
input GcpNativeDiskNameOrIDSubstringFilter {
    nameOrIDSubstring: String!
}

"Filter to return GCP disks which have project rubrik ID in the given list of project rubrik IDs."
input GcpNativeDiskProjectFilter {
    projectIds: [String!]!
}

"Filter to return GCP disks which have disk type in the given list of disk types."
input GcpNativeDiskTypeFilter {
    diskTypes: [String!]!
}

"Filters for list of GCP GCE instances."
input GcpNativeGceInstanceFilters {
    effectiveSlaFilter: EffectiveSlaFilter
    labelFilter: GcpNativeLabelFilter
    machineTypeFilter: GcpNativeMachineTypeFilter
    nameOrIDSubstringFilter: GcpNativeInstanceNameOrIDSubstringFilter
    networkFilter: GcpNativeNetworkFilter
    projectFilter: GcpNativeProjectFilter
    regionFilter: GcpNativeRegionFilter
    relicFilter: RelicFilter
}

"Filter to return GCP GCE instances with a given substring in their name or ID."
input GcpNativeInstanceNameOrIDSubstringFilter {
    nameOrIDSubstring: String!
}

"Filter to return GCP objects which have at least one label in the given list of labels."
input GcpNativeLabelFilter {
    labelFilterParams: [LabelFilterParams!]!
}

"Filter to return GCP GCE instances which have instance type in the given list of machine types."
input GcpNativeMachineTypeFilter {
    machineTypes: [String!]!
}

"Filter to return GCP GCE instances which have network name in the given list of network names."
input GcpNativeNetworkFilter {
    networkNames: [String!]!
}

"Filter to return GCP objects which have project rubrik ID in the given list of project rubrik IDs."
input GcpNativeProjectFilter {
    projectIds: [String!]!
}

"Filters for list of GCP projects."
input GcpNativeProjectFilters {
    effectiveSlaFilter: EffectiveSlaFilter
    nameOrNumberSubstringFilter: GcpNativeProjectNameOrNumberSubstringFilter
}

"Filter to return GCP projects with a given substring in their name or number."
input GcpNativeProjectNameOrNumberSubstringFilter {
    nameOrNumberSubstring: String!
}

"Filter to return GCP objects which have region in the given list of regions."
input GcpNativeRegionFilter {
    regions: [String!]!
}

input GenericTimeRangeInput {
    absoluteTimeRange: TimeRangeInput
    relativeTimeRange: RelativeTimeRangeInput
}

input GlobalSlaCreateRequest {
    archivalSpecInput: ArchivalSpecInput
    backupWindows: [BackupWindowInput!] = []
    description: String = ""
    firstFullBackupWindows: [BackupWindowInput!] = []
    localRetentionLimit: SlaDurationInput
    logConfig: LogConfig
    name: String = ""
    objectSpecificConfigsInput: ObjectSpecificConfigsInput
    objectTypeList: [SLAObjectTypeEnum!] = []
    replicationSpecInput: ReplicationSpecInput
    replicationSpecV2List: [ReplicationSpecV2Input!] = []
    snapshotSchedule: GlobalSnapshotScheduleInput
}

input GlobalSlaEditRequest {
    archivalSpecInput: ArchivalSpecInput
    backupWindows: [BackupWindowInput!] = []
    description: String = ""
    firstFullBackupWindows: [BackupWindowInput!] = []
    id: String = ""
    localRetentionLimit: SlaDurationInput
    logConfig: LogConfig
    name: String = ""
    objectSpecificConfigsInput: ObjectSpecificConfigsInput
    objectTypeList: [SLAObjectTypeEnum!] = []
    replicationSpecInput: ReplicationSpecInput
    replicationSpecV2List: [ReplicationSpecV2Input!] = []
    snapshotSchedule: GlobalSnapshotScheduleInput
    stateVersion: Long = 0
}

input GlobalSlaFilterInput {
    field: GlobalSlaQueryFilterInputField = NAME
    objectTypeList: [SLAObjectTypeEnum!] = []
    text: String = ""
}

input GlobalSnapshotScheduleInput {
    daily: DailySnapshotScheduleInput
    hourly: HourlySnapshotScheduleInput
    minute: MinuteSnapshotScheduleInput
    monthly: MonthlySnapshotScheduleInput
    quarterly: QuarterlySnapshotScheduleInput
    weekly: WeeklySnapshotScheduleInput
    yearly: YearlySnapshotScheduleInput
}

"group config"
input GroupConfig {
    name: String = ""
}

input GrowthRequest {
    archivalThreshold: Int = 0
    archiveRetention: Int = 0
    cloudRegion: String = ""
    daysBetweenFullSnapshots: Int = 0
    growthRate: Float = 0.0
    growthRateFrequencyType: FrequencyUnitEnum = DAILY
    initialBackupSize: Float = 0.0
    instantArchive: Boolean = false
    maxDaysToEvaluate: Int = 0
    maxRetention: Int = 0
    snapshotFrequency: Int = 0
    snapshotFrequencyType: FrequencyUnitEnum = DAILY
}

"""

Supported in v5.2+
"""
input HdfsBaseConfigInput {
    """

    Supported in v5.2+
    API token to access Hdfs
    """
    apiToken: String
    """

    Required. Supported in v5.2+
    List of Hdfs Namenode Hosts
    """
    hosts: [HdfsHostInput!] = []
    """

    Supported in v5.2+
    Ticket Cache Path of Kerberos Ticket
    """
    kerberosTicket: String
    """

    Supported in v5.2+
    Logical name for nameservice for Hdfs HA
    """
    nameservices: String
    """

    Supported in v5.2+
    Username to access Hdfs API
    """
    username: String
}

"""

Supported in v5.2+
"""
input HdfsConfigInput {
    hdfsBaseConfig: HdfsBaseConfigInput
}

"""

Supported in v5.2+
"""
input HdfsHostInput {
    """

    Required. Supported in v5.2+
    Hostname or Ip of Namenode
    """
    hostname: String = ""
    """

    Required. Supported in v5.2+
    Port number of Namenode
    """
    port: Int = 0
}

"""

Supported in v5.0+
"""
input HostRegisterInput {
    """

    Supported in v5.1+
    A user-specified string that returns this host in searches.
    """
    alias: String
    """

    Supported in v5.0+
    """
    hasAgent: Boolean
    """

    Supported in v5.2+
    """
    hdfsConfig: HdfsConfigInput
    """

    Required. Supported in v5.0+
    """
    hostname: String = ""
    """

    Supported in v5.2+
    A Boolean that specifies whether to discover Oracle information at registration. A value of 'true' discovers Oracle information at registration.
    """
    isOracleHost: Boolean
    """

    Supported in v5.0+
    """
    nasConfig: NasConfigInput
    """

    Supported in v5.0+
    Specifies the Oracle username for an account with query privileges. The account must have query privileges for a specified Oracle installation to enable Oracle discovery queries for that installation.
    """
    oracleQueryUser: String
    """

    Supported in v5.0+
    v5.0: Specifies the Oracle username for an account with sysdba privileges. The account must have sysdba privileges for a specified Oracle installation to enable backup and recovery of Oracle databases for that installation. This field overrides the configured global sysdba user for the specified Oracle installation.
    v5.1+: Specifies the Oracle username for an account with sysdba privileges. The account must have sysdba privileges for a specified Oracle installation to enable Oracle discovery queries for that installation. This field overrides the configured global sysdba user for the specified Oracle installation.
    """
    oracleSysDbaUser: String
    """

    Supported in v5.0+
    The ID of the organization to which the host is assigned.
    """
    organizationId: String
}

"""

Supported in v5.0+
"""
input HostUpdateIdInput {
    """

    Supported in v5.0+
    ID of the host.
    """
    hostId: String = ""
    """

    Supported in v5.0+
    """
    updateProperties: HostUpdateInput
}

"""

Supported in v5.0+
"""
input HostUpdateInput {
    """

    Supported in v5.1+
    A user-specified string that returns this host in searches.
    """
    alias: String
    """

    Supported in v5.0+
    """
    compressionEnabled: Boolean
    """

    Supported in v5.2+
    """
    hdfsConfig: HdfsConfigInput
    """

    Supported in v5.0+
    When VFD is disabled on the specified Windows host, set this property to false to instruct the Rubrik cluster to remove the VFD driver from a specified Windows host. Before using this property, disable VFD on the specified Windows host by setting the value of HostVfdEnabled to Disabled.
    """
    hostVfdDriverInstalled: Boolean
    """

    Supported in v5.0+
    """
    hostVfdEnabled: HostVfdInstallConfigEnum = HOST_VFD_INSTALL_CONFIG_EMPTY_VALUE
    """

    Supported in v5.0+
    """
    hostname: String
    """

    Supported in v5.2+
    A Boolean that specifies whether to discover Oracle information during host refresh. A value of 'true' discovers Oracle information during host refresh.
    """
    isOracleHost: Boolean
    """

    Supported in v5.0+
    When CBT is disabled on the specified Windows host, set this property to false to instruct the Rubrik cluster to remove the CBT driver from a specified Windows host. Before using this property, disable CBT on the specified Windows host by setting the value of mssqlCbtEnabled to Disabled.
    """
    mssqlCbtDriverInstalled: Boolean
    """

    Supported in v5.0+
    """
    mssqlCbtEnabled: MssqlCbtStatusTypeEnum = MSSQL_CBT_STATUS_TYPE_EMPTY_VALUE
    """

    Supported in v5.0+
    """
    nasConfig: NasConfigInput
    """

    Supported in v5.0+
    Specifies the Oracle username for an account with query privileges. The account must have query privileges for a specified Oracle installation to enable Oracle discovery queries for that installation.
    """
    oracleQueryUser: String
    """

    Supported in v5.0+
    v5.0: Specifies the Oracle username for an account with sysdba privileges. The account must have sysdba privileges for a specified Oracle installation to enable backup and recovery of Oracle databases for that installation. This field overrides the configured global sysdba user for the specified Oracle installation.
    v5.1+: Specifies the Oracle username for an account with sysdba privileges. The account must have sysdba privileges for a specified Oracle installation to enable Oracle discovery queries for that installation. This field overrides the configured global sysdba user for the specified Oracle installation.
    """
    oracleSysDbaUser: String
}

input HourlySnapshotScheduleInput {
    basicSchedule: BasicSnapshotScheduleInput
}

input InstantRecoveryJobConfig {
    baseConfig: AppBlueprintRestoreSnapshotJobConfigBase
    childrenToRestore: [AppBlueprintChildSnappableInstantRecoverySpec!] = []
    shouldRemoveChildrenFromAppBlueprint: Boolean = false
    shouldRemoveChildrenFromOtherAppBlueprints: Boolean = false
}

input InterfaceCidrInput {
    cidr: String = ""
    interfaceType: InterfaceTypeEnum = UNKNOWN_TYPE
    selected: Boolean = false
}

"Label filter parameters for GCP objects."
input LabelFilterParams {
    filterType: GcpNativeLabelFilterTypeEnum!
    labelKey: String!
    labelValue: String!
}

"DataType representing label key-value pair"
input LabelType {
    labelKey: String!
    labelValue: String!
    matchAllValues: Boolean!
}

"LDAP Server"
input LdapServerInput {
    hostname: String = ""
    port: Int = 0
    useTls: Boolean = false
}

"""

Supported in v5.2+
"""
input LegalHoldDownloadConfigInput {
    """

    Supported in v5.2+
    v5.2: Specifies whether the download action is in response to a Legal Hold. This download generates a SHA1 checksum of downloaded data that is used for integrity verification by external bodies.
    v5.3: Specifies if the download action is in response to a Legal Hold. This download generates a SHA1 checksum of downloaded data that external bodies can use for integrity verification.
    """
    isLegalHoldDownload: Boolean = false
}

input ListFileResultFiltersInput {
    analyzerGroupIds: [String!] = []
    fileType: FileCountTypeEnum!
    searchText: String = ""
    snappablePaths: [SnappablePathInput!] = []
    snappableTypes: [String!] = []
    whitelistEnabled: Boolean = false
}

input LogConfig {
    slaLogFrequencyConfig: SlaLogFrequencyConfig
}

input ManualTargetMappingCreateRequest {
    archivalLocationClusterMappings: [TargetToClusterMapping!] = []
    name: String = ""
    type: TargetTypeEnum = AWS
}

input ManualTargetMappingEditRequest {
    archivalLocationClusterMappings: [TargetToClusterMapping!] = []
    id: String = ""
    name: String = ""
}

input MinuteSnapshotScheduleInput {
    basicSchedule: BasicSnapshotScheduleInput
}

input MissedSnapshotFilterInput {
    timeRange: TimeRangeInput
}

input MonthlySnapshotScheduleInput {
    basicSchedule: BasicSnapshotScheduleInput
    dayOfMonth: DayOfMonthEnum = FIRST_DAY
}

"""

Supported in v5.0+
"""
input MountExportSnapshotJobCommonOptionsInput {
    """

    Supported in v5.0+
    Sets the state of the network interfaces when the virtual machine is mounted or exported. Use 'false' to enable the network interfaces. Use 'true' to disable the network interfaces. Disabling the interfaces can prevent IP conflicts.
    """
    disableNetwork: Boolean
    """

    Supported in v5.0+
    Determines whether the MAC addresses of the network interfaces on the source virtual machine are assigned to the new virtual machine. Set to 'true' to assign the original MAC addresses to the new virtual machine. Set to 'false' to assign new MAC addresses. The default is 'false'. When removeNetworkDevices is set to true, this property is ignored.
    """
    keepMacAddresses: Boolean
    """

    Supported in v5.0+
    Determines whether the virtual machine should be powered on after mount or export. Set to 'true' to power on the virtual machine. Set to 'false' to mount or export the virtual machine but not power it on. The default is 'true'.
    """
    powerOn: Boolean
    """

    Supported in v5.0+
    Determines whether to remove the network interfaces from the mounted or exported virtual machine. Set to 'true' to remove all network interfaces. The default value is 'false'.
    """
    removeNetworkDevices: Boolean
    """

    Supported in v5.0+
    Name of the new VM created by mount or export
    """
    vmName: String
}

"""

Supported in v5.0+
"""
input MountSnapshotJobConfigForBatchV1Input {
    """

    Required. Supported in v5.0+
    Snapshot mount config
    """
    config: MountSnapshotJobConfigV1Input
    """

    Supported in v5.0+
    Mounts the oldest snapshot taken after the specified date. This parameter is only evaluated when no values are set for snapshotId and snapshotBeforeDate.
    """
    snapshotAfterDate: DateTime
    """

    Supported in v5.0+
    Mounts the most recent snapshot prior to the specified date. This parameter is only evaluated when no value is set for snapshotId.
    """
    snapshotBeforeDate: DateTime
    """

    Supported in v5.0+
    ID of snapshot to mount. Optional. The snapshot to mount is determined from the other parameters in this call when the ID is not provided.
    """
    snapshotId: String
    """

    Supported in v5.0+
    v5.0: Mount a snapshot from this virtual machine.
    v5.1+: Mount a snapshot from this virtual machine
    """
    vmId: String = ""
}

"""

Supported in v5.0+
"""
input MountSnapshotJobConfigV1Input {
    """

    Supported in v5.0+
    The job creates a datastore that contains the VMDK, but does not create the corresponding virtual machine.
    """
    createDatastoreOnly: Boolean
    """

    Supported in v5.0+
    v5.0: Name of the host NAS datastore to use with the new virtual machine. The Rubrik cluster creates a new datastore on the host using the provided name.
    v5.1+: Obsolete parameter.
    """
    dataStoreName: String
    """

    Supported in v5.0+
    ID of the ESXi host to mount the new virtual machine on.
    """
    hostId: String
    mountExportSnapshotJobCommonOptions: MountExportSnapshotJobCommonOptionsInput
    """

    Supported in v5.0+
    The job recovers the tags that were assigned to the virtual machine.
    """
    shouldRecoverTags: Boolean
    """

    Supported in v5.0+
    VLAN ID for the VLAN ESXi host prefer to use for mounting the datastore.
    """
    vlan: Int
}

"Filter to return objects with a given substring in their name."
input NameSubstringFilter {
    nameSubstring: String!
}

"""

Supported in v5.0+
"""
input NasConfigInput {
    """

    Supported in v5.0+
    TLS certification to validate NAS server
    """
    apiCertificate: String
    """

    Supported in v5.0+
    API endpoint to access NAS API 'FLASHBLADE'
    """
    apiEndpoint: String
    """

    Supported in v5.0+
    Hostname or IP used in the NAS API calls
    """
    apiHostname: String
    """

    Supported in v5.0+
    Password to access NAS API 'ISILON/NETAPP'
    """
    apiPassword: String
    """

    Supported in v5.0+
    API token to access NAS API 'FLASHBLADE'
    """
    apiToken: String
    """

    Supported in v5.0+
    Username to access NAS API 'ISILON/NETAPP'
    """
    apiUsername: String
    """

    Supported in v5.2+
    v5.2: A Boolean value that specifies whether Changelist is enabled on Isilon NAS share. When this value is 'true', metadata fetches during backup operations use the Isilon Changelist feature. The Changelist feature improves incremental backup performance by tracking the difference between two snapshots, reducing the metadata scanning time during a backup job.
    v5.3: Indicates if Changelist is enabled on Isilon NAS share. When this value is 'true', metadata fetches during backup operations use the Isilon Changelist feature. The Changelist feature improves incremental backup performance by tracking the difference between two snapshots, reducing the metadata scanning time during a backup job.
    """
    isIsilonChangelistEnabled: Boolean
    """

    Supported in v5.2+
    v5.2: A Boolean value that specifies whether SnapDiff is enabled on NetApp NAS share. When this value is 'true', metadata fetches during backup operations use the NetApp SnapDiff feature. The SnapDiff feature improves incremental backup performance by tracking the difference between two snapshots, reducing the metadata scanning time during a backup job.
    v5.3: Indicates if SnapDiff is enabled on NetApp NAS share. When this value is 'true', metadata fetches during backup operations use the NetApp SnapDiff feature. The SnapDiff feature improves incremental backup performance by tracking the difference between two snapshots, reducing the metadata scanning time during a backup job.
    """
    isNetAppSnapDiffEnabled: Boolean
    """

    Supported in v5.3
    Specifies whether shares on the NAS host are automatically discovered. When this value is 'true', Rubrik periodically (every 30 minutes by default) connects to the NAS host to discover NFS and SMB shares.
    """
    isShareAutoDiscoveryEnabled: Boolean
    """

    Supported in v5.1
    Control if snapdiff is enabled on Netapp NAS
    """
    isSnapdiffEnabled: Boolean
    """

    Supported in v5.0+
    Type of NAS vendor 'ISILON/NETAPP/FLASHBLADE'
    """
    vendorType: String = ""
    """

    Supported in v5.0+
    Name of the Isilon zone that data IP belongs to
    """
    zoneName: String
}

"new compute config"
input NewComputeConfig {
    securityGroupName: String = ""
    subnetName: String = ""
    vnetName: String = ""
}

"new storage account config"
input NewStorageAccountConfig {
    name: String = ""
    sku: SkuEnum = STANDARD_LRS
    tier: TierEnum = COOL
}

input NfsTargetCreateRequest {
    clusterUuid: UUID!
    destinationFolder: String!
    encryptionPassword: String!
    exportDir: String!
    fileLockPeriodInSeconds: Int!
    host: String!
    isConsolidationEnabled: Boolean!
    name: String!
    nfsAuthType: AuthTypeEnum!
    nfsVersion: Int
    otherNfsOptions: String
}

input NfsTargetEditRequest {
    exportDir: String
    fileLockPeriodInSeconds: Int
    host: String
    id: UUID!
    isConsolidationEnabled: Boolean
    name: String
    nfsAuthType: AuthTypeEnum
}

input ObjectIdsForHierarchyTypeInput {
    objectIds: [String!]!
    snappableType: SnappableLevelHierarchyTypeEnum!
}

input ObjectSpecificConfigsInput {
    awsRdsConfigInput: AwsRdsConfigInput
    sapHanaConfigInput: SapHanaConfigInput
    vmwareVmConfigInput: VmwareVmConfigInput
}

input OldRestorePathPairInput {
    path: String = ""
    restorePath: String = ""
}

"Parameters for onedrive file or folder search"
input OnedriveSearchFilter {
    createTime: TimeRangeFilter
    modifiedTime: TimeRangeFilter
    searchKeywordFilter: OnedriveSearchKeywordFilter
    searchObjectFilter: OnedriveSearchObjectFilter
}

"Onedrive search keyword and keyword type"
input OnedriveSearchKeywordFilter {
    keywordType: OnedriveSearchKeywordTypeEnum = NAME
    searchKeyword: String = ""
}

"Onedrive search object type"
input OnedriveSearchObjectFilter {
    searchObjectType: OnedriveSearchObjectTypeEnum = O365_FOLDER
}

input PermissionInput {
    objectsForHierarchyTypes: [ObjectIdsForHierarchyTypeInput!]!
    operation: OperationEnum!
}

input PolarisSnapshotFilterInput {
    isOnDemandSnapshot: Boolean
    snappableId: [String!]
    timeRange: TimeRangeInput
}

input PolarisSnapshotFilterNewInput {
    field: FieldEnum = ALL
    texts: [String!] = []
}

input PostBackupScriptInputType {
    failureHandling: String
    scriptPath: String
    timeoutInMs: Long
}

input PostSnapScriptInputType {
    failureHandling: String
    scriptPath: String
    timeoutInMs: Long
}

input PreBackupScriptInputType {
    failureHandling: String
    scriptPath: String
    timeoutInMs: Long
}

input PreviewerClusterConfigInput {
    clusterId: String = ""
    enabled: Boolean = false
}

input ProxySettingsInput {
    password: String = ""
    portNumber: Int = 0
    protocol: String = ""
    proxyServer: String = ""
    username: String = ""
}

input QuarterlySnapshotScheduleInput {
    basicSchedule: BasicSnapshotScheduleInput
    dayOfQuarter: DayOfQuarterEnum = FIRST_DAY
    quarterStartMonth: MonthEnum = JANUARY
}

"Filter ransomware result data."
input RansomwareResultFilterInput {
    clusterUuid: [UUID!]
    endTime: DateTime
    isEncrypted: Boolean
    managedId: [String!]
    startTime: DateTime
}

input RelativeTimeRangeInput {
    magnitude: Int!
    unit: TimeUnitEnum!
}

"Filter to return objects which are relic or not."
input RelicFilter {
    relic: Boolean!
}

input ReplicationSpecInput {
    replicationType: ReplicationTypeEnum = UNKNOWN_REPLICATION_TYPE
    specificReplicationSpecInput: SpecificReplicationSpecInput
}

input ReplicationSpecV2Input {
    awsAccount: String = ""
    awsRegion: AwsNativeRegionForReplicationEnum
    azureRegion: AzureNativeRegionForReplicationEnum
    azureSubscription: String = ""
    clusterUuid: String = ""
    retentionDuration: SlaDurationInput
    storageSettingId: String = ""
}

input ReplicationToCloudLocationSpecInput {
    cloudProvider: CloudProviderEnum = AWS
    replicationTargetId: String = ""
    retentionDuration: SlaDurationInput
}

input ReplicationToCloudRegionSpecInput {
    cloudProvider: CloudProviderEnum = AWS
    replicationTargetRegion: String = ""
    retention: Int = 0
    retentionUnit: RetentionUnitEnum = MINUTES
}

"Create configs for a snappable data chart."
input ReportChartCreate {
    "The metrics focus of the chart."
    focus: ReportFocusEnum!
    groupBy: [GroupByFieldEnum!]
    "The name of the chart."
    name: String!
}

input ReportConfigInput {
    aggregations: [String!]!
    chartConfigs: [ChartConfigInput!]!
    columns: [String!]!
    dataViewType: DataViewTypeEnum!
    filters: [ReportFilterInput!]!
    groupBy: [String!]!
    name: String!
    sortBy: String!
    sortOrder: SortOrderEnum
}

input ReportFilterInput {
    name: String!
    "values are JSON serialized string of the original value"
    values: [String]!
}

"Create configs for an activity data table."
input ReportTableCreate {
    focus: ReportFocusEnum!
    groupBy: [GroupByFieldEnum!]
    "The name of the table."
    name: String!
    selectedColumns: [ReportTableColumnEnum!]!
    sortBy: SortByFieldEnum
    "The data sorting order for the table, Asc or Des."
    sortOrder: SortOrderEnum
}

input ResourceInput {
    snappableFid: String = ""
    snapshotFid: String = ""
}

input RestoreConfig {
    deltaTypeFilter: [DeltaTypeEnum!] = []
    domainName: String = ""
    nextSnapshotFid: String = ""
    password: String = ""
    restoreFilesConfig: [RestoreFileConfig!] = []
    shouldIgnoreErrors: Boolean = false
    shouldRestoreXAttrs: Boolean
    shouldSaveCredentials: Boolean = false
    shouldUseAgent: Boolean
    username: String = ""
}

input RestoreFileConfig {
    path: String = ""
    restorePath: String = ""
}

"""

Supported in v5.0+
"""
input RestoreFilesJobConfigInput {
    """

    Supported in v5.1+
    Managed ID of the destination object that the files should be recovered to.
    """
    destObjectId: String
    """

    Supported in v5.0+
    Domain name (Use . for local admin)
    """
    domainName: String
    """

    Supported in v5.0+
    v5.0: Optional field to determine whether to ignore errors during restore jobs that use the Rubrik Backup Service. Default value is false, errors are not ignored.
    v5.1+: Optional Boolean field to determine whether to ignore errors during restore jobs that use the Rubrik Backup Service. When 'true', errors are ignored. Default value is 'false', errors are not ignored.
    """
    ignoreErrors: Boolean
    """

    Supported in v5.0+
    Password
    """
    password: String
    """

    Supported in v5.0+
    Absolute file path and restore path if not restored back to itself
    """
    restoreConfig: [VmRestorePathPairInput!] = []
    """

    Supported in v5.1+
    Boolean value that determines restore file settings for Linux systems and for Windows systems. For Linux, use 'true' to include the extended attributes of restored files. For Windows, use 'true' to include alternate data streams for restored files. For both, use 'false' to exclude this additional metadata.
    """
    shouldRestoreXAttrs: Boolean
    """

    Supported in v5.0+
    v5.0: Whether we should save the user-entered credentials
    v5.1+: A Boolean value that specifies whether to save the user-entered credentials. When 'true', the user-entered credentials are saved.
    """
    shouldSaveCredentials: Boolean
    """

    Supported in v5.1+
    A Boolean that specifies whether to use the Rubrik Backup Service or VMware tools to restore files. When 'true', the RBS restores files. When 'false',the VMware tools restores files.
    """
    shouldUseAgent: Boolean
    """

    Supported in v5.0+
    Username
    """
    username: String
}

"Config for O365 mailbox restore"
input RestoreO365MailboxInput {
    mailboxUUID: UUID!
    restoreConfigs: [RestoreObjectConfig!]!
    snapshotUUID: UUID
}

"Config for the mailbox object (email/folder) to be restored"
input RestoreObjectConfig {
    EmailUUID: UUID
    FolderUUID: UUID
    SnapshotUUID: UUID!
}

"""

Supported in v5.0+
"""
input RestorePathPairInput {
    """

    Required. Supported in v5.0+
    Original file path to be restored
    """
    path: String = ""
    """

    Supported in v5.0+
    Directory of the folder to copy files into. If this is empty, file will be restored back into original directory.
    """
    restorePath: String
}

input RunCustomAnalyzerInput {
    content: String = ""
    dictionaryCsv: String = ""
    regex: String = ""
}

input SapHanaConfigInput {
    incrementalFrequency: SlaDurationInput
    logRetention: SlaDurationInput
}

"Filter Sap Hana log snapshots."
input SapHanaLogSnapshotFilterInput {
    clusterUuid: [UUID!]
    fromTime: DateTime
    isArchived: Boolean
    snappableId: [String!]
    toTime: DateTime
}

"Filter Sap Hana recoverable ranges."
input SapHanaRecoverableRangeFilterInput {
    clusterUuid: [UUID!]
    databaseId: [String!]
    fromTime: DateTime
    isArchived: Boolean
    toTime: DateTime
}

input SapHanaSystemConfigInput {
    "The SAP HANA system hosts."
    hostIds: [String!] = []
    "The instance number of the SAP HANA system."
    instanceNumber: String = ""
    "Required. The password of the SAP HANA system."
    password: String = ""
    "Required. The SAP System Identification (SID) code for the SAP HANA system."
    sid: String = ""
    "Required. The username of the SAP HANA system."
    username: String = ""
}

input SapHanaSystemPatchInput {
    "The ID of the SLA Domain that is configured for the SAP HANA system."
    configuredSlaDomainId: String
    "The SAP HANA system hosts."
    hostIds: [String!] = []
    "The instance number of the SAP HANA system."
    instanceNumber: String
    "The password of the SAP HANA system."
    password: String
    "The SAP System Identification (SID) code for the SAP HANA system."
    sid: String
    "The username of the SAP HANA system."
    username: String
}

input ScheduledReportCreate {
    creatorId: String
    dailyTime: LocalTime
    hasCSVAttachment: Boolean!
    hasPDFAttachment: Boolean!
    monthlyDate: Int
    monthlyTime: LocalTime
    recipients: [String!]!
    "Chart configs for the report."
    reportId: Int!
    title: String!
    weeklyDays: [WeekDayEnum!]
    weeklyTime: LocalTime
}

"Filters for the scheduled report list"
input ScheduledReportFilterInput {
    reportId: Int
}

"Parameters for mail or folder search"
input SearchFilter {
    emailAddresses: [EmailAddressFilter!] = []
    fromTime: DateTime
    searchKeywordFilter: SearchKeywordFilter
    searchObjectFilter: SearchObjectFilter
    untilTime: DateTime
}

"Search keyword and keyword type"
input SearchKeywordFilter {
    keywordType: SearchKeywordTypeEnum = SUBJECT
    searchKeyword: String = ""
}

"Search object type"
input SearchObjectFilter {
    searchObjectType: SearchObjectTypeEnum = FOLDER
}

input SlaDurationInput {
    duration: Int = 0
    unit: RetentionUnitEnum = MINUTES
}

input SlaLogFrequencyConfig {
    retention: SlaDurationInput
}

input SnappableFailoverInfoType {
    recoveryPoint: Long!
    snappableId: String!
}

"Filter snappable data."
input SnappableFilterInput {
    cluster: CommonClusterFilterInput
    complianceStatus: [ComplianceStatusEnum!]
    objectType: [ObjectTypeEnum!]
    protectionStatus: [ProtectionStatusEnum!]
    searchTerm: String
    slaDomain: SnappableSlaDomainFilterInput
}

"Filter snappable data (including search capability)."
input SnappableFilterInputWithSearch {
    cluster: CommonClusterFilterInput
    complianceStatus: [ComplianceStatusEnum!]
    objectType: [ObjectTypeEnum!]
    protectionStatus: [ProtectionStatusEnum!]
    searchTerm: String
    slaDomain: SnappableSlaDomainFilterInput
    timeRange: TimeRangeInput
}

"Filter snappable data in group by."
input SnappableGroupByFilterInput {
    cluster: CommonClusterFilterInput
    complianceStatus: [ComplianceStatusEnum!]
    objectType: [ObjectTypeEnum!]
    protectionStatus: [ProtectionStatusEnum!]
    slaDomain: SnappableSlaDomainFilterInput
    timeRange: TimeRangeInput
}

input SnappablePathInput {
    snappableFid: String = ""
    stdPath: String = ""
}

"Filter snappable data based on properties of its Sla domain."
input SnappableSlaDomainFilterInput {
    id: [String!]
}

input SnapshotDeltaFilterInput {
    deltaType: [DeltaTypeEnum!]
}

input SnapshotQueryFilterInput {
    field: SnapshotQueryFilterField = SLA_ID
    text: String = ""
    typeFilters: [SnapshotTypeEnum!] = []
}

input SonarContentReportFilter {
    applyWhitelists: Boolean = false
    clusterIds: [String!] = []
    objectTypes: [HierarchyObjectTypeEnum!]!
    policyIds: [String!] = []
    search: String = ""
}

input SpecificReplicationSpecInput {
    bidirectionalSpecInput: BidirectionalReplicationSpecInput
    cloudLocationSpecInput: ReplicationToCloudLocationSpecInput
    cloudRegionSpecInput: ReplicationToCloudRegionSpecInput
    unidirectionalSpecInput: UnidirectionalReplicationSpecInput
}

input StartTimeAttributesInput {
    dayOfWeek: DayOfWeekOptInput
    hour: Int = 0
    minute: Int = 0
}

"TagFilterParams"
input TagFilterParams {
    filterType: TagFilterType = TAG_KEY
    tagKey: String = ""
    tagValue: String = ""
}

"DataType representing tag key-value pair"
input TagType {
    matchAllValues: Boolean!
    tagKey: String!
    tagValue: String!
}

input TargetFilterInput {
    field: TargetQueryFilterFieldEnum = NAME
    text: String = ""
}

input TargetMappingDeleteRequest {
    id: String = ""
}

input TargetMappingFilterInput {
    field: TargetMappingQueryFilterFieldEnum = NAME
    text: String = ""
}

input TargetToClusterMapping {
    clusterUuid: String = ""
    locationId: String = ""
}

"Filter task detail"
input TaskDetailFilterInput {
    clusterLocation: [String!]
    clusterType: [String!]
    clusterUuid: [UUID!]
    objectType: [String!]
    replicationSource: [String!]
    searchTerm: String
    slaDomain: SnappableSlaDomainFilterInput
    taskCategory: [String!]
    taskStatus: [String!]
    taskType: [String!]
    time_gt: DateTime
    time_lt: DateTime
}

"Filter task summary"
input TaskSummaryFilterInput {
    cluster: CommonClusterFilterInput
    objectType: [ObjectTypeEnum!]
    slaDomain: SnappableSlaDomainFilterInput
    time_gt: DateTime
    time_lt: DateTime
}

input TimeFilterInput {
    endTime: String = ""
    startTime: String = ""
    timeDuration: TimeDurationEnum = HOUR
    timezone: String = ""
}

"Timerange filter"
input TimeRangeFilter {
    fromTime: DateTime
    untilTime: DateTime
}

input TimeRangeInput {
    end: DateTime!
    start: DateTime!
}

input UnidirectionalReplicationSpecInput {
    replicationTargetId: String = ""
    retention: Int = 0
    retentionUnit: RetentionUnitEnum = MINUTES
}

"Filter User Audit data"
input UserAuditFilterInput {
    cluster: CommonClusterFilterInput
    clusterIds: [UUID!]
    searchTerm: String
    status: [UserAuditStatusEnum!]
    time_gt: DateTime
    time_lt: DateTime
    userAuditObjectType: [UserAuditObjectTypeEnum!]
    userAuditSeverity: [UserAuditSeverityEnum!]
    userAuditType: [UserAuditTypeEnum!]
}

input UserGroupToRolesInput {
    roleIds: [String!] = []
    userGroupId: String = ""
}

input VSphereMountFilter {
    clusterUuid: [UUID!]
    name: String
    powerStatus: [Boolean!]
    sourceVmId: UUID
}

input VSphereVMNicSpecInputType {
    adapterType: NetworkAdapterTypeEnum = E1000
    dnsInfos: [String!] = []
    gateway: String = ""
    ipv4Address: String = ""
    ipv6Address: String = ""
    isPrimaryNic: Boolean = false
    key: String = ""
    netmask: String = ""
    networkId: String = ""
    networkMoid: String = ""
    networkType: NetworkTypeEnum = STATIC
}

input VSphereVMRecoverySpecInputType {
    hostCdmId: String = ""
    hostId: String = ""
    hostName: String = ""
    memoryMbs: Int = 0
    nics: [VSphereVMNicSpecInputType!] = []
    userData: String = ""
    vcenterCdmId: String = ""
    vcenterId: String = ""
    vcenterName: String = ""
    vcpus: Int = 0
    version: Long = 0
    volumes: [VSphereVMVolumeSpecInputType!] = []
}

input VSphereVMVolumeSpecInputType {
    dataStoreCdmId: String = ""
    dataStoreId: String = ""
    "key value defined in Ebs Volume"
    key: String = ""
    sizeGbs: Int = 0
}

input VSphereVirtualDiskFilter {
    clusterUuid: [UUID!]
    fileName: String
    sourceVmId: UUID
}

input VmDiskUpdateInput {
    excludeFromSnapshots: Boolean
    virtualDiskFid: UUID!
}

"""

Supported in v5.0+
"""
input VmRestorePathPairInput {
    restorePathPair: RestorePathPairInput
}

input VmwareVmConfigInput {
    logRetentionSeconds: Long = 0
}

input VolumeIdToIsExcluded {
    isExcluded: Boolean!
    volumeId: String!
}

input WeeklySnapshotScheduleInput {
    basicSchedule: BasicSnapshotScheduleInput
    dayOfWeek: DayOfWeekEnum = MONDAY
}

input YearlySnapshotScheduleInput {
    basicSchedule: BasicSnapshotScheduleInput
    dayOfYear: DayOfYearEnum = FIRST_DAY
    yearStartMonth: MonthEnum = JANUARY
}

"GCP KMS Crypto Key"
input kmsCryptoKey {
    key: String = ""
    keyRing: String = ""
    location: String = ""
    projectNativeId: String = ""
}


scalar AnyScalar

scalar DateTime

"The `LocalTimeType` scalar type a time of day (i.e., between 00:00 and 23:59) WITHOUT an associated timezone. The timezone is assumed to be the local timezone, so if you want an explicit timezone you'll need to associate it explicitly."
scalar LocalTime

scalar UUID

"The `Long` scalar type represents non-fractional signed whole numeric values. Long can represent values between -(2^63) and 2^63 - 1."
scalar Long